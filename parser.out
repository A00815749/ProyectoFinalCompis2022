Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    STR
    TRUE
    FALSE
    MEDIA
    MEDIANA
    MODA
    VARIANZA
    STDEV
    PLOTXY

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
Rule 2     neuraltablefunctions -> ID
Rule 3     varsgl -> VARS vars
Rule 4     varsgl -> empty
Rule 5     vars -> typing COLON neuralinsertvar varsarr varsmul vars
Rule 6     vars -> empty
Rule 7     neuralinsertvar -> ID
Rule 8     varsarr -> LEFTSQR CTEINT RIGHTSQR
Rule 9     varsarr -> empty
Rule 10    varsmul -> COMMA neuralinsertvar varsarr varsmul
Rule 11    varsmul -> SEMICOLON
Rule 12    modules -> FUNCTION functype neuralinsertfuncname funcparam
Rule 13    modules -> empty
Rule 14    neuralinsertfuncname -> ID
Rule 15    functype -> VOID
Rule 16    functype -> typing
Rule 17    funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules
Rule 18    neuralendfuncs -> <empty>
Rule 19    typing -> INT
Rule 20    typing -> FLOAT
Rule 21    typing -> CHAR
Rule 22    parameters -> typing COLON ID idarray mulparams
Rule 23    parameters -> empty
Rule 24    mulparams -> COMMA parameters
Rule 25    mulparams -> empty
Rule 26    statutes -> assign statutesaux
Rule 27    statutes -> reading statutesaux
Rule 28    statutes -> writing statutesaux
Rule 29    statutes -> returning statutesaux
Rule 30    statutes -> ifing statutesaux
Rule 31    statutes -> whiling statutesaux
Rule 32    statutes -> foring statutesaux
Rule 33    statutes -> exp statutesaux
Rule 34    statutes -> specialfunc statutesaux
Rule 35    statutesaux -> statutes
Rule 36    statutesaux -> empty
Rule 37    specialfunc -> empty
Rule 38    assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON
Rule 39    neuralassign1 -> ID
Rule 40    neuralassign2 -> EQUAL
Rule 41    writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
Rule 42    auxwrite -> writetyping
Rule 43    auxwrite -> exp
Rule 44    writetyping -> STRING
Rule 45    writetyping -> CTECHAR
Rule 46    mulwrite -> COMMA auxwrite mulwrite
Rule 47    mulwrite -> empty
Rule 48    reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
Rule 49    neuralread -> ID
Rule 50    mulread -> COMMA ID idarray mulread
Rule 51    mulread -> empty
Rule 52    returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON
Rule 53    ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
Rule 54    neuralif -> RIGHTPAR
Rule 55    elsing -> neuralelse LEFTBR statutes RIGHTBR
Rule 56    elsing -> empty
Rule 57    neuralelse -> ELSE
Rule 58    whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
Rule 59    neuralwhile1 -> WHILE
Rule 60    neuralwhile2 -> RIGHTPAR
Rule 61    foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
Rule 62    neuralfor1 -> ID
Rule 63    neuralfor2 -> TO
Rule 64    neuralfor3 -> DO
Rule 65    idarray -> LEFTSQR exp RIGHTSQR
Rule 66    idarray -> empty
Rule 67    exp -> andexp exp1
Rule 68    exp1 -> OR exp
Rule 69    exp1 -> empty
Rule 70    andexp -> boolexp andexp1
Rule 71    andexp1 -> neuraland andexp
Rule 72    andexp1 -> empty
Rule 73    neuraland -> AND
Rule 74    boolexp -> arithexp boolexp1
Rule 75    boolexp1 -> neuralbool arithexp
Rule 76    boolexp1 -> empty
Rule 77    neuralbool -> GREATER
Rule 78    neuralbool -> GREATERAND
Rule 79    neuralbool -> LESSER
Rule 80    neuralbool -> LESSERAND
Rule 81    neuralbool -> SAME
Rule 82    neuralbool -> NOTSAME
Rule 83    neuralbool -> NOT
Rule 84    arithexp -> geoexp arithexp1
Rule 85    arithexp1 -> neuralarith arithexp
Rule 86    arithexp1 -> empty
Rule 87    neuralarith -> PLUS
Rule 88    neuralarith -> REST
Rule 89    geoexp -> finexp geoexp1
Rule 90    geoexp1 -> neuralgeo geoexp
Rule 91    geoexp1 -> empty
Rule 92    neuralgeo -> TIMES
Rule 93    neuralgeo -> DIVIDE
Rule 94    addparenth -> LEFTPAR
Rule 95    popparenth -> RIGHTPAR
Rule 96    finexp -> addparenth exp popparenth
Rule 97    finexp -> cteexp
Rule 98    cteexp -> CTEINT
Rule 99    cteexp -> CTEFLOAT
Rule 100   cteexp -> CTECHAR
Rule 101   cteexp -> ID paramsexp
Rule 102   paramsexp -> LEFTPAR paramsexp2 RIGHTPAR
Rule 103   paramsexp -> idarray
Rule 104   paramsexp2 -> exp auxparamsexp2
Rule 105   paramsexp2 -> empty
Rule 106   auxparamsexp2 -> COMMA exp auxparamsexp2
Rule 107   auxparamsexp2 -> empty
Rule 108   empty -> <empty>
Rule 109   debug -> empty

Terminals, with rules where they appear

AND                  : 73
CHAR                 : 21
COLON                : 5 22
COMMA                : 10 24 46 50 106
CTECHAR              : 45 100
CTEFLOAT             : 99
CTEINT               : 8 98
DIVIDE               : 93
DO                   : 58 64
ELSE                 : 57
EQUAL                : 40 61
FALSE                : 
FLOAT                : 20
FOR                  : 61
FUNCTION             : 12
GREATER              : 77
GREATERAND           : 78
ID                   : 2 7 14 22 39 49 50 62 101
IF                   : 53
INT                  : 19
LEFTBR               : 1 17 53 55 58 61
LEFTPAR              : 1 17 41 48 52 53 58 94 102
LEFTSQR              : 8 65
LESSER               : 79
LESSERAND            : 80
MAIN                 : 1
MEDIA                : 
MEDIANA              : 
MODA                 : 
NOT                  : 83
NOTSAME              : 82
OR                   : 68
PLOTXY               : 
PLUS                 : 87
PROGRAM              : 1
READ                 : 48
REST                 : 88
RETURN               : 52
RIGHTBR              : 1 17 53 55 58 61
RIGHTPAR             : 1 17 41 48 52 54 60 95 102
RIGHTSQR             : 8 65
SAME                 : 81
SEMICOLON            : 1 11 17 38 41 48 52
STDEV                : 
STR                  : 
STRING               : 44
THEN                 : 53
TIMES                : 92
TO                   : 63
TRUE                 : 
VARIANZA             : 
VARS                 : 3
VOID                 : 15
WHILE                : 59
WRITE                : 41
error                : 

Nonterminals, with rules where they appear

addparenth           : 96
andexp               : 67 71
andexp1              : 70
arithexp             : 74 75 85
arithexp1            : 84
assign               : 26
auxparamsexp2        : 104 106
auxwrite             : 41 46
boolexp              : 70
boolexp1             : 74
cteexp               : 97
debug                : 
elsing               : 53
empty                : 4 6 9 13 23 25 36 37 47 51 56 66 69 72 76 86 91 105 107 109
exp                  : 33 38 43 52 53 58 61 61 65 68 96 104 106
exp1                 : 67
finexp               : 89
foring               : 32
funcparam            : 12
functype             : 12
geoexp               : 84 90
geoexp1              : 89
idarray              : 22 38 48 50 61 103
ifing                : 30
modules              : 1 17
mulparams            : 22
mulread              : 48 50
mulwrite             : 41 46
neuraland            : 71
neuralarith          : 85
neuralassign1        : 38
neuralassign2        : 38
neuralbool           : 75
neuralelse           : 55
neuralendfuncs       : 17
neuralfor1           : 61
neuralfor2           : 61
neuralfor3           : 61
neuralgeo            : 90
neuralif             : 53
neuralinsertfuncname : 12
neuralinsertvar      : 5 10
neuralread           : 48
neuraltablefunctions : 1
neuralwhile1         : 58
neuralwhile2         : 58
parameters           : 17 24
paramsexp            : 101
paramsexp2           : 102
popparenth           : 96
program              : 0
reading              : 27
returning            : 29
specialfunc          : 34
statutes             : 1 17 35 53 55 58 61
statutesaux          : 26 27 28 29 30 31 32 33 34
typing               : 5 16 22
vars                 : 3 5
varsarr              : 5 10
varsgl               : 1 17
varsmul              : 5 10
whiling              : 31
writetyping          : 42
writing              : 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
    (2) neuraltablefunctions -> . ID

    ID              shift and go to state 4

    neuraltablefunctions           shift and go to state 3

state 3

    (1) program -> PROGRAM neuraltablefunctions . SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    SEMICOLON       shift and go to state 5


state 4

    (2) neuraltablefunctions -> ID .

    SEMICOLON       reduce using rule 2 (neuraltablefunctions -> ID .)


state 5

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON . varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
    (3) varsgl -> . VARS vars
    (4) varsgl -> . empty
    (108) empty -> .

    VARS            shift and go to state 7
    FUNCTION        reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)

    varsgl                         shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl . modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
    (12) modules -> . FUNCTION functype neuralinsertfuncname funcparam
    (13) modules -> . empty
    (108) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 108 (empty -> .)

    modules                        shift and go to state 9
    empty                          shift and go to state 11

state 7

    (3) varsgl -> VARS . vars
    (5) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (6) vars -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (108) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    LEFTBR          reduce using rule 108 (empty -> .)

    vars                           shift and go to state 12
    typing                         shift and go to state 13
    empty                          shift and go to state 14

state 8

    (4) varsgl -> empty .

    FUNCTION        reduce using rule 4 (varsgl -> empty .)
    MAIN            reduce using rule 4 (varsgl -> empty .)
    LEFTBR          reduce using rule 4 (varsgl -> empty .)


state 9

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules . MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    MAIN            shift and go to state 18


state 10

    (12) modules -> FUNCTION . functype neuralinsertfuncname funcparam
    (15) functype -> . VOID
    (16) functype -> . typing
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR

    VOID            shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    functype                       shift and go to state 19
    typing                         shift and go to state 21

state 11

    (13) modules -> empty .

    MAIN            reduce using rule 13 (modules -> empty .)


state 12

    (3) varsgl -> VARS vars .

    FUNCTION        reduce using rule 3 (varsgl -> VARS vars .)
    MAIN            reduce using rule 3 (varsgl -> VARS vars .)
    LEFTBR          reduce using rule 3 (varsgl -> VARS vars .)


state 13

    (5) vars -> typing . COLON neuralinsertvar varsarr varsmul vars

    COLON           shift and go to state 22


state 14

    (6) vars -> empty .

    FUNCTION        reduce using rule 6 (vars -> empty .)
    MAIN            reduce using rule 6 (vars -> empty .)
    LEFTBR          reduce using rule 6 (vars -> empty .)


state 15

    (19) typing -> INT .

    COLON           reduce using rule 19 (typing -> INT .)
    ID              reduce using rule 19 (typing -> INT .)


state 16

    (20) typing -> FLOAT .

    COLON           reduce using rule 20 (typing -> FLOAT .)
    ID              reduce using rule 20 (typing -> FLOAT .)


state 17

    (21) typing -> CHAR .

    COLON           reduce using rule 21 (typing -> CHAR .)
    ID              reduce using rule 21 (typing -> CHAR .)


state 18

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN . LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 23


state 19

    (12) modules -> FUNCTION functype . neuralinsertfuncname funcparam
    (14) neuralinsertfuncname -> . ID

    ID              shift and go to state 25

    neuralinsertfuncname           shift and go to state 24

state 20

    (15) functype -> VOID .

    ID              reduce using rule 15 (functype -> VOID .)


state 21

    (16) functype -> typing .

    ID              reduce using rule 16 (functype -> typing .)


state 22

    (5) vars -> typing COLON . neuralinsertvar varsarr varsmul vars
    (7) neuralinsertvar -> . ID

    ID              shift and go to state 27

    neuralinsertvar                shift and go to state 26

state 23

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR . RIGHTPAR LEFTBR statutes RIGHTBR

    RIGHTPAR        shift and go to state 28


state 24

    (12) modules -> FUNCTION functype neuralinsertfuncname . funcparam
    (17) funcparam -> . LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules

    LEFTPAR         shift and go to state 30

    funcparam                      shift and go to state 29

state 25

    (14) neuralinsertfuncname -> ID .

    LEFTPAR         reduce using rule 14 (neuralinsertfuncname -> ID .)


state 26

    (5) vars -> typing COLON neuralinsertvar . varsarr varsmul vars
    (8) varsarr -> . LEFTSQR CTEINT RIGHTSQR
    (9) varsarr -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 32
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    varsarr                        shift and go to state 31
    empty                          shift and go to state 33

state 27

    (7) neuralinsertvar -> ID .

    LEFTSQR         reduce using rule 7 (neuralinsertvar -> ID .)
    COMMA           reduce using rule 7 (neuralinsertvar -> ID .)
    SEMICOLON       reduce using rule 7 (neuralinsertvar -> ID .)


state 28

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 34


state 29

    (12) modules -> FUNCTION functype neuralinsertfuncname funcparam .

    MAIN            reduce using rule 12 (modules -> FUNCTION functype neuralinsertfuncname funcparam .)


state 30

    (17) funcparam -> LEFTPAR . parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules
    (22) parameters -> . typing COLON ID idarray mulparams
    (23) parameters -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (108) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 108 (empty -> .)

    parameters                     shift and go to state 35
    typing                         shift and go to state 36
    empty                          shift and go to state 37

state 31

    (5) vars -> typing COLON neuralinsertvar varsarr . varsmul vars
    (10) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (11) varsmul -> . SEMICOLON

    COMMA           shift and go to state 39
    SEMICOLON       shift and go to state 40

    varsmul                        shift and go to state 38

state 32

    (8) varsarr -> LEFTSQR . CTEINT RIGHTSQR

    CTEINT          shift and go to state 41


state 33

    (9) varsarr -> empty .

    COMMA           reduce using rule 9 (varsarr -> empty .)
    SEMICOLON       reduce using rule 9 (varsarr -> empty .)


state 34

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR . statutes RIGHTBR
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (108) empty -> .
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    RIGHTBR         reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    statutes                       shift and go to state 43
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    empty                          shift and go to state 61
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 35

    (17) funcparam -> LEFTPAR parameters . RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules

    RIGHTPAR        shift and go to state 73


state 36

    (22) parameters -> typing . COLON ID idarray mulparams

    COLON           shift and go to state 74


state 37

    (23) parameters -> empty .

    RIGHTPAR        reduce using rule 23 (parameters -> empty .)


state 38

    (5) vars -> typing COLON neuralinsertvar varsarr varsmul . vars
    (5) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (6) vars -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (108) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    LEFTBR          reduce using rule 108 (empty -> .)

    typing                         shift and go to state 13
    vars                           shift and go to state 75
    empty                          shift and go to state 14

state 39

    (10) varsmul -> COMMA . neuralinsertvar varsarr varsmul
    (7) neuralinsertvar -> . ID

    ID              shift and go to state 27

    neuralinsertvar                shift and go to state 76

state 40

    (11) varsmul -> SEMICOLON .

    INT             reduce using rule 11 (varsmul -> SEMICOLON .)
    FLOAT           reduce using rule 11 (varsmul -> SEMICOLON .)
    CHAR            reduce using rule 11 (varsmul -> SEMICOLON .)
    FUNCTION        reduce using rule 11 (varsmul -> SEMICOLON .)
    MAIN            reduce using rule 11 (varsmul -> SEMICOLON .)
    LEFTBR          reduce using rule 11 (varsmul -> SEMICOLON .)


state 41

    (8) varsarr -> LEFTSQR CTEINT . RIGHTSQR

    RIGHTSQR        shift and go to state 77


state 42

    (94) addparenth -> LEFTPAR .

    LEFTPAR         reduce using rule 94 (addparenth -> LEFTPAR .)
    CTEINT          reduce using rule 94 (addparenth -> LEFTPAR .)
    CTEFLOAT        reduce using rule 94 (addparenth -> LEFTPAR .)
    CTECHAR         reduce using rule 94 (addparenth -> LEFTPAR .)
    ID              reduce using rule 94 (addparenth -> LEFTPAR .)


state 43

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 78


state 44

    (26) statutes -> assign . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    assign                         shift and go to state 44
    statutesaux                    shift and go to state 79
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 45

    (27) statutes -> reading . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    reading                        shift and go to state 45
    statutesaux                    shift and go to state 82
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 46

    (28) statutes -> writing . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    writing                        shift and go to state 46
    statutesaux                    shift and go to state 83
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 47

    (29) statutes -> returning . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    returning                      shift and go to state 47
    statutesaux                    shift and go to state 84
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 48

    (30) statutes -> ifing . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    ifing                          shift and go to state 48
    statutesaux                    shift and go to state 85
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 49

    (31) statutes -> whiling . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    whiling                        shift and go to state 49
    statutesaux                    shift and go to state 86
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 50

    (32) statutes -> foring . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    foring                         shift and go to state 50
    statutesaux                    shift and go to state 87
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 51

    (33) statutes -> exp . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    exp                            shift and go to state 51
    statutesaux                    shift and go to state 88
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 52

    (34) statutes -> specialfunc . statutesaux
    (35) statutesaux -> . statutes
    (36) statutesaux -> . empty
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (108) empty -> .
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 108 (empty -> .)
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    specialfunc                    shift and go to state 52
    statutesaux                    shift and go to state 89
    statutes                       shift and go to state 80
    empty                          shift and go to state 81
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 53

    (38) assign -> neuralassign1 . idarray neuralassign2 exp SEMICOLON
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 91
    EQUAL           reduce using rule 108 (empty -> .)

    idarray                        shift and go to state 90
    empty                          shift and go to state 92

state 54

    (48) reading -> READ . LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 93


state 55

    (41) writing -> WRITE . LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 94


state 56

    (52) returning -> RETURN . LEFTPAR exp RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 95


state 57

    (53) ifing -> IF . LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing

    LEFTPAR         shift and go to state 96


state 58

    (58) whiling -> neuralwhile1 . LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 97


state 59

    (61) foring -> FOR . neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (62) neuralfor1 -> . ID

    ID              shift and go to state 99

    neuralfor1                     shift and go to state 98

state 60

    (67) exp -> andexp . exp1
    (68) exp1 -> . OR exp
    (69) exp1 -> . empty
    (108) empty -> .

    OR              shift and go to state 101
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    LEFTPAR         reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)
    RIGHTSQR        reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    exp1                           shift and go to state 100
    empty                          shift and go to state 102

state 61

    (37) specialfunc -> empty .

    READ            reduce using rule 37 (specialfunc -> empty .)
    WRITE           reduce using rule 37 (specialfunc -> empty .)
    RETURN          reduce using rule 37 (specialfunc -> empty .)
    IF              reduce using rule 37 (specialfunc -> empty .)
    FOR             reduce using rule 37 (specialfunc -> empty .)
    ID              reduce using rule 37 (specialfunc -> empty .)
    WHILE           reduce using rule 37 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 37 (specialfunc -> empty .)
    CTEINT          reduce using rule 37 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 37 (specialfunc -> empty .)
    CTECHAR         reduce using rule 37 (specialfunc -> empty .)
    RIGHTBR         reduce using rule 37 (specialfunc -> empty .)


state 62

    (39) neuralassign1 -> ID .
    (101) cteexp -> ID . paramsexp
    (102) paramsexp -> . LEFTPAR paramsexp2 RIGHTPAR
    (103) paramsexp -> . idarray
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

  ! shift/reduce conflict for LEFTSQR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    EQUAL           reduce using rule 39 (neuralassign1 -> ID .)
    LEFTPAR         shift and go to state 104
    LEFTSQR         shift and go to state 91
    TIMES           reduce using rule 108 (empty -> .)
    DIVIDE          reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    REST            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    GREATERAND      reduce using rule 108 (empty -> .)
    LESSER          reduce using rule 108 (empty -> .)
    LESSERAND       reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    NOTSAME         reduce using rule 108 (empty -> .)
    NOT             reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)

  ! LEFTSQR         [ reduce using rule 39 (neuralassign1 -> ID .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]

    paramsexp                      shift and go to state 103
    idarray                        shift and go to state 105
    empty                          shift and go to state 92

state 63

    (59) neuralwhile1 -> WHILE .

    LEFTPAR         reduce using rule 59 (neuralwhile1 -> WHILE .)


state 64

    (70) andexp -> boolexp . andexp1
    (71) andexp1 -> . neuraland andexp
    (72) andexp1 -> . empty
    (73) neuraland -> . AND
    (108) empty -> .

    AND             shift and go to state 109
    OR              reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    LEFTPAR         reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)
    RIGHTSQR        reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    andexp1                        shift and go to state 106
    neuraland                      shift and go to state 107
    empty                          shift and go to state 108

state 65

    (74) boolexp -> arithexp . boolexp1
    (75) boolexp1 -> . neuralbool arithexp
    (76) boolexp1 -> . empty
    (77) neuralbool -> . GREATER
    (78) neuralbool -> . GREATERAND
    (79) neuralbool -> . LESSER
    (80) neuralbool -> . LESSERAND
    (81) neuralbool -> . SAME
    (82) neuralbool -> . NOTSAME
    (83) neuralbool -> . NOT
    (108) empty -> .

    GREATER         shift and go to state 113
    GREATERAND      shift and go to state 114
    LESSER          shift and go to state 115
    LESSERAND       shift and go to state 116
    SAME            shift and go to state 117
    NOTSAME         shift and go to state 118
    NOT             shift and go to state 119
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    LEFTPAR         reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)
    RIGHTSQR        reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    boolexp1                       shift and go to state 110
    neuralbool                     shift and go to state 111
    empty                          shift and go to state 112

state 66

    (84) arithexp -> geoexp . arithexp1
    (85) arithexp1 -> . neuralarith arithexp
    (86) arithexp1 -> . empty
    (87) neuralarith -> . PLUS
    (88) neuralarith -> . REST
    (108) empty -> .

    PLUS            shift and go to state 123
    REST            shift and go to state 124
    GREATER         reduce using rule 108 (empty -> .)
    GREATERAND      reduce using rule 108 (empty -> .)
    LESSER          reduce using rule 108 (empty -> .)
    LESSERAND       reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    NOTSAME         reduce using rule 108 (empty -> .)
    NOT             reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    LEFTPAR         reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)
    RIGHTSQR        reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    arithexp1                      shift and go to state 120
    neuralarith                    shift and go to state 121
    empty                          shift and go to state 122

state 67

    (89) geoexp -> finexp . geoexp1
    (90) geoexp1 -> . neuralgeo geoexp
    (91) geoexp1 -> . empty
    (92) neuralgeo -> . TIMES
    (93) neuralgeo -> . DIVIDE
    (108) empty -> .

    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    PLUS            reduce using rule 108 (empty -> .)
    REST            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    GREATERAND      reduce using rule 108 (empty -> .)
    LESSER          reduce using rule 108 (empty -> .)
    LESSERAND       reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    NOTSAME         reduce using rule 108 (empty -> .)
    NOT             reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    LEFTPAR         reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)
    RIGHTSQR        reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    geoexp1                        shift and go to state 125
    neuralgeo                      shift and go to state 126
    empty                          shift and go to state 127

state 68

    (96) finexp -> addparenth . exp popparenth
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    addparenth                     shift and go to state 68
    exp                            shift and go to state 130
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    cteexp                         shift and go to state 69

state 69

    (97) finexp -> cteexp .

    TIMES           reduce using rule 97 (finexp -> cteexp .)
    DIVIDE          reduce using rule 97 (finexp -> cteexp .)
    PLUS            reduce using rule 97 (finexp -> cteexp .)
    REST            reduce using rule 97 (finexp -> cteexp .)
    GREATER         reduce using rule 97 (finexp -> cteexp .)
    GREATERAND      reduce using rule 97 (finexp -> cteexp .)
    LESSER          reduce using rule 97 (finexp -> cteexp .)
    LESSERAND       reduce using rule 97 (finexp -> cteexp .)
    SAME            reduce using rule 97 (finexp -> cteexp .)
    NOTSAME         reduce using rule 97 (finexp -> cteexp .)
    NOT             reduce using rule 97 (finexp -> cteexp .)
    AND             reduce using rule 97 (finexp -> cteexp .)
    OR              reduce using rule 97 (finexp -> cteexp .)
    READ            reduce using rule 97 (finexp -> cteexp .)
    WRITE           reduce using rule 97 (finexp -> cteexp .)
    RETURN          reduce using rule 97 (finexp -> cteexp .)
    IF              reduce using rule 97 (finexp -> cteexp .)
    FOR             reduce using rule 97 (finexp -> cteexp .)
    ID              reduce using rule 97 (finexp -> cteexp .)
    WHILE           reduce using rule 97 (finexp -> cteexp .)
    LEFTPAR         reduce using rule 97 (finexp -> cteexp .)
    CTEINT          reduce using rule 97 (finexp -> cteexp .)
    CTEFLOAT        reduce using rule 97 (finexp -> cteexp .)
    CTECHAR         reduce using rule 97 (finexp -> cteexp .)
    RIGHTBR         reduce using rule 97 (finexp -> cteexp .)
    RIGHTPAR        reduce using rule 97 (finexp -> cteexp .)
    RIGHTSQR        reduce using rule 97 (finexp -> cteexp .)
    COMMA           reduce using rule 97 (finexp -> cteexp .)
    SEMICOLON       reduce using rule 97 (finexp -> cteexp .)
    TO              reduce using rule 97 (finexp -> cteexp .)
    DO              reduce using rule 97 (finexp -> cteexp .)


state 70

    (98) cteexp -> CTEINT .

    TIMES           reduce using rule 98 (cteexp -> CTEINT .)
    DIVIDE          reduce using rule 98 (cteexp -> CTEINT .)
    PLUS            reduce using rule 98 (cteexp -> CTEINT .)
    REST            reduce using rule 98 (cteexp -> CTEINT .)
    GREATER         reduce using rule 98 (cteexp -> CTEINT .)
    GREATERAND      reduce using rule 98 (cteexp -> CTEINT .)
    LESSER          reduce using rule 98 (cteexp -> CTEINT .)
    LESSERAND       reduce using rule 98 (cteexp -> CTEINT .)
    SAME            reduce using rule 98 (cteexp -> CTEINT .)
    NOTSAME         reduce using rule 98 (cteexp -> CTEINT .)
    NOT             reduce using rule 98 (cteexp -> CTEINT .)
    AND             reduce using rule 98 (cteexp -> CTEINT .)
    OR              reduce using rule 98 (cteexp -> CTEINT .)
    READ            reduce using rule 98 (cteexp -> CTEINT .)
    WRITE           reduce using rule 98 (cteexp -> CTEINT .)
    RETURN          reduce using rule 98 (cteexp -> CTEINT .)
    IF              reduce using rule 98 (cteexp -> CTEINT .)
    FOR             reduce using rule 98 (cteexp -> CTEINT .)
    ID              reduce using rule 98 (cteexp -> CTEINT .)
    WHILE           reduce using rule 98 (cteexp -> CTEINT .)
    LEFTPAR         reduce using rule 98 (cteexp -> CTEINT .)
    CTEINT          reduce using rule 98 (cteexp -> CTEINT .)
    CTEFLOAT        reduce using rule 98 (cteexp -> CTEINT .)
    CTECHAR         reduce using rule 98 (cteexp -> CTEINT .)
    RIGHTBR         reduce using rule 98 (cteexp -> CTEINT .)
    RIGHTPAR        reduce using rule 98 (cteexp -> CTEINT .)
    RIGHTSQR        reduce using rule 98 (cteexp -> CTEINT .)
    COMMA           reduce using rule 98 (cteexp -> CTEINT .)
    SEMICOLON       reduce using rule 98 (cteexp -> CTEINT .)
    TO              reduce using rule 98 (cteexp -> CTEINT .)
    DO              reduce using rule 98 (cteexp -> CTEINT .)


state 71

    (99) cteexp -> CTEFLOAT .

    TIMES           reduce using rule 99 (cteexp -> CTEFLOAT .)
    DIVIDE          reduce using rule 99 (cteexp -> CTEFLOAT .)
    PLUS            reduce using rule 99 (cteexp -> CTEFLOAT .)
    REST            reduce using rule 99 (cteexp -> CTEFLOAT .)
    GREATER         reduce using rule 99 (cteexp -> CTEFLOAT .)
    GREATERAND      reduce using rule 99 (cteexp -> CTEFLOAT .)
    LESSER          reduce using rule 99 (cteexp -> CTEFLOAT .)
    LESSERAND       reduce using rule 99 (cteexp -> CTEFLOAT .)
    SAME            reduce using rule 99 (cteexp -> CTEFLOAT .)
    NOTSAME         reduce using rule 99 (cteexp -> CTEFLOAT .)
    NOT             reduce using rule 99 (cteexp -> CTEFLOAT .)
    AND             reduce using rule 99 (cteexp -> CTEFLOAT .)
    OR              reduce using rule 99 (cteexp -> CTEFLOAT .)
    READ            reduce using rule 99 (cteexp -> CTEFLOAT .)
    WRITE           reduce using rule 99 (cteexp -> CTEFLOAT .)
    RETURN          reduce using rule 99 (cteexp -> CTEFLOAT .)
    IF              reduce using rule 99 (cteexp -> CTEFLOAT .)
    FOR             reduce using rule 99 (cteexp -> CTEFLOAT .)
    ID              reduce using rule 99 (cteexp -> CTEFLOAT .)
    WHILE           reduce using rule 99 (cteexp -> CTEFLOAT .)
    LEFTPAR         reduce using rule 99 (cteexp -> CTEFLOAT .)
    CTEINT          reduce using rule 99 (cteexp -> CTEFLOAT .)
    CTEFLOAT        reduce using rule 99 (cteexp -> CTEFLOAT .)
    CTECHAR         reduce using rule 99 (cteexp -> CTEFLOAT .)
    RIGHTBR         reduce using rule 99 (cteexp -> CTEFLOAT .)
    RIGHTPAR        reduce using rule 99 (cteexp -> CTEFLOAT .)
    RIGHTSQR        reduce using rule 99 (cteexp -> CTEFLOAT .)
    COMMA           reduce using rule 99 (cteexp -> CTEFLOAT .)
    SEMICOLON       reduce using rule 99 (cteexp -> CTEFLOAT .)
    TO              reduce using rule 99 (cteexp -> CTEFLOAT .)
    DO              reduce using rule 99 (cteexp -> CTEFLOAT .)


state 72

    (100) cteexp -> CTECHAR .

    TIMES           reduce using rule 100 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 100 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 100 (cteexp -> CTECHAR .)
    REST            reduce using rule 100 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 100 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 100 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 100 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 100 (cteexp -> CTECHAR .)
    SAME            reduce using rule 100 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 100 (cteexp -> CTECHAR .)
    NOT             reduce using rule 100 (cteexp -> CTECHAR .)
    AND             reduce using rule 100 (cteexp -> CTECHAR .)
    OR              reduce using rule 100 (cteexp -> CTECHAR .)
    READ            reduce using rule 100 (cteexp -> CTECHAR .)
    WRITE           reduce using rule 100 (cteexp -> CTECHAR .)
    RETURN          reduce using rule 100 (cteexp -> CTECHAR .)
    IF              reduce using rule 100 (cteexp -> CTECHAR .)
    FOR             reduce using rule 100 (cteexp -> CTECHAR .)
    ID              reduce using rule 100 (cteexp -> CTECHAR .)
    WHILE           reduce using rule 100 (cteexp -> CTECHAR .)
    LEFTPAR         reduce using rule 100 (cteexp -> CTECHAR .)
    CTEINT          reduce using rule 100 (cteexp -> CTECHAR .)
    CTEFLOAT        reduce using rule 100 (cteexp -> CTECHAR .)
    CTECHAR         reduce using rule 100 (cteexp -> CTECHAR .)
    RIGHTBR         reduce using rule 100 (cteexp -> CTECHAR .)
    RIGHTPAR        reduce using rule 100 (cteexp -> CTECHAR .)
    RIGHTSQR        reduce using rule 100 (cteexp -> CTECHAR .)
    COMMA           reduce using rule 100 (cteexp -> CTECHAR .)
    SEMICOLON       reduce using rule 100 (cteexp -> CTECHAR .)
    TO              reduce using rule 100 (cteexp -> CTECHAR .)
    DO              reduce using rule 100 (cteexp -> CTECHAR .)


state 73

    (17) funcparam -> LEFTPAR parameters RIGHTPAR . SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules

    SEMICOLON       shift and go to state 132


state 74

    (22) parameters -> typing COLON . ID idarray mulparams

    ID              shift and go to state 133


state 75

    (5) vars -> typing COLON neuralinsertvar varsarr varsmul vars .

    FUNCTION        reduce using rule 5 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    MAIN            reduce using rule 5 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    LEFTBR          reduce using rule 5 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)


state 76

    (10) varsmul -> COMMA neuralinsertvar . varsarr varsmul
    (8) varsarr -> . LEFTSQR CTEINT RIGHTSQR
    (9) varsarr -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 32
    COMMA           reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    varsarr                        shift and go to state 134
    empty                          shift and go to state 33

state 77

    (8) varsarr -> LEFTSQR CTEINT RIGHTSQR .

    COMMA           reduce using rule 8 (varsarr -> LEFTSQR CTEINT RIGHTSQR .)
    SEMICOLON       reduce using rule 8 (varsarr -> LEFTSQR CTEINT RIGHTSQR .)


state 78

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR .

    $end            reduce using rule 1 (program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR .)


state 79

    (26) statutes -> assign statutesaux .

    RIGHTBR         reduce using rule 26 (statutes -> assign statutesaux .)


state 80

    (35) statutesaux -> statutes .

    RIGHTBR         reduce using rule 35 (statutesaux -> statutes .)


state 81

    (36) statutesaux -> empty .
    (37) specialfunc -> empty .

  ! reduce/reduce conflict for RIGHTBR resolved using rule 36 (statutesaux -> empty .)
    RIGHTBR         reduce using rule 36 (statutesaux -> empty .)
    READ            reduce using rule 37 (specialfunc -> empty .)
    WRITE           reduce using rule 37 (specialfunc -> empty .)
    RETURN          reduce using rule 37 (specialfunc -> empty .)
    IF              reduce using rule 37 (specialfunc -> empty .)
    FOR             reduce using rule 37 (specialfunc -> empty .)
    ID              reduce using rule 37 (specialfunc -> empty .)
    WHILE           reduce using rule 37 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 37 (specialfunc -> empty .)
    CTEINT          reduce using rule 37 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 37 (specialfunc -> empty .)
    CTECHAR         reduce using rule 37 (specialfunc -> empty .)

  ! RIGHTBR         [ reduce using rule 37 (specialfunc -> empty .) ]


state 82

    (27) statutes -> reading statutesaux .

    RIGHTBR         reduce using rule 27 (statutes -> reading statutesaux .)


state 83

    (28) statutes -> writing statutesaux .

    RIGHTBR         reduce using rule 28 (statutes -> writing statutesaux .)


state 84

    (29) statutes -> returning statutesaux .

    RIGHTBR         reduce using rule 29 (statutes -> returning statutesaux .)


state 85

    (30) statutes -> ifing statutesaux .

    RIGHTBR         reduce using rule 30 (statutes -> ifing statutesaux .)


state 86

    (31) statutes -> whiling statutesaux .

    RIGHTBR         reduce using rule 31 (statutes -> whiling statutesaux .)


state 87

    (32) statutes -> foring statutesaux .

    RIGHTBR         reduce using rule 32 (statutes -> foring statutesaux .)


state 88

    (33) statutes -> exp statutesaux .

    RIGHTBR         reduce using rule 33 (statutes -> exp statutesaux .)


state 89

    (34) statutes -> specialfunc statutesaux .

    RIGHTBR         reduce using rule 34 (statutes -> specialfunc statutesaux .)


state 90

    (38) assign -> neuralassign1 idarray . neuralassign2 exp SEMICOLON
    (40) neuralassign2 -> . EQUAL

    EQUAL           shift and go to state 136

    neuralassign2                  shift and go to state 135

state 91

    (65) idarray -> LEFTSQR . exp RIGHTSQR
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 137
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 92

    (66) idarray -> empty .

    EQUAL           reduce using rule 66 (idarray -> empty .)
    TIMES           reduce using rule 66 (idarray -> empty .)
    DIVIDE          reduce using rule 66 (idarray -> empty .)
    PLUS            reduce using rule 66 (idarray -> empty .)
    REST            reduce using rule 66 (idarray -> empty .)
    GREATER         reduce using rule 66 (idarray -> empty .)
    GREATERAND      reduce using rule 66 (idarray -> empty .)
    LESSER          reduce using rule 66 (idarray -> empty .)
    LESSERAND       reduce using rule 66 (idarray -> empty .)
    SAME            reduce using rule 66 (idarray -> empty .)
    NOTSAME         reduce using rule 66 (idarray -> empty .)
    NOT             reduce using rule 66 (idarray -> empty .)
    AND             reduce using rule 66 (idarray -> empty .)
    OR              reduce using rule 66 (idarray -> empty .)
    READ            reduce using rule 66 (idarray -> empty .)
    WRITE           reduce using rule 66 (idarray -> empty .)
    RETURN          reduce using rule 66 (idarray -> empty .)
    IF              reduce using rule 66 (idarray -> empty .)
    FOR             reduce using rule 66 (idarray -> empty .)
    ID              reduce using rule 66 (idarray -> empty .)
    WHILE           reduce using rule 66 (idarray -> empty .)
    LEFTPAR         reduce using rule 66 (idarray -> empty .)
    CTEINT          reduce using rule 66 (idarray -> empty .)
    CTEFLOAT        reduce using rule 66 (idarray -> empty .)
    CTECHAR         reduce using rule 66 (idarray -> empty .)
    RIGHTBR         reduce using rule 66 (idarray -> empty .)
    RIGHTPAR        reduce using rule 66 (idarray -> empty .)
    RIGHTSQR        reduce using rule 66 (idarray -> empty .)
    COMMA           reduce using rule 66 (idarray -> empty .)
    SEMICOLON       reduce using rule 66 (idarray -> empty .)
    TO              reduce using rule 66 (idarray -> empty .)
    DO              reduce using rule 66 (idarray -> empty .)


state 93

    (48) reading -> READ LEFTPAR . neuralread idarray mulread RIGHTPAR SEMICOLON
    (49) neuralread -> . ID

    ID              shift and go to state 139

    neuralread                     shift and go to state 138

state 94

    (41) writing -> WRITE LEFTPAR . auxwrite mulwrite RIGHTPAR SEMICOLON
    (42) auxwrite -> . writetyping
    (43) auxwrite -> . exp
    (44) writetyping -> . STRING
    (45) writetyping -> . CTECHAR
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    STRING          shift and go to state 143
    CTECHAR         shift and go to state 144
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    ID              shift and go to state 131

    auxwrite                       shift and go to state 140
    writetyping                    shift and go to state 141
    exp                            shift and go to state 142
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 95

    (52) returning -> RETURN LEFTPAR . exp RIGHTPAR SEMICOLON
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 145
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 96

    (53) ifing -> IF LEFTPAR . exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 146
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 97

    (58) whiling -> neuralwhile1 LEFTPAR . exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 147
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 98

    (61) foring -> FOR neuralfor1 . idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 91
    EQUAL           reduce using rule 108 (empty -> .)

    idarray                        shift and go to state 148
    empty                          shift and go to state 92

state 99

    (62) neuralfor1 -> ID .

    LEFTSQR         reduce using rule 62 (neuralfor1 -> ID .)
    EQUAL           reduce using rule 62 (neuralfor1 -> ID .)


state 100

    (67) exp -> andexp exp1 .

    READ            reduce using rule 67 (exp -> andexp exp1 .)
    WRITE           reduce using rule 67 (exp -> andexp exp1 .)
    RETURN          reduce using rule 67 (exp -> andexp exp1 .)
    IF              reduce using rule 67 (exp -> andexp exp1 .)
    FOR             reduce using rule 67 (exp -> andexp exp1 .)
    ID              reduce using rule 67 (exp -> andexp exp1 .)
    WHILE           reduce using rule 67 (exp -> andexp exp1 .)
    LEFTPAR         reduce using rule 67 (exp -> andexp exp1 .)
    CTEINT          reduce using rule 67 (exp -> andexp exp1 .)
    CTEFLOAT        reduce using rule 67 (exp -> andexp exp1 .)
    CTECHAR         reduce using rule 67 (exp -> andexp exp1 .)
    RIGHTBR         reduce using rule 67 (exp -> andexp exp1 .)
    RIGHTPAR        reduce using rule 67 (exp -> andexp exp1 .)
    RIGHTSQR        reduce using rule 67 (exp -> andexp exp1 .)
    COMMA           reduce using rule 67 (exp -> andexp exp1 .)
    SEMICOLON       reduce using rule 67 (exp -> andexp exp1 .)
    TO              reduce using rule 67 (exp -> andexp exp1 .)
    DO              reduce using rule 67 (exp -> andexp exp1 .)


state 101

    (68) exp1 -> OR . exp
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 149
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 102

    (69) exp1 -> empty .

    READ            reduce using rule 69 (exp1 -> empty .)
    WRITE           reduce using rule 69 (exp1 -> empty .)
    RETURN          reduce using rule 69 (exp1 -> empty .)
    IF              reduce using rule 69 (exp1 -> empty .)
    FOR             reduce using rule 69 (exp1 -> empty .)
    ID              reduce using rule 69 (exp1 -> empty .)
    WHILE           reduce using rule 69 (exp1 -> empty .)
    LEFTPAR         reduce using rule 69 (exp1 -> empty .)
    CTEINT          reduce using rule 69 (exp1 -> empty .)
    CTEFLOAT        reduce using rule 69 (exp1 -> empty .)
    CTECHAR         reduce using rule 69 (exp1 -> empty .)
    RIGHTBR         reduce using rule 69 (exp1 -> empty .)
    RIGHTPAR        reduce using rule 69 (exp1 -> empty .)
    RIGHTSQR        reduce using rule 69 (exp1 -> empty .)
    COMMA           reduce using rule 69 (exp1 -> empty .)
    SEMICOLON       reduce using rule 69 (exp1 -> empty .)
    TO              reduce using rule 69 (exp1 -> empty .)
    DO              reduce using rule 69 (exp1 -> empty .)


state 103

    (101) cteexp -> ID paramsexp .

    TIMES           reduce using rule 101 (cteexp -> ID paramsexp .)
    DIVIDE          reduce using rule 101 (cteexp -> ID paramsexp .)
    PLUS            reduce using rule 101 (cteexp -> ID paramsexp .)
    REST            reduce using rule 101 (cteexp -> ID paramsexp .)
    GREATER         reduce using rule 101 (cteexp -> ID paramsexp .)
    GREATERAND      reduce using rule 101 (cteexp -> ID paramsexp .)
    LESSER          reduce using rule 101 (cteexp -> ID paramsexp .)
    LESSERAND       reduce using rule 101 (cteexp -> ID paramsexp .)
    SAME            reduce using rule 101 (cteexp -> ID paramsexp .)
    NOTSAME         reduce using rule 101 (cteexp -> ID paramsexp .)
    NOT             reduce using rule 101 (cteexp -> ID paramsexp .)
    AND             reduce using rule 101 (cteexp -> ID paramsexp .)
    OR              reduce using rule 101 (cteexp -> ID paramsexp .)
    READ            reduce using rule 101 (cteexp -> ID paramsexp .)
    WRITE           reduce using rule 101 (cteexp -> ID paramsexp .)
    RETURN          reduce using rule 101 (cteexp -> ID paramsexp .)
    IF              reduce using rule 101 (cteexp -> ID paramsexp .)
    FOR             reduce using rule 101 (cteexp -> ID paramsexp .)
    ID              reduce using rule 101 (cteexp -> ID paramsexp .)
    WHILE           reduce using rule 101 (cteexp -> ID paramsexp .)
    LEFTPAR         reduce using rule 101 (cteexp -> ID paramsexp .)
    CTEINT          reduce using rule 101 (cteexp -> ID paramsexp .)
    CTEFLOAT        reduce using rule 101 (cteexp -> ID paramsexp .)
    CTECHAR         reduce using rule 101 (cteexp -> ID paramsexp .)
    RIGHTBR         reduce using rule 101 (cteexp -> ID paramsexp .)
    RIGHTPAR        reduce using rule 101 (cteexp -> ID paramsexp .)
    RIGHTSQR        reduce using rule 101 (cteexp -> ID paramsexp .)
    COMMA           reduce using rule 101 (cteexp -> ID paramsexp .)
    SEMICOLON       reduce using rule 101 (cteexp -> ID paramsexp .)
    TO              reduce using rule 101 (cteexp -> ID paramsexp .)
    DO              reduce using rule 101 (cteexp -> ID paramsexp .)


state 104

    (102) paramsexp -> LEFTPAR . paramsexp2 RIGHTPAR
    (104) paramsexp2 -> . exp auxparamsexp2
    (105) paramsexp2 -> . empty
    (67) exp -> . andexp exp1
    (108) empty -> .
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    RIGHTPAR        reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    paramsexp2                     shift and go to state 150
    exp                            shift and go to state 151
    empty                          shift and go to state 152
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 105

    (103) paramsexp -> idarray .

    TIMES           reduce using rule 103 (paramsexp -> idarray .)
    DIVIDE          reduce using rule 103 (paramsexp -> idarray .)
    PLUS            reduce using rule 103 (paramsexp -> idarray .)
    REST            reduce using rule 103 (paramsexp -> idarray .)
    GREATER         reduce using rule 103 (paramsexp -> idarray .)
    GREATERAND      reduce using rule 103 (paramsexp -> idarray .)
    LESSER          reduce using rule 103 (paramsexp -> idarray .)
    LESSERAND       reduce using rule 103 (paramsexp -> idarray .)
    SAME            reduce using rule 103 (paramsexp -> idarray .)
    NOTSAME         reduce using rule 103 (paramsexp -> idarray .)
    NOT             reduce using rule 103 (paramsexp -> idarray .)
    AND             reduce using rule 103 (paramsexp -> idarray .)
    OR              reduce using rule 103 (paramsexp -> idarray .)
    READ            reduce using rule 103 (paramsexp -> idarray .)
    WRITE           reduce using rule 103 (paramsexp -> idarray .)
    RETURN          reduce using rule 103 (paramsexp -> idarray .)
    IF              reduce using rule 103 (paramsexp -> idarray .)
    FOR             reduce using rule 103 (paramsexp -> idarray .)
    ID              reduce using rule 103 (paramsexp -> idarray .)
    WHILE           reduce using rule 103 (paramsexp -> idarray .)
    LEFTPAR         reduce using rule 103 (paramsexp -> idarray .)
    CTEINT          reduce using rule 103 (paramsexp -> idarray .)
    CTEFLOAT        reduce using rule 103 (paramsexp -> idarray .)
    CTECHAR         reduce using rule 103 (paramsexp -> idarray .)
    RIGHTBR         reduce using rule 103 (paramsexp -> idarray .)
    RIGHTPAR        reduce using rule 103 (paramsexp -> idarray .)
    RIGHTSQR        reduce using rule 103 (paramsexp -> idarray .)
    COMMA           reduce using rule 103 (paramsexp -> idarray .)
    SEMICOLON       reduce using rule 103 (paramsexp -> idarray .)
    TO              reduce using rule 103 (paramsexp -> idarray .)
    DO              reduce using rule 103 (paramsexp -> idarray .)


state 106

    (70) andexp -> boolexp andexp1 .

    OR              reduce using rule 70 (andexp -> boolexp andexp1 .)
    READ            reduce using rule 70 (andexp -> boolexp andexp1 .)
    WRITE           reduce using rule 70 (andexp -> boolexp andexp1 .)
    RETURN          reduce using rule 70 (andexp -> boolexp andexp1 .)
    IF              reduce using rule 70 (andexp -> boolexp andexp1 .)
    FOR             reduce using rule 70 (andexp -> boolexp andexp1 .)
    ID              reduce using rule 70 (andexp -> boolexp andexp1 .)
    WHILE           reduce using rule 70 (andexp -> boolexp andexp1 .)
    LEFTPAR         reduce using rule 70 (andexp -> boolexp andexp1 .)
    CTEINT          reduce using rule 70 (andexp -> boolexp andexp1 .)
    CTEFLOAT        reduce using rule 70 (andexp -> boolexp andexp1 .)
    CTECHAR         reduce using rule 70 (andexp -> boolexp andexp1 .)
    RIGHTBR         reduce using rule 70 (andexp -> boolexp andexp1 .)
    RIGHTPAR        reduce using rule 70 (andexp -> boolexp andexp1 .)
    RIGHTSQR        reduce using rule 70 (andexp -> boolexp andexp1 .)
    COMMA           reduce using rule 70 (andexp -> boolexp andexp1 .)
    SEMICOLON       reduce using rule 70 (andexp -> boolexp andexp1 .)
    TO              reduce using rule 70 (andexp -> boolexp andexp1 .)
    DO              reduce using rule 70 (andexp -> boolexp andexp1 .)


state 107

    (71) andexp1 -> neuraland . andexp
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    andexp                         shift and go to state 153
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 108

    (72) andexp1 -> empty .

    OR              reduce using rule 72 (andexp1 -> empty .)
    READ            reduce using rule 72 (andexp1 -> empty .)
    WRITE           reduce using rule 72 (andexp1 -> empty .)
    RETURN          reduce using rule 72 (andexp1 -> empty .)
    IF              reduce using rule 72 (andexp1 -> empty .)
    FOR             reduce using rule 72 (andexp1 -> empty .)
    ID              reduce using rule 72 (andexp1 -> empty .)
    WHILE           reduce using rule 72 (andexp1 -> empty .)
    LEFTPAR         reduce using rule 72 (andexp1 -> empty .)
    CTEINT          reduce using rule 72 (andexp1 -> empty .)
    CTEFLOAT        reduce using rule 72 (andexp1 -> empty .)
    CTECHAR         reduce using rule 72 (andexp1 -> empty .)
    RIGHTBR         reduce using rule 72 (andexp1 -> empty .)
    RIGHTPAR        reduce using rule 72 (andexp1 -> empty .)
    RIGHTSQR        reduce using rule 72 (andexp1 -> empty .)
    COMMA           reduce using rule 72 (andexp1 -> empty .)
    SEMICOLON       reduce using rule 72 (andexp1 -> empty .)
    TO              reduce using rule 72 (andexp1 -> empty .)
    DO              reduce using rule 72 (andexp1 -> empty .)


state 109

    (73) neuraland -> AND .

    LEFTPAR         reduce using rule 73 (neuraland -> AND .)
    CTEINT          reduce using rule 73 (neuraland -> AND .)
    CTEFLOAT        reduce using rule 73 (neuraland -> AND .)
    CTECHAR         reduce using rule 73 (neuraland -> AND .)
    ID              reduce using rule 73 (neuraland -> AND .)


state 110

    (74) boolexp -> arithexp boolexp1 .

    AND             reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    OR              reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    READ            reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    WRITE           reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    RETURN          reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    IF              reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    FOR             reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    ID              reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    WHILE           reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    LEFTPAR         reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    CTEINT          reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    CTEFLOAT        reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    CTECHAR         reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    RIGHTBR         reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    RIGHTPAR        reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    RIGHTSQR        reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    COMMA           reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    SEMICOLON       reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    TO              reduce using rule 74 (boolexp -> arithexp boolexp1 .)
    DO              reduce using rule 74 (boolexp -> arithexp boolexp1 .)


state 111

    (75) boolexp1 -> neuralbool . arithexp
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    arithexp                       shift and go to state 154
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 112

    (76) boolexp1 -> empty .

    AND             reduce using rule 76 (boolexp1 -> empty .)
    OR              reduce using rule 76 (boolexp1 -> empty .)
    READ            reduce using rule 76 (boolexp1 -> empty .)
    WRITE           reduce using rule 76 (boolexp1 -> empty .)
    RETURN          reduce using rule 76 (boolexp1 -> empty .)
    IF              reduce using rule 76 (boolexp1 -> empty .)
    FOR             reduce using rule 76 (boolexp1 -> empty .)
    ID              reduce using rule 76 (boolexp1 -> empty .)
    WHILE           reduce using rule 76 (boolexp1 -> empty .)
    LEFTPAR         reduce using rule 76 (boolexp1 -> empty .)
    CTEINT          reduce using rule 76 (boolexp1 -> empty .)
    CTEFLOAT        reduce using rule 76 (boolexp1 -> empty .)
    CTECHAR         reduce using rule 76 (boolexp1 -> empty .)
    RIGHTBR         reduce using rule 76 (boolexp1 -> empty .)
    RIGHTPAR        reduce using rule 76 (boolexp1 -> empty .)
    RIGHTSQR        reduce using rule 76 (boolexp1 -> empty .)
    COMMA           reduce using rule 76 (boolexp1 -> empty .)
    SEMICOLON       reduce using rule 76 (boolexp1 -> empty .)
    TO              reduce using rule 76 (boolexp1 -> empty .)
    DO              reduce using rule 76 (boolexp1 -> empty .)


state 113

    (77) neuralbool -> GREATER .

    LEFTPAR         reduce using rule 77 (neuralbool -> GREATER .)
    CTEINT          reduce using rule 77 (neuralbool -> GREATER .)
    CTEFLOAT        reduce using rule 77 (neuralbool -> GREATER .)
    CTECHAR         reduce using rule 77 (neuralbool -> GREATER .)
    ID              reduce using rule 77 (neuralbool -> GREATER .)


state 114

    (78) neuralbool -> GREATERAND .

    LEFTPAR         reduce using rule 78 (neuralbool -> GREATERAND .)
    CTEINT          reduce using rule 78 (neuralbool -> GREATERAND .)
    CTEFLOAT        reduce using rule 78 (neuralbool -> GREATERAND .)
    CTECHAR         reduce using rule 78 (neuralbool -> GREATERAND .)
    ID              reduce using rule 78 (neuralbool -> GREATERAND .)


state 115

    (79) neuralbool -> LESSER .

    LEFTPAR         reduce using rule 79 (neuralbool -> LESSER .)
    CTEINT          reduce using rule 79 (neuralbool -> LESSER .)
    CTEFLOAT        reduce using rule 79 (neuralbool -> LESSER .)
    CTECHAR         reduce using rule 79 (neuralbool -> LESSER .)
    ID              reduce using rule 79 (neuralbool -> LESSER .)


state 116

    (80) neuralbool -> LESSERAND .

    LEFTPAR         reduce using rule 80 (neuralbool -> LESSERAND .)
    CTEINT          reduce using rule 80 (neuralbool -> LESSERAND .)
    CTEFLOAT        reduce using rule 80 (neuralbool -> LESSERAND .)
    CTECHAR         reduce using rule 80 (neuralbool -> LESSERAND .)
    ID              reduce using rule 80 (neuralbool -> LESSERAND .)


state 117

    (81) neuralbool -> SAME .

    LEFTPAR         reduce using rule 81 (neuralbool -> SAME .)
    CTEINT          reduce using rule 81 (neuralbool -> SAME .)
    CTEFLOAT        reduce using rule 81 (neuralbool -> SAME .)
    CTECHAR         reduce using rule 81 (neuralbool -> SAME .)
    ID              reduce using rule 81 (neuralbool -> SAME .)


state 118

    (82) neuralbool -> NOTSAME .

    LEFTPAR         reduce using rule 82 (neuralbool -> NOTSAME .)
    CTEINT          reduce using rule 82 (neuralbool -> NOTSAME .)
    CTEFLOAT        reduce using rule 82 (neuralbool -> NOTSAME .)
    CTECHAR         reduce using rule 82 (neuralbool -> NOTSAME .)
    ID              reduce using rule 82 (neuralbool -> NOTSAME .)


state 119

    (83) neuralbool -> NOT .

    LEFTPAR         reduce using rule 83 (neuralbool -> NOT .)
    CTEINT          reduce using rule 83 (neuralbool -> NOT .)
    CTEFLOAT        reduce using rule 83 (neuralbool -> NOT .)
    CTECHAR         reduce using rule 83 (neuralbool -> NOT .)
    ID              reduce using rule 83 (neuralbool -> NOT .)


state 120

    (84) arithexp -> geoexp arithexp1 .

    GREATER         reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    GREATERAND      reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    LESSER          reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    LESSERAND       reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    SAME            reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    NOTSAME         reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    NOT             reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    AND             reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    OR              reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    READ            reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    WRITE           reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    RETURN          reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    IF              reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    FOR             reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    ID              reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    WHILE           reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    LEFTPAR         reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    CTEINT          reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    CTEFLOAT        reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    CTECHAR         reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    RIGHTBR         reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    RIGHTPAR        reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    RIGHTSQR        reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    COMMA           reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    SEMICOLON       reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    TO              reduce using rule 84 (arithexp -> geoexp arithexp1 .)
    DO              reduce using rule 84 (arithexp -> geoexp arithexp1 .)


state 121

    (85) arithexp1 -> neuralarith . arithexp
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    arithexp                       shift and go to state 155
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 122

    (86) arithexp1 -> empty .

    GREATER         reduce using rule 86 (arithexp1 -> empty .)
    GREATERAND      reduce using rule 86 (arithexp1 -> empty .)
    LESSER          reduce using rule 86 (arithexp1 -> empty .)
    LESSERAND       reduce using rule 86 (arithexp1 -> empty .)
    SAME            reduce using rule 86 (arithexp1 -> empty .)
    NOTSAME         reduce using rule 86 (arithexp1 -> empty .)
    NOT             reduce using rule 86 (arithexp1 -> empty .)
    AND             reduce using rule 86 (arithexp1 -> empty .)
    OR              reduce using rule 86 (arithexp1 -> empty .)
    READ            reduce using rule 86 (arithexp1 -> empty .)
    WRITE           reduce using rule 86 (arithexp1 -> empty .)
    RETURN          reduce using rule 86 (arithexp1 -> empty .)
    IF              reduce using rule 86 (arithexp1 -> empty .)
    FOR             reduce using rule 86 (arithexp1 -> empty .)
    ID              reduce using rule 86 (arithexp1 -> empty .)
    WHILE           reduce using rule 86 (arithexp1 -> empty .)
    LEFTPAR         reduce using rule 86 (arithexp1 -> empty .)
    CTEINT          reduce using rule 86 (arithexp1 -> empty .)
    CTEFLOAT        reduce using rule 86 (arithexp1 -> empty .)
    CTECHAR         reduce using rule 86 (arithexp1 -> empty .)
    RIGHTBR         reduce using rule 86 (arithexp1 -> empty .)
    RIGHTPAR        reduce using rule 86 (arithexp1 -> empty .)
    RIGHTSQR        reduce using rule 86 (arithexp1 -> empty .)
    COMMA           reduce using rule 86 (arithexp1 -> empty .)
    SEMICOLON       reduce using rule 86 (arithexp1 -> empty .)
    TO              reduce using rule 86 (arithexp1 -> empty .)
    DO              reduce using rule 86 (arithexp1 -> empty .)


state 123

    (87) neuralarith -> PLUS .

    LEFTPAR         reduce using rule 87 (neuralarith -> PLUS .)
    CTEINT          reduce using rule 87 (neuralarith -> PLUS .)
    CTEFLOAT        reduce using rule 87 (neuralarith -> PLUS .)
    CTECHAR         reduce using rule 87 (neuralarith -> PLUS .)
    ID              reduce using rule 87 (neuralarith -> PLUS .)


state 124

    (88) neuralarith -> REST .

    LEFTPAR         reduce using rule 88 (neuralarith -> REST .)
    CTEINT          reduce using rule 88 (neuralarith -> REST .)
    CTEFLOAT        reduce using rule 88 (neuralarith -> REST .)
    CTECHAR         reduce using rule 88 (neuralarith -> REST .)
    ID              reduce using rule 88 (neuralarith -> REST .)


state 125

    (89) geoexp -> finexp geoexp1 .

    PLUS            reduce using rule 89 (geoexp -> finexp geoexp1 .)
    REST            reduce using rule 89 (geoexp -> finexp geoexp1 .)
    GREATER         reduce using rule 89 (geoexp -> finexp geoexp1 .)
    GREATERAND      reduce using rule 89 (geoexp -> finexp geoexp1 .)
    LESSER          reduce using rule 89 (geoexp -> finexp geoexp1 .)
    LESSERAND       reduce using rule 89 (geoexp -> finexp geoexp1 .)
    SAME            reduce using rule 89 (geoexp -> finexp geoexp1 .)
    NOTSAME         reduce using rule 89 (geoexp -> finexp geoexp1 .)
    NOT             reduce using rule 89 (geoexp -> finexp geoexp1 .)
    AND             reduce using rule 89 (geoexp -> finexp geoexp1 .)
    OR              reduce using rule 89 (geoexp -> finexp geoexp1 .)
    READ            reduce using rule 89 (geoexp -> finexp geoexp1 .)
    WRITE           reduce using rule 89 (geoexp -> finexp geoexp1 .)
    RETURN          reduce using rule 89 (geoexp -> finexp geoexp1 .)
    IF              reduce using rule 89 (geoexp -> finexp geoexp1 .)
    FOR             reduce using rule 89 (geoexp -> finexp geoexp1 .)
    ID              reduce using rule 89 (geoexp -> finexp geoexp1 .)
    WHILE           reduce using rule 89 (geoexp -> finexp geoexp1 .)
    LEFTPAR         reduce using rule 89 (geoexp -> finexp geoexp1 .)
    CTEINT          reduce using rule 89 (geoexp -> finexp geoexp1 .)
    CTEFLOAT        reduce using rule 89 (geoexp -> finexp geoexp1 .)
    CTECHAR         reduce using rule 89 (geoexp -> finexp geoexp1 .)
    RIGHTBR         reduce using rule 89 (geoexp -> finexp geoexp1 .)
    RIGHTPAR        reduce using rule 89 (geoexp -> finexp geoexp1 .)
    RIGHTSQR        reduce using rule 89 (geoexp -> finexp geoexp1 .)
    COMMA           reduce using rule 89 (geoexp -> finexp geoexp1 .)
    SEMICOLON       reduce using rule 89 (geoexp -> finexp geoexp1 .)
    TO              reduce using rule 89 (geoexp -> finexp geoexp1 .)
    DO              reduce using rule 89 (geoexp -> finexp geoexp1 .)


state 126

    (90) geoexp1 -> neuralgeo . geoexp
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    geoexp                         shift and go to state 156
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 127

    (91) geoexp1 -> empty .

    PLUS            reduce using rule 91 (geoexp1 -> empty .)
    REST            reduce using rule 91 (geoexp1 -> empty .)
    GREATER         reduce using rule 91 (geoexp1 -> empty .)
    GREATERAND      reduce using rule 91 (geoexp1 -> empty .)
    LESSER          reduce using rule 91 (geoexp1 -> empty .)
    LESSERAND       reduce using rule 91 (geoexp1 -> empty .)
    SAME            reduce using rule 91 (geoexp1 -> empty .)
    NOTSAME         reduce using rule 91 (geoexp1 -> empty .)
    NOT             reduce using rule 91 (geoexp1 -> empty .)
    AND             reduce using rule 91 (geoexp1 -> empty .)
    OR              reduce using rule 91 (geoexp1 -> empty .)
    READ            reduce using rule 91 (geoexp1 -> empty .)
    WRITE           reduce using rule 91 (geoexp1 -> empty .)
    RETURN          reduce using rule 91 (geoexp1 -> empty .)
    IF              reduce using rule 91 (geoexp1 -> empty .)
    FOR             reduce using rule 91 (geoexp1 -> empty .)
    ID              reduce using rule 91 (geoexp1 -> empty .)
    WHILE           reduce using rule 91 (geoexp1 -> empty .)
    LEFTPAR         reduce using rule 91 (geoexp1 -> empty .)
    CTEINT          reduce using rule 91 (geoexp1 -> empty .)
    CTEFLOAT        reduce using rule 91 (geoexp1 -> empty .)
    CTECHAR         reduce using rule 91 (geoexp1 -> empty .)
    RIGHTBR         reduce using rule 91 (geoexp1 -> empty .)
    RIGHTPAR        reduce using rule 91 (geoexp1 -> empty .)
    RIGHTSQR        reduce using rule 91 (geoexp1 -> empty .)
    COMMA           reduce using rule 91 (geoexp1 -> empty .)
    SEMICOLON       reduce using rule 91 (geoexp1 -> empty .)
    TO              reduce using rule 91 (geoexp1 -> empty .)
    DO              reduce using rule 91 (geoexp1 -> empty .)


state 128

    (92) neuralgeo -> TIMES .

    LEFTPAR         reduce using rule 92 (neuralgeo -> TIMES .)
    CTEINT          reduce using rule 92 (neuralgeo -> TIMES .)
    CTEFLOAT        reduce using rule 92 (neuralgeo -> TIMES .)
    CTECHAR         reduce using rule 92 (neuralgeo -> TIMES .)
    ID              reduce using rule 92 (neuralgeo -> TIMES .)


state 129

    (93) neuralgeo -> DIVIDE .

    LEFTPAR         reduce using rule 93 (neuralgeo -> DIVIDE .)
    CTEINT          reduce using rule 93 (neuralgeo -> DIVIDE .)
    CTEFLOAT        reduce using rule 93 (neuralgeo -> DIVIDE .)
    CTECHAR         reduce using rule 93 (neuralgeo -> DIVIDE .)
    ID              reduce using rule 93 (neuralgeo -> DIVIDE .)


state 130

    (96) finexp -> addparenth exp . popparenth
    (95) popparenth -> . RIGHTPAR

    RIGHTPAR        shift and go to state 158

    popparenth                     shift and go to state 157

state 131

    (101) cteexp -> ID . paramsexp
    (102) paramsexp -> . LEFTPAR paramsexp2 RIGHTPAR
    (103) paramsexp -> . idarray
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

  ! shift/reduce conflict for LEFTPAR resolved as shift
    LEFTPAR         shift and go to state 104
    LEFTSQR         shift and go to state 91
    TIMES           reduce using rule 108 (empty -> .)
    DIVIDE          reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    REST            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    GREATERAND      reduce using rule 108 (empty -> .)
    LESSER          reduce using rule 108 (empty -> .)
    LESSERAND       reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    NOTSAME         reduce using rule 108 (empty -> .)
    NOT             reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)
    RIGHTSQR        reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]

    paramsexp                      shift and go to state 103
    idarray                        shift and go to state 105
    empty                          shift and go to state 92

state 132

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON . varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules
    (3) varsgl -> . VARS vars
    (4) varsgl -> . empty
    (108) empty -> .

    VARS            shift and go to state 7
    LEFTBR          reduce using rule 108 (empty -> .)

    varsgl                         shift and go to state 159
    empty                          shift and go to state 8

state 133

    (22) parameters -> typing COLON ID . idarray mulparams
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 91
    COMMA           reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)

    idarray                        shift and go to state 160
    empty                          shift and go to state 92

state 134

    (10) varsmul -> COMMA neuralinsertvar varsarr . varsmul
    (10) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (11) varsmul -> . SEMICOLON

    COMMA           shift and go to state 39
    SEMICOLON       shift and go to state 40

    varsmul                        shift and go to state 161

state 135

    (38) assign -> neuralassign1 idarray neuralassign2 . exp SEMICOLON
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 162
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 136

    (40) neuralassign2 -> EQUAL .

    LEFTPAR         reduce using rule 40 (neuralassign2 -> EQUAL .)
    CTEINT          reduce using rule 40 (neuralassign2 -> EQUAL .)
    CTEFLOAT        reduce using rule 40 (neuralassign2 -> EQUAL .)
    CTECHAR         reduce using rule 40 (neuralassign2 -> EQUAL .)
    ID              reduce using rule 40 (neuralassign2 -> EQUAL .)


state 137

    (65) idarray -> LEFTSQR exp . RIGHTSQR

    RIGHTSQR        shift and go to state 163


state 138

    (48) reading -> READ LEFTPAR neuralread . idarray mulread RIGHTPAR SEMICOLON
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 91
    COMMA           reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)

    idarray                        shift and go to state 164
    empty                          shift and go to state 92

state 139

    (49) neuralread -> ID .

    LEFTSQR         reduce using rule 49 (neuralread -> ID .)
    COMMA           reduce using rule 49 (neuralread -> ID .)
    RIGHTPAR        reduce using rule 49 (neuralread -> ID .)


state 140

    (41) writing -> WRITE LEFTPAR auxwrite . mulwrite RIGHTPAR SEMICOLON
    (46) mulwrite -> . COMMA auxwrite mulwrite
    (47) mulwrite -> . empty
    (108) empty -> .

    COMMA           shift and go to state 166
    RIGHTPAR        reduce using rule 108 (empty -> .)

    mulwrite                       shift and go to state 165
    empty                          shift and go to state 167

state 141

    (42) auxwrite -> writetyping .

    COMMA           reduce using rule 42 (auxwrite -> writetyping .)
    RIGHTPAR        reduce using rule 42 (auxwrite -> writetyping .)


state 142

    (43) auxwrite -> exp .

    COMMA           reduce using rule 43 (auxwrite -> exp .)
    RIGHTPAR        reduce using rule 43 (auxwrite -> exp .)


state 143

    (44) writetyping -> STRING .

    COMMA           reduce using rule 44 (writetyping -> STRING .)
    RIGHTPAR        reduce using rule 44 (writetyping -> STRING .)


state 144

    (45) writetyping -> CTECHAR .
    (100) cteexp -> CTECHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 45 (writetyping -> CTECHAR .)
  ! reduce/reduce conflict for RIGHTPAR resolved using rule 45 (writetyping -> CTECHAR .)
    COMMA           reduce using rule 45 (writetyping -> CTECHAR .)
    RIGHTPAR        reduce using rule 45 (writetyping -> CTECHAR .)
    TIMES           reduce using rule 100 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 100 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 100 (cteexp -> CTECHAR .)
    REST            reduce using rule 100 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 100 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 100 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 100 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 100 (cteexp -> CTECHAR .)
    SAME            reduce using rule 100 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 100 (cteexp -> CTECHAR .)
    NOT             reduce using rule 100 (cteexp -> CTECHAR .)
    AND             reduce using rule 100 (cteexp -> CTECHAR .)
    OR              reduce using rule 100 (cteexp -> CTECHAR .)

  ! COMMA           [ reduce using rule 100 (cteexp -> CTECHAR .) ]
  ! RIGHTPAR        [ reduce using rule 100 (cteexp -> CTECHAR .) ]


state 145

    (52) returning -> RETURN LEFTPAR exp . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 168


state 146

    (53) ifing -> IF LEFTPAR exp . neuralif THEN LEFTBR statutes RIGHTBR elsing
    (54) neuralif -> . RIGHTPAR

    RIGHTPAR        shift and go to state 170

    neuralif                       shift and go to state 169

state 147

    (58) whiling -> neuralwhile1 LEFTPAR exp . neuralwhile2 DO LEFTBR statutes RIGHTBR
    (60) neuralwhile2 -> . RIGHTPAR

    RIGHTPAR        shift and go to state 172

    neuralwhile2                   shift and go to state 171

state 148

    (61) foring -> FOR neuralfor1 idarray . EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR

    EQUAL           shift and go to state 173


state 149

    (68) exp1 -> OR exp .

    READ            reduce using rule 68 (exp1 -> OR exp .)
    WRITE           reduce using rule 68 (exp1 -> OR exp .)
    RETURN          reduce using rule 68 (exp1 -> OR exp .)
    IF              reduce using rule 68 (exp1 -> OR exp .)
    FOR             reduce using rule 68 (exp1 -> OR exp .)
    ID              reduce using rule 68 (exp1 -> OR exp .)
    WHILE           reduce using rule 68 (exp1 -> OR exp .)
    LEFTPAR         reduce using rule 68 (exp1 -> OR exp .)
    CTEINT          reduce using rule 68 (exp1 -> OR exp .)
    CTEFLOAT        reduce using rule 68 (exp1 -> OR exp .)
    CTECHAR         reduce using rule 68 (exp1 -> OR exp .)
    RIGHTBR         reduce using rule 68 (exp1 -> OR exp .)
    RIGHTPAR        reduce using rule 68 (exp1 -> OR exp .)
    RIGHTSQR        reduce using rule 68 (exp1 -> OR exp .)
    COMMA           reduce using rule 68 (exp1 -> OR exp .)
    SEMICOLON       reduce using rule 68 (exp1 -> OR exp .)
    TO              reduce using rule 68 (exp1 -> OR exp .)
    DO              reduce using rule 68 (exp1 -> OR exp .)


state 150

    (102) paramsexp -> LEFTPAR paramsexp2 . RIGHTPAR

    RIGHTPAR        shift and go to state 174


state 151

    (104) paramsexp2 -> exp . auxparamsexp2
    (106) auxparamsexp2 -> . COMMA exp auxparamsexp2
    (107) auxparamsexp2 -> . empty
    (108) empty -> .

    COMMA           shift and go to state 176
    RIGHTPAR        reduce using rule 108 (empty -> .)

    auxparamsexp2                  shift and go to state 175
    empty                          shift and go to state 177

state 152

    (105) paramsexp2 -> empty .

    RIGHTPAR        reduce using rule 105 (paramsexp2 -> empty .)


state 153

    (71) andexp1 -> neuraland andexp .

    OR              reduce using rule 71 (andexp1 -> neuraland andexp .)
    READ            reduce using rule 71 (andexp1 -> neuraland andexp .)
    WRITE           reduce using rule 71 (andexp1 -> neuraland andexp .)
    RETURN          reduce using rule 71 (andexp1 -> neuraland andexp .)
    IF              reduce using rule 71 (andexp1 -> neuraland andexp .)
    FOR             reduce using rule 71 (andexp1 -> neuraland andexp .)
    ID              reduce using rule 71 (andexp1 -> neuraland andexp .)
    WHILE           reduce using rule 71 (andexp1 -> neuraland andexp .)
    LEFTPAR         reduce using rule 71 (andexp1 -> neuraland andexp .)
    CTEINT          reduce using rule 71 (andexp1 -> neuraland andexp .)
    CTEFLOAT        reduce using rule 71 (andexp1 -> neuraland andexp .)
    CTECHAR         reduce using rule 71 (andexp1 -> neuraland andexp .)
    RIGHTBR         reduce using rule 71 (andexp1 -> neuraland andexp .)
    RIGHTPAR        reduce using rule 71 (andexp1 -> neuraland andexp .)
    RIGHTSQR        reduce using rule 71 (andexp1 -> neuraland andexp .)
    COMMA           reduce using rule 71 (andexp1 -> neuraland andexp .)
    SEMICOLON       reduce using rule 71 (andexp1 -> neuraland andexp .)
    TO              reduce using rule 71 (andexp1 -> neuraland andexp .)
    DO              reduce using rule 71 (andexp1 -> neuraland andexp .)


state 154

    (75) boolexp1 -> neuralbool arithexp .

    AND             reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    OR              reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    READ            reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    WRITE           reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    RETURN          reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    IF              reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    FOR             reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    ID              reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    WHILE           reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    LEFTPAR         reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    CTEINT          reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    CTEFLOAT        reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    CTECHAR         reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    RIGHTBR         reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    RIGHTPAR        reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    RIGHTSQR        reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    COMMA           reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    SEMICOLON       reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    TO              reduce using rule 75 (boolexp1 -> neuralbool arithexp .)
    DO              reduce using rule 75 (boolexp1 -> neuralbool arithexp .)


state 155

    (85) arithexp1 -> neuralarith arithexp .

    GREATER         reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    GREATERAND      reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    LESSER          reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    LESSERAND       reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    SAME            reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    NOTSAME         reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    NOT             reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    AND             reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    OR              reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    READ            reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    WRITE           reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    RETURN          reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    IF              reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    FOR             reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    ID              reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    WHILE           reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    LEFTPAR         reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    CTEINT          reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    CTEFLOAT        reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    CTECHAR         reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    RIGHTBR         reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    RIGHTPAR        reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    RIGHTSQR        reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    COMMA           reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    SEMICOLON       reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    TO              reduce using rule 85 (arithexp1 -> neuralarith arithexp .)
    DO              reduce using rule 85 (arithexp1 -> neuralarith arithexp .)


state 156

    (90) geoexp1 -> neuralgeo geoexp .

    PLUS            reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    REST            reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    GREATER         reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    GREATERAND      reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    LESSER          reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    LESSERAND       reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    SAME            reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    NOTSAME         reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    NOT             reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    AND             reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    OR              reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    READ            reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    WRITE           reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    RETURN          reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    IF              reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    FOR             reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    ID              reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    WHILE           reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    LEFTPAR         reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    CTEINT          reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    CTEFLOAT        reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    CTECHAR         reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    RIGHTBR         reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    RIGHTPAR        reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    RIGHTSQR        reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    COMMA           reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    SEMICOLON       reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    TO              reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)
    DO              reduce using rule 90 (geoexp1 -> neuralgeo geoexp .)


state 157

    (96) finexp -> addparenth exp popparenth .

    TIMES           reduce using rule 96 (finexp -> addparenth exp popparenth .)
    DIVIDE          reduce using rule 96 (finexp -> addparenth exp popparenth .)
    PLUS            reduce using rule 96 (finexp -> addparenth exp popparenth .)
    REST            reduce using rule 96 (finexp -> addparenth exp popparenth .)
    GREATER         reduce using rule 96 (finexp -> addparenth exp popparenth .)
    GREATERAND      reduce using rule 96 (finexp -> addparenth exp popparenth .)
    LESSER          reduce using rule 96 (finexp -> addparenth exp popparenth .)
    LESSERAND       reduce using rule 96 (finexp -> addparenth exp popparenth .)
    SAME            reduce using rule 96 (finexp -> addparenth exp popparenth .)
    NOTSAME         reduce using rule 96 (finexp -> addparenth exp popparenth .)
    NOT             reduce using rule 96 (finexp -> addparenth exp popparenth .)
    AND             reduce using rule 96 (finexp -> addparenth exp popparenth .)
    OR              reduce using rule 96 (finexp -> addparenth exp popparenth .)
    READ            reduce using rule 96 (finexp -> addparenth exp popparenth .)
    WRITE           reduce using rule 96 (finexp -> addparenth exp popparenth .)
    RETURN          reduce using rule 96 (finexp -> addparenth exp popparenth .)
    IF              reduce using rule 96 (finexp -> addparenth exp popparenth .)
    FOR             reduce using rule 96 (finexp -> addparenth exp popparenth .)
    ID              reduce using rule 96 (finexp -> addparenth exp popparenth .)
    WHILE           reduce using rule 96 (finexp -> addparenth exp popparenth .)
    LEFTPAR         reduce using rule 96 (finexp -> addparenth exp popparenth .)
    CTEINT          reduce using rule 96 (finexp -> addparenth exp popparenth .)
    CTEFLOAT        reduce using rule 96 (finexp -> addparenth exp popparenth .)
    CTECHAR         reduce using rule 96 (finexp -> addparenth exp popparenth .)
    RIGHTBR         reduce using rule 96 (finexp -> addparenth exp popparenth .)
    RIGHTPAR        reduce using rule 96 (finexp -> addparenth exp popparenth .)
    RIGHTSQR        reduce using rule 96 (finexp -> addparenth exp popparenth .)
    COMMA           reduce using rule 96 (finexp -> addparenth exp popparenth .)
    SEMICOLON       reduce using rule 96 (finexp -> addparenth exp popparenth .)
    TO              reduce using rule 96 (finexp -> addparenth exp popparenth .)
    DO              reduce using rule 96 (finexp -> addparenth exp popparenth .)


state 158

    (95) popparenth -> RIGHTPAR .

    TIMES           reduce using rule 95 (popparenth -> RIGHTPAR .)
    DIVIDE          reduce using rule 95 (popparenth -> RIGHTPAR .)
    PLUS            reduce using rule 95 (popparenth -> RIGHTPAR .)
    REST            reduce using rule 95 (popparenth -> RIGHTPAR .)
    GREATER         reduce using rule 95 (popparenth -> RIGHTPAR .)
    GREATERAND      reduce using rule 95 (popparenth -> RIGHTPAR .)
    LESSER          reduce using rule 95 (popparenth -> RIGHTPAR .)
    LESSERAND       reduce using rule 95 (popparenth -> RIGHTPAR .)
    SAME            reduce using rule 95 (popparenth -> RIGHTPAR .)
    NOTSAME         reduce using rule 95 (popparenth -> RIGHTPAR .)
    NOT             reduce using rule 95 (popparenth -> RIGHTPAR .)
    AND             reduce using rule 95 (popparenth -> RIGHTPAR .)
    OR              reduce using rule 95 (popparenth -> RIGHTPAR .)
    READ            reduce using rule 95 (popparenth -> RIGHTPAR .)
    WRITE           reduce using rule 95 (popparenth -> RIGHTPAR .)
    RETURN          reduce using rule 95 (popparenth -> RIGHTPAR .)
    IF              reduce using rule 95 (popparenth -> RIGHTPAR .)
    FOR             reduce using rule 95 (popparenth -> RIGHTPAR .)
    ID              reduce using rule 95 (popparenth -> RIGHTPAR .)
    WHILE           reduce using rule 95 (popparenth -> RIGHTPAR .)
    LEFTPAR         reduce using rule 95 (popparenth -> RIGHTPAR .)
    CTEINT          reduce using rule 95 (popparenth -> RIGHTPAR .)
    CTEFLOAT        reduce using rule 95 (popparenth -> RIGHTPAR .)
    CTECHAR         reduce using rule 95 (popparenth -> RIGHTPAR .)
    RIGHTBR         reduce using rule 95 (popparenth -> RIGHTPAR .)
    RIGHTPAR        reduce using rule 95 (popparenth -> RIGHTPAR .)
    RIGHTSQR        reduce using rule 95 (popparenth -> RIGHTPAR .)
    COMMA           reduce using rule 95 (popparenth -> RIGHTPAR .)
    SEMICOLON       reduce using rule 95 (popparenth -> RIGHTPAR .)
    TO              reduce using rule 95 (popparenth -> RIGHTPAR .)
    DO              reduce using rule 95 (popparenth -> RIGHTPAR .)


state 159

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl . LEFTBR statutes RIGHTBR neuralendfuncs modules

    LEFTBR          shift and go to state 178


state 160

    (22) parameters -> typing COLON ID idarray . mulparams
    (24) mulparams -> . COMMA parameters
    (25) mulparams -> . empty
    (108) empty -> .

    COMMA           shift and go to state 180
    RIGHTPAR        reduce using rule 108 (empty -> .)

    mulparams                      shift and go to state 179
    empty                          shift and go to state 181

state 161

    (10) varsmul -> COMMA neuralinsertvar varsarr varsmul .

    INT             reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FLOAT           reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    CHAR            reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FUNCTION        reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    MAIN            reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    LEFTBR          reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)


state 162

    (38) assign -> neuralassign1 idarray neuralassign2 exp . SEMICOLON

    SEMICOLON       shift and go to state 182


state 163

    (65) idarray -> LEFTSQR exp RIGHTSQR .

    EQUAL           reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    TIMES           reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    DIVIDE          reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    PLUS            reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    REST            reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    GREATER         reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    GREATERAND      reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    LESSER          reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    LESSERAND       reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    SAME            reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    NOTSAME         reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    NOT             reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    AND             reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    OR              reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    READ            reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    WRITE           reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    RETURN          reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    IF              reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    FOR             reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    ID              reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    WHILE           reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    LEFTPAR         reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTEINT          reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTEFLOAT        reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTECHAR         reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTBR         reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTPAR        reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTSQR        reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    COMMA           reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    SEMICOLON       reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    TO              reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)
    DO              reduce using rule 65 (idarray -> LEFTSQR exp RIGHTSQR .)


state 164

    (48) reading -> READ LEFTPAR neuralread idarray . mulread RIGHTPAR SEMICOLON
    (50) mulread -> . COMMA ID idarray mulread
    (51) mulread -> . empty
    (108) empty -> .

    COMMA           shift and go to state 184
    RIGHTPAR        reduce using rule 108 (empty -> .)

    mulread                        shift and go to state 183
    empty                          shift and go to state 185

state 165

    (41) writing -> WRITE LEFTPAR auxwrite mulwrite . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 186


state 166

    (46) mulwrite -> COMMA . auxwrite mulwrite
    (42) auxwrite -> . writetyping
    (43) auxwrite -> . exp
    (44) writetyping -> . STRING
    (45) writetyping -> . CTECHAR
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    STRING          shift and go to state 143
    CTECHAR         shift and go to state 144
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    ID              shift and go to state 131

    auxwrite                       shift and go to state 187
    writetyping                    shift and go to state 141
    exp                            shift and go to state 142
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 167

    (47) mulwrite -> empty .

    RIGHTPAR        reduce using rule 47 (mulwrite -> empty .)


state 168

    (52) returning -> RETURN LEFTPAR exp RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 188


state 169

    (53) ifing -> IF LEFTPAR exp neuralif . THEN LEFTBR statutes RIGHTBR elsing

    THEN            shift and go to state 189


state 170

    (54) neuralif -> RIGHTPAR .

    THEN            reduce using rule 54 (neuralif -> RIGHTPAR .)


state 171

    (58) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 190


state 172

    (60) neuralwhile2 -> RIGHTPAR .

    DO              reduce using rule 60 (neuralwhile2 -> RIGHTPAR .)


state 173

    (61) foring -> FOR neuralfor1 idarray EQUAL . exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 191
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 174

    (102) paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .

    TIMES           reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    DIVIDE          reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    PLUS            reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    REST            reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    GREATER         reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    GREATERAND      reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    LESSER          reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    LESSERAND       reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    SAME            reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    NOTSAME         reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    NOT             reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    AND             reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    OR              reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    READ            reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    WRITE           reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RETURN          reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    IF              reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    FOR             reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    ID              reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    WHILE           reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    LEFTPAR         reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    CTEINT          reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    CTEFLOAT        reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    CTECHAR         reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RIGHTBR         reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RIGHTPAR        reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RIGHTSQR        reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    COMMA           reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    SEMICOLON       reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    TO              reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    DO              reduce using rule 102 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)


state 175

    (104) paramsexp2 -> exp auxparamsexp2 .

    RIGHTPAR        reduce using rule 104 (paramsexp2 -> exp auxparamsexp2 .)


state 176

    (106) auxparamsexp2 -> COMMA . exp auxparamsexp2
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 192
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 177

    (107) auxparamsexp2 -> empty .

    RIGHTPAR        reduce using rule 107 (auxparamsexp2 -> empty .)


state 178

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR . statutes RIGHTBR neuralendfuncs modules
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (108) empty -> .
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    RIGHTBR         reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    statutes                       shift and go to state 193
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    empty                          shift and go to state 61
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 179

    (22) parameters -> typing COLON ID idarray mulparams .

    RIGHTPAR        reduce using rule 22 (parameters -> typing COLON ID idarray mulparams .)


state 180

    (24) mulparams -> COMMA . parameters
    (22) parameters -> . typing COLON ID idarray mulparams
    (23) parameters -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (108) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 108 (empty -> .)

    parameters                     shift and go to state 194
    typing                         shift and go to state 36
    empty                          shift and go to state 37

state 181

    (25) mulparams -> empty .

    RIGHTPAR        reduce using rule 25 (mulparams -> empty .)


state 182

    (38) assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .

    READ            reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    WRITE           reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    RETURN          reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    IF              reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    FOR             reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    ID              reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    WHILE           reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    LEFTPAR         reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    CTEINT          reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    CTEFLOAT        reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    CTECHAR         reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)
    RIGHTBR         reduce using rule 38 (assign -> neuralassign1 idarray neuralassign2 exp SEMICOLON .)


state 183

    (48) reading -> READ LEFTPAR neuralread idarray mulread . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 195


state 184

    (50) mulread -> COMMA . ID idarray mulread

    ID              shift and go to state 196


state 185

    (51) mulread -> empty .

    RIGHTPAR        reduce using rule 51 (mulread -> empty .)


state 186

    (41) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 197


state 187

    (46) mulwrite -> COMMA auxwrite . mulwrite
    (46) mulwrite -> . COMMA auxwrite mulwrite
    (47) mulwrite -> . empty
    (108) empty -> .

    COMMA           shift and go to state 166
    RIGHTPAR        reduce using rule 108 (empty -> .)

    mulwrite                       shift and go to state 198
    empty                          shift and go to state 167

state 188

    (52) returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .

    READ            reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    IF              reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    ID              reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 52 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)


state 189

    (53) ifing -> IF LEFTPAR exp neuralif THEN . LEFTBR statutes RIGHTBR elsing

    LEFTBR          shift and go to state 199


state 190

    (58) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 200


state 191

    (61) foring -> FOR neuralfor1 idarray EQUAL exp . neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (63) neuralfor2 -> . TO

    TO              shift and go to state 202

    neuralfor2                     shift and go to state 201

state 192

    (106) auxparamsexp2 -> COMMA exp . auxparamsexp2
    (106) auxparamsexp2 -> . COMMA exp auxparamsexp2
    (107) auxparamsexp2 -> . empty
    (108) empty -> .

    COMMA           shift and go to state 176
    RIGHTPAR        reduce using rule 108 (empty -> .)

    auxparamsexp2                  shift and go to state 203
    empty                          shift and go to state 177

state 193

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes . RIGHTBR neuralendfuncs modules

    RIGHTBR         shift and go to state 204


state 194

    (24) mulparams -> COMMA parameters .

    RIGHTPAR        reduce using rule 24 (mulparams -> COMMA parameters .)


state 195

    (48) reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 205


state 196

    (50) mulread -> COMMA ID . idarray mulread
    (65) idarray -> . LEFTSQR exp RIGHTSQR
    (66) idarray -> . empty
    (108) empty -> .

    LEFTSQR         shift and go to state 91
    COMMA           reduce using rule 108 (empty -> .)
    RIGHTPAR        reduce using rule 108 (empty -> .)

    idarray                        shift and go to state 206
    empty                          shift and go to state 92

state 197

    (41) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .

    READ            reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    IF              reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    ID              reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 41 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)


state 198

    (46) mulwrite -> COMMA auxwrite mulwrite .

    RIGHTPAR        reduce using rule 46 (mulwrite -> COMMA auxwrite mulwrite .)


state 199

    (53) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR . statutes RIGHTBR elsing
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (108) empty -> .
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    RIGHTBR         reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    exp                            shift and go to state 51
    statutes                       shift and go to state 207
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    empty                          shift and go to state 61
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 200

    (58) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR . statutes RIGHTBR
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (108) empty -> .
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    RIGHTBR         reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    neuralwhile1                   shift and go to state 58
    exp                            shift and go to state 51
    statutes                       shift and go to state 208
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    andexp                         shift and go to state 60
    empty                          shift and go to state 61
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 201

    (61) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 . exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (70) andexp -> . boolexp andexp1
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72
    ID              shift and go to state 131

    exp                            shift and go to state 209
    andexp                         shift and go to state 60
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 202

    (63) neuralfor2 -> TO .

    LEFTPAR         reduce using rule 63 (neuralfor2 -> TO .)
    CTEINT          reduce using rule 63 (neuralfor2 -> TO .)
    CTEFLOAT        reduce using rule 63 (neuralfor2 -> TO .)
    CTECHAR         reduce using rule 63 (neuralfor2 -> TO .)
    ID              reduce using rule 63 (neuralfor2 -> TO .)


state 203

    (106) auxparamsexp2 -> COMMA exp auxparamsexp2 .

    RIGHTPAR        reduce using rule 106 (auxparamsexp2 -> COMMA exp auxparamsexp2 .)


state 204

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR . neuralendfuncs modules
    (18) neuralendfuncs -> .

    FUNCTION        reduce using rule 18 (neuralendfuncs -> .)
    MAIN            reduce using rule 18 (neuralendfuncs -> .)

    neuralendfuncs                 shift and go to state 210

state 205

    (48) reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .

    READ            reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    IF              reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    ID              reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 48 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)


state 206

    (50) mulread -> COMMA ID idarray . mulread
    (50) mulread -> . COMMA ID idarray mulread
    (51) mulread -> . empty
    (108) empty -> .

    COMMA           shift and go to state 184
    RIGHTPAR        reduce using rule 108 (empty -> .)

    mulread                        shift and go to state 211
    empty                          shift and go to state 185

state 207

    (53) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes . RIGHTBR elsing

    RIGHTBR         shift and go to state 212


state 208

    (58) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 213


state 209

    (61) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp . neuralfor3 LEFTBR statutes RIGHTBR
    (64) neuralfor3 -> . DO

    DO              shift and go to state 215

    neuralfor3                     shift and go to state 214

state 210

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs . modules
    (12) modules -> . FUNCTION functype neuralinsertfuncname funcparam
    (13) modules -> . empty
    (108) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 108 (empty -> .)

    modules                        shift and go to state 216
    empty                          shift and go to state 11

state 211

    (50) mulread -> COMMA ID idarray mulread .

    RIGHTPAR        reduce using rule 50 (mulread -> COMMA ID idarray mulread .)


state 212

    (53) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR . elsing
    (55) elsing -> . neuralelse LEFTBR statutes RIGHTBR
    (56) elsing -> . empty
    (57) neuralelse -> . ELSE
    (108) empty -> .

    ELSE            shift and go to state 220
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    LEFTPAR         reduce using rule 108 (empty -> .)
    CTEINT          reduce using rule 108 (empty -> .)
    CTEFLOAT        reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    RIGHTBR         reduce using rule 108 (empty -> .)

    elsing                         shift and go to state 217
    neuralelse                     shift and go to state 218
    empty                          shift and go to state 219

state 213

    (58) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .

    READ            reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 58 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)


state 214

    (61) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 221


state 215

    (64) neuralfor3 -> DO .

    LEFTBR          reduce using rule 64 (neuralfor3 -> DO .)


state 216

    (17) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules .

    MAIN            reduce using rule 17 (funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR neuralendfuncs modules .)


state 217

    (53) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .

    READ            reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    WRITE           reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    RETURN          reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    IF              reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    FOR             reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    ID              reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    WHILE           reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    LEFTPAR         reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTEINT          reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTEFLOAT        reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTECHAR         reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    RIGHTBR         reduce using rule 53 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)


state 218

    (55) elsing -> neuralelse . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 222


state 219

    (56) elsing -> empty .

    READ            reduce using rule 56 (elsing -> empty .)
    WRITE           reduce using rule 56 (elsing -> empty .)
    RETURN          reduce using rule 56 (elsing -> empty .)
    IF              reduce using rule 56 (elsing -> empty .)
    FOR             reduce using rule 56 (elsing -> empty .)
    ID              reduce using rule 56 (elsing -> empty .)
    WHILE           reduce using rule 56 (elsing -> empty .)
    LEFTPAR         reduce using rule 56 (elsing -> empty .)
    CTEINT          reduce using rule 56 (elsing -> empty .)
    CTEFLOAT        reduce using rule 56 (elsing -> empty .)
    CTECHAR         reduce using rule 56 (elsing -> empty .)
    RIGHTBR         reduce using rule 56 (elsing -> empty .)


state 220

    (57) neuralelse -> ELSE .

    LEFTBR          reduce using rule 57 (neuralelse -> ELSE .)


state 221

    (61) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR . statutes RIGHTBR
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (108) empty -> .
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    RIGHTBR         reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    exp                            shift and go to state 51
    statutes                       shift and go to state 223
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    empty                          shift and go to state 61
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 222

    (55) elsing -> neuralelse LEFTBR . statutes RIGHTBR
    (26) statutes -> . assign statutesaux
    (27) statutes -> . reading statutesaux
    (28) statutes -> . writing statutesaux
    (29) statutes -> . returning statutesaux
    (30) statutes -> . ifing statutesaux
    (31) statutes -> . whiling statutesaux
    (32) statutes -> . foring statutesaux
    (33) statutes -> . exp statutesaux
    (34) statutes -> . specialfunc statutesaux
    (38) assign -> . neuralassign1 idarray neuralassign2 exp SEMICOLON
    (48) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (41) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (52) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (53) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (58) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (61) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (67) exp -> . andexp exp1
    (37) specialfunc -> . empty
    (39) neuralassign1 -> . ID
    (59) neuralwhile1 -> . WHILE
    (70) andexp -> . boolexp andexp1
    (108) empty -> .
    (74) boolexp -> . arithexp boolexp1
    (84) arithexp -> . geoexp arithexp1
    (89) geoexp -> . finexp geoexp1
    (96) finexp -> . addparenth exp popparenth
    (97) finexp -> . cteexp
    (94) addparenth -> . LEFTPAR
    (98) cteexp -> . CTEINT
    (99) cteexp -> . CTEFLOAT
    (100) cteexp -> . CTECHAR
    (101) cteexp -> . ID paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 54
    WRITE           shift and go to state 55
    RETURN          shift and go to state 56
    IF              shift and go to state 57
    FOR             shift and go to state 59
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    RIGHTBR         reduce using rule 108 (empty -> .)
    LEFTPAR         shift and go to state 42
    CTEINT          shift and go to state 70
    CTEFLOAT        shift and go to state 71
    CTECHAR         shift and go to state 72

  ! READ            [ reduce using rule 108 (empty -> .) ]
  ! WRITE           [ reduce using rule 108 (empty -> .) ]
  ! RETURN          [ reduce using rule 108 (empty -> .) ]
  ! IF              [ reduce using rule 108 (empty -> .) ]
  ! FOR             [ reduce using rule 108 (empty -> .) ]
  ! ID              [ reduce using rule 108 (empty -> .) ]
  ! WHILE           [ reduce using rule 108 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 108 (empty -> .) ]
  ! CTEINT          [ reduce using rule 108 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 108 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 108 (empty -> .) ]

    statutes                       shift and go to state 224
    assign                         shift and go to state 44
    reading                        shift and go to state 45
    writing                        shift and go to state 46
    returning                      shift and go to state 47
    ifing                          shift and go to state 48
    whiling                        shift and go to state 49
    foring                         shift and go to state 50
    exp                            shift and go to state 51
    specialfunc                    shift and go to state 52
    neuralassign1                  shift and go to state 53
    neuralwhile1                   shift and go to state 58
    andexp                         shift and go to state 60
    empty                          shift and go to state 61
    boolexp                        shift and go to state 64
    arithexp                       shift and go to state 65
    geoexp                         shift and go to state 66
    finexp                         shift and go to state 67
    addparenth                     shift and go to state 68
    cteexp                         shift and go to state 69

state 223

    (61) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 225


state 224

    (55) elsing -> neuralelse LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 226


state 225

    (61) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .

    READ            reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 61 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)


state 226

    (55) elsing -> neuralelse LEFTBR statutes RIGHTBR .

    READ            reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 55 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for READ in state 34 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 34 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 34 resolved as shift
WARNING: shift/reduce conflict for IF in state 34 resolved as shift
WARNING: shift/reduce conflict for FOR in state 34 resolved as shift
WARNING: shift/reduce conflict for ID in state 34 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 34 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 34 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 34 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 34 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 34 resolved as shift
WARNING: shift/reduce conflict for READ in state 44 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 44 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for FOR in state 44 resolved as shift
WARNING: shift/reduce conflict for ID in state 44 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 44 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 44 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 44 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 44 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 44 resolved as shift
WARNING: shift/reduce conflict for READ in state 45 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 45 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for FOR in state 45 resolved as shift
WARNING: shift/reduce conflict for ID in state 45 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 45 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 45 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 45 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 45 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 45 resolved as shift
WARNING: shift/reduce conflict for READ in state 46 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 46 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for FOR in state 46 resolved as shift
WARNING: shift/reduce conflict for ID in state 46 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 46 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 46 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 46 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 46 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 46 resolved as shift
WARNING: shift/reduce conflict for READ in state 47 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for FOR in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 47 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 47 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 47 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 47 resolved as shift
WARNING: shift/reduce conflict for READ in state 48 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 48 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 48 resolved as shift
WARNING: shift/reduce conflict for IF in state 48 resolved as shift
WARNING: shift/reduce conflict for FOR in state 48 resolved as shift
WARNING: shift/reduce conflict for ID in state 48 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 48 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 48 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 48 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 48 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 48 resolved as shift
WARNING: shift/reduce conflict for READ in state 49 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 49 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 49 resolved as shift
WARNING: shift/reduce conflict for IF in state 49 resolved as shift
WARNING: shift/reduce conflict for FOR in state 49 resolved as shift
WARNING: shift/reduce conflict for ID in state 49 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 49 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 49 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 49 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 49 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 49 resolved as shift
WARNING: shift/reduce conflict for READ in state 50 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 50 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 50 resolved as shift
WARNING: shift/reduce conflict for IF in state 50 resolved as shift
WARNING: shift/reduce conflict for FOR in state 50 resolved as shift
WARNING: shift/reduce conflict for ID in state 50 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 50 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 50 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 50 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 50 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 50 resolved as shift
WARNING: shift/reduce conflict for READ in state 51 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 51 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 51 resolved as shift
WARNING: shift/reduce conflict for IF in state 51 resolved as shift
WARNING: shift/reduce conflict for FOR in state 51 resolved as shift
WARNING: shift/reduce conflict for ID in state 51 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 51 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 51 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 51 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 51 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 51 resolved as shift
WARNING: shift/reduce conflict for READ in state 52 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 52 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 52 resolved as shift
WARNING: shift/reduce conflict for IF in state 52 resolved as shift
WARNING: shift/reduce conflict for FOR in state 52 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 52 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 52 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 52 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 52 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 52 resolved as shift
WARNING: shift/reduce conflict for LEFTSQR in state 62 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 62 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 131 resolved as shift
WARNING: shift/reduce conflict for READ in state 178 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 178 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 178 resolved as shift
WARNING: shift/reduce conflict for IF in state 178 resolved as shift
WARNING: shift/reduce conflict for FOR in state 178 resolved as shift
WARNING: shift/reduce conflict for ID in state 178 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 178 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 178 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 178 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 178 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 178 resolved as shift
WARNING: shift/reduce conflict for READ in state 199 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 199 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 199 resolved as shift
WARNING: shift/reduce conflict for IF in state 199 resolved as shift
WARNING: shift/reduce conflict for FOR in state 199 resolved as shift
WARNING: shift/reduce conflict for ID in state 199 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 199 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 199 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 199 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 199 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 199 resolved as shift
WARNING: shift/reduce conflict for READ in state 200 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 200 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 200 resolved as shift
WARNING: shift/reduce conflict for IF in state 200 resolved as shift
WARNING: shift/reduce conflict for FOR in state 200 resolved as shift
WARNING: shift/reduce conflict for ID in state 200 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 200 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 200 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 200 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 200 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 200 resolved as shift
WARNING: shift/reduce conflict for READ in state 221 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 221 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 221 resolved as shift
WARNING: shift/reduce conflict for IF in state 221 resolved as shift
WARNING: shift/reduce conflict for FOR in state 221 resolved as shift
WARNING: shift/reduce conflict for ID in state 221 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 221 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 221 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 221 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 221 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 221 resolved as shift
WARNING: shift/reduce conflict for READ in state 222 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 222 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 222 resolved as shift
WARNING: shift/reduce conflict for IF in state 222 resolved as shift
WARNING: shift/reduce conflict for FOR in state 222 resolved as shift
WARNING: shift/reduce conflict for ID in state 222 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 222 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 222 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 222 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 222 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 222 resolved as shift
WARNING: reduce/reduce conflict in state 81 resolved using rule (statutesaux -> empty)
WARNING: rejected rule (specialfunc -> empty) in state 81
WARNING: reduce/reduce conflict in state 144 resolved using rule (writetyping -> CTECHAR)
WARNING: rejected rule (cteexp -> CTECHAR) in state 144
