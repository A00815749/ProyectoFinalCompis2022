Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    STR
    TRUE
    FALSE
    MEDIA
    MEDIANA
    MODA
    VARIANZA
    STDEV
    PLOTXY

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
Rule 2     neuraltablefunctions -> ID
Rule 3     varsgl -> VARS vars
Rule 4     varsgl -> empty
Rule 5     vars -> typing COLON neuralinsertvar varsarr varsmul vars
Rule 6     vars -> empty
Rule 7     neuralinsertvar -> ID
Rule 8     varsarr -> LEFTSQR CTEINT RIGHTSQR
Rule 9     varsarr -> empty
Rule 10    varsmul -> COMMA neuralinsertvar varsarr varsmul
Rule 11    varsmul -> SEMICOLON
Rule 12    modules -> FUNCTION functype ID funcparam
Rule 13    modules -> empty
Rule 14    functype -> VOID
Rule 15    functype -> typing
Rule 16    funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR modules
Rule 17    typing -> INT
Rule 18    typing -> FLOAT
Rule 19    typing -> CHAR
Rule 20    parameters -> typing COLON ID idarray mulparams
Rule 21    parameters -> empty
Rule 22    mulparams -> COMMA parameters
Rule 23    mulparams -> empty
Rule 24    statutes -> assign statutesaux
Rule 25    statutes -> reading statutesaux
Rule 26    statutes -> writing statutesaux
Rule 27    statutes -> returning statutesaux
Rule 28    statutes -> ifing statutesaux
Rule 29    statutes -> whiling statutesaux
Rule 30    statutes -> foring statutesaux
Rule 31    statutes -> exp statutesaux
Rule 32    statutes -> specialfunc statutesaux
Rule 33    statutesaux -> statutes
Rule 34    statutesaux -> empty
Rule 35    specialfunc -> empty
Rule 36    assign -> ID idarray EQUAL exp SEMICOLON
Rule 37    writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
Rule 38    auxwrite -> writetyping
Rule 39    auxwrite -> exp
Rule 40    writetyping -> STRING
Rule 41    writetyping -> CTECHAR
Rule 42    mulwrite -> COMMA auxwrite mulwrite
Rule 43    mulwrite -> empty
Rule 44    reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
Rule 45    mulread -> COMMA ID idarray mulread
Rule 46    mulread -> empty
Rule 47    returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON
Rule 48    ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
Rule 49    elsing -> ELSE LEFTBR statutes RIGHTBR
Rule 50    elsing -> empty
Rule 51    whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
Rule 52    foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
Rule 53    idarray -> LEFTSQR exp RIGHTSQR
Rule 54    idarray -> empty
Rule 55    exp -> andexp exp1
Rule 56    exp1 -> OR exp
Rule 57    exp1 -> empty
Rule 58    andexp -> boolexp andexp1
Rule 59    andexp1 -> AND andexp
Rule 60    andexp1 -> empty
Rule 61    boolexp -> arithexp boolexp1
Rule 62    boolexp1 -> GREATER arithexp
Rule 63    boolexp1 -> GREATERAND arithexp
Rule 64    boolexp1 -> LESSER arithexp
Rule 65    boolexp1 -> LESSERAND arithexp
Rule 66    boolexp1 -> SAME arithexp
Rule 67    boolexp1 -> NOTSAME arithexp
Rule 68    boolexp1 -> NOT arithexp
Rule 69    boolexp1 -> empty
Rule 70    arithexp -> geoexp arithexp1
Rule 71    arithexp1 -> PLUS arithexp
Rule 72    arithexp1 -> REST arithexp
Rule 73    arithexp1 -> empty
Rule 74    geoexp -> finexp geoexp1
Rule 75    geoexp1 -> TIMES geoexp
Rule 76    geoexp1 -> DIVIDE geoexp
Rule 77    geoexp1 -> empty
Rule 78    finexp -> LEFTPAR exp RIGHTPAR
Rule 79    finexp -> cteexp
Rule 80    cteexp -> CTEINT
Rule 81    cteexp -> CTEFLOAT
Rule 82    cteexp -> CTECHAR
Rule 83    cteexp -> ID paramsexp
Rule 84    paramsexp -> LEFTPAR paramsexp2 RIGHTPAR
Rule 85    paramsexp -> idarray
Rule 86    paramsexp2 -> exp auxparamsexp2
Rule 87    paramsexp2 -> empty
Rule 88    auxparamsexp2 -> COMMA exp auxparamsexp2
Rule 89    auxparamsexp2 -> empty
Rule 90    empty -> <empty>
Rule 91    debug -> empty

Terminals, with rules where they appear

AND                  : 59
CHAR                 : 19
COLON                : 5 20
COMMA                : 10 22 42 45 88
CTECHAR              : 41 82
CTEFLOAT             : 81
CTEINT               : 8 80
DIVIDE               : 76
DO                   : 51 52
ELSE                 : 49
EQUAL                : 36 52
FALSE                : 
FLOAT                : 18
FOR                  : 52
FUNCTION             : 12
GREATER              : 62
GREATERAND           : 63
ID                   : 2 7 12 20 36 44 45 52 83
IF                   : 48
INT                  : 17
LEFTBR               : 1 16 48 49 51 52
LEFTPAR              : 1 16 37 44 47 48 51 78 84
LEFTSQR              : 8 53
LESSER               : 64
LESSERAND            : 65
MAIN                 : 1
MEDIA                : 
MEDIANA              : 
MODA                 : 
NOT                  : 68
NOTSAME              : 67
OR                   : 56
PLOTXY               : 
PLUS                 : 71
PROGRAM              : 1
READ                 : 44
REST                 : 72
RETURN               : 47
RIGHTBR              : 1 16 48 49 51 52
RIGHTPAR             : 1 16 37 44 47 48 51 78 84
RIGHTSQR             : 8 53
SAME                 : 66
SEMICOLON            : 1 11 16 36 37 44 47
STDEV                : 
STR                  : 
STRING               : 40
THEN                 : 48
TIMES                : 75
TO                   : 52
TRUE                 : 
VARIANZA             : 
VARS                 : 3
VOID                 : 14
WHILE                : 51
WRITE                : 37
error                : 

Nonterminals, with rules where they appear

andexp               : 55 59
andexp1              : 58
arithexp             : 61 62 63 64 65 66 67 68 71 72
arithexp1            : 70
assign               : 24
auxparamsexp2        : 86 88
auxwrite             : 37 42
boolexp              : 58
boolexp1             : 61
cteexp               : 79
debug                : 
elsing               : 48
empty                : 4 6 9 13 21 23 34 35 43 46 50 54 57 60 69 73 77 87 89 91
exp                  : 31 36 39 47 48 51 52 52 53 56 78 86 88
exp1                 : 55
finexp               : 74
foring               : 30
funcparam            : 12
functype             : 12
geoexp               : 70 75 76
geoexp1              : 74
idarray              : 20 36 44 45 52 85
ifing                : 28
modules              : 1 16
mulparams            : 20
mulread              : 44 45
mulwrite             : 37 42
neuralinsertvar      : 5 10
neuraltablefunctions : 1
parameters           : 16 22
paramsexp            : 83
paramsexp2           : 84
program              : 0
reading              : 25
returning            : 27
specialfunc          : 32
statutes             : 1 16 33 48 49 51 52
statutesaux          : 24 25 26 27 28 29 30 31 32
typing               : 5 15 20
vars                 : 3 5
varsarr              : 5 10
varsgl               : 1 16
varsmul              : 5 10
whiling              : 29
writetyping          : 38
writing              : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
    (2) neuraltablefunctions -> . ID

    ID              shift and go to state 4

    neuraltablefunctions           shift and go to state 3

state 3

    (1) program -> PROGRAM neuraltablefunctions . SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    SEMICOLON       shift and go to state 5


state 4

    (2) neuraltablefunctions -> ID .

    SEMICOLON       reduce using rule 2 (neuraltablefunctions -> ID .)


state 5

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON . varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
    (3) varsgl -> . VARS vars
    (4) varsgl -> . empty
    (90) empty -> .

    VARS            shift and go to state 7
    FUNCTION        reduce using rule 90 (empty -> .)
    MAIN            reduce using rule 90 (empty -> .)

    varsgl                         shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl . modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
    (12) modules -> . FUNCTION functype ID funcparam
    (13) modules -> . empty
    (90) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 90 (empty -> .)

    modules                        shift and go to state 9
    empty                          shift and go to state 11

state 7

    (3) varsgl -> VARS . vars
    (5) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (6) vars -> . empty
    (17) typing -> . INT
    (18) typing -> . FLOAT
    (19) typing -> . CHAR
    (90) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 90 (empty -> .)
    MAIN            reduce using rule 90 (empty -> .)
    LEFTBR          reduce using rule 90 (empty -> .)

    vars                           shift and go to state 12
    typing                         shift and go to state 13
    empty                          shift and go to state 14

state 8

    (4) varsgl -> empty .

    FUNCTION        reduce using rule 4 (varsgl -> empty .)
    MAIN            reduce using rule 4 (varsgl -> empty .)
    LEFTBR          reduce using rule 4 (varsgl -> empty .)


state 9

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules . MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    MAIN            shift and go to state 18


state 10

    (12) modules -> FUNCTION . functype ID funcparam
    (14) functype -> . VOID
    (15) functype -> . typing
    (17) typing -> . INT
    (18) typing -> . FLOAT
    (19) typing -> . CHAR

    VOID            shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    functype                       shift and go to state 19
    typing                         shift and go to state 21

state 11

    (13) modules -> empty .

    MAIN            reduce using rule 13 (modules -> empty .)


state 12

    (3) varsgl -> VARS vars .

    FUNCTION        reduce using rule 3 (varsgl -> VARS vars .)
    MAIN            reduce using rule 3 (varsgl -> VARS vars .)
    LEFTBR          reduce using rule 3 (varsgl -> VARS vars .)


state 13

    (5) vars -> typing . COLON neuralinsertvar varsarr varsmul vars

    COLON           shift and go to state 22


state 14

    (6) vars -> empty .

    FUNCTION        reduce using rule 6 (vars -> empty .)
    MAIN            reduce using rule 6 (vars -> empty .)
    LEFTBR          reduce using rule 6 (vars -> empty .)


state 15

    (17) typing -> INT .

    COLON           reduce using rule 17 (typing -> INT .)
    ID              reduce using rule 17 (typing -> INT .)


state 16

    (18) typing -> FLOAT .

    COLON           reduce using rule 18 (typing -> FLOAT .)
    ID              reduce using rule 18 (typing -> FLOAT .)


state 17

    (19) typing -> CHAR .

    COLON           reduce using rule 19 (typing -> CHAR .)
    ID              reduce using rule 19 (typing -> CHAR .)


state 18

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN . LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 23


state 19

    (12) modules -> FUNCTION functype . ID funcparam

    ID              shift and go to state 24


state 20

    (14) functype -> VOID .

    ID              reduce using rule 14 (functype -> VOID .)


state 21

    (15) functype -> typing .

    ID              reduce using rule 15 (functype -> typing .)


state 22

    (5) vars -> typing COLON . neuralinsertvar varsarr varsmul vars
    (7) neuralinsertvar -> . ID

    ID              shift and go to state 26

    neuralinsertvar                shift and go to state 25

state 23

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR . RIGHTPAR LEFTBR statutes RIGHTBR

    RIGHTPAR        shift and go to state 27


state 24

    (12) modules -> FUNCTION functype ID . funcparam
    (16) funcparam -> . LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR modules

    LEFTPAR         shift and go to state 29

    funcparam                      shift and go to state 28

state 25

    (5) vars -> typing COLON neuralinsertvar . varsarr varsmul vars
    (8) varsarr -> . LEFTSQR CTEINT RIGHTSQR
    (9) varsarr -> . empty
    (90) empty -> .

    LEFTSQR         shift and go to state 31
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    varsarr                        shift and go to state 30
    empty                          shift and go to state 32

state 26

    (7) neuralinsertvar -> ID .

    LEFTSQR         reduce using rule 7 (neuralinsertvar -> ID .)
    COMMA           reduce using rule 7 (neuralinsertvar -> ID .)
    SEMICOLON       reduce using rule 7 (neuralinsertvar -> ID .)


state 27

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 33


state 28

    (12) modules -> FUNCTION functype ID funcparam .

    MAIN            reduce using rule 12 (modules -> FUNCTION functype ID funcparam .)


state 29

    (16) funcparam -> LEFTPAR . parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR modules
    (20) parameters -> . typing COLON ID idarray mulparams
    (21) parameters -> . empty
    (17) typing -> . INT
    (18) typing -> . FLOAT
    (19) typing -> . CHAR
    (90) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 90 (empty -> .)

    parameters                     shift and go to state 34
    typing                         shift and go to state 35
    empty                          shift and go to state 36

state 30

    (5) vars -> typing COLON neuralinsertvar varsarr . varsmul vars
    (10) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (11) varsmul -> . SEMICOLON

    COMMA           shift and go to state 38
    SEMICOLON       shift and go to state 39

    varsmul                        shift and go to state 37

state 31

    (8) varsarr -> LEFTSQR . CTEINT RIGHTSQR

    CTEINT          shift and go to state 40


state 32

    (9) varsarr -> empty .

    COMMA           reduce using rule 9 (varsarr -> empty .)
    SEMICOLON       reduce using rule 9 (varsarr -> empty .)


state 33

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR . statutes RIGHTBR
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (90) empty -> .
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    RIGHTBR         reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    statutes                       shift and go to state 42
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    empty                          shift and go to state 60
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 34

    (16) funcparam -> LEFTPAR parameters . RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR modules

    RIGHTPAR        shift and go to state 69


state 35

    (20) parameters -> typing . COLON ID idarray mulparams

    COLON           shift and go to state 70


state 36

    (21) parameters -> empty .

    RIGHTPAR        reduce using rule 21 (parameters -> empty .)


state 37

    (5) vars -> typing COLON neuralinsertvar varsarr varsmul . vars
    (5) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (6) vars -> . empty
    (17) typing -> . INT
    (18) typing -> . FLOAT
    (19) typing -> . CHAR
    (90) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 90 (empty -> .)
    MAIN            reduce using rule 90 (empty -> .)
    LEFTBR          reduce using rule 90 (empty -> .)

    typing                         shift and go to state 13
    vars                           shift and go to state 71
    empty                          shift and go to state 14

state 38

    (10) varsmul -> COMMA . neuralinsertvar varsarr varsmul
    (7) neuralinsertvar -> . ID

    ID              shift and go to state 26

    neuralinsertvar                shift and go to state 72

state 39

    (11) varsmul -> SEMICOLON .

    INT             reduce using rule 11 (varsmul -> SEMICOLON .)
    FLOAT           reduce using rule 11 (varsmul -> SEMICOLON .)
    CHAR            reduce using rule 11 (varsmul -> SEMICOLON .)
    FUNCTION        reduce using rule 11 (varsmul -> SEMICOLON .)
    MAIN            reduce using rule 11 (varsmul -> SEMICOLON .)
    LEFTBR          reduce using rule 11 (varsmul -> SEMICOLON .)


state 40

    (8) varsarr -> LEFTSQR CTEINT . RIGHTSQR

    RIGHTSQR        shift and go to state 73


state 41

    (78) finexp -> LEFTPAR . exp RIGHTPAR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 74
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 42

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 76


state 43

    (24) statutes -> assign . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    assign                         shift and go to state 43
    statutesaux                    shift and go to state 77
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 44

    (25) statutes -> reading . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    reading                        shift and go to state 44
    statutesaux                    shift and go to state 80
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 45

    (26) statutes -> writing . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    writing                        shift and go to state 45
    statutesaux                    shift and go to state 81
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 46

    (27) statutes -> returning . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    returning                      shift and go to state 46
    statutesaux                    shift and go to state 82
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 47

    (28) statutes -> ifing . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    ifing                          shift and go to state 47
    statutesaux                    shift and go to state 83
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 48

    (29) statutes -> whiling . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    whiling                        shift and go to state 48
    statutesaux                    shift and go to state 84
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 49

    (30) statutes -> foring . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    foring                         shift and go to state 49
    statutesaux                    shift and go to state 85
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 50

    (31) statutes -> exp . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    exp                            shift and go to state 50
    statutesaux                    shift and go to state 86
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 51

    (32) statutes -> specialfunc . statutesaux
    (33) statutesaux -> . statutes
    (34) statutesaux -> . empty
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (90) empty -> .
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 90 (empty -> .)
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    specialfunc                    shift and go to state 51
    statutesaux                    shift and go to state 87
    statutes                       shift and go to state 78
    empty                          shift and go to state 79
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 52

    (36) assign -> ID . idarray EQUAL exp SEMICOLON
    (83) cteexp -> ID . paramsexp
    (53) idarray -> . LEFTSQR exp RIGHTSQR
    (54) idarray -> . empty
    (84) paramsexp -> . LEFTPAR paramsexp2 RIGHTPAR
    (85) paramsexp -> . idarray
    (90) empty -> .

  ! shift/reduce conflict for LEFTPAR resolved as shift
    LEFTSQR         shift and go to state 90
    LEFTPAR         shift and go to state 92
    EQUAL           reduce using rule 90 (empty -> .)
    TIMES           reduce using rule 90 (empty -> .)
    DIVIDE          reduce using rule 90 (empty -> .)
    PLUS            reduce using rule 90 (empty -> .)
    REST            reduce using rule 90 (empty -> .)
    GREATER         reduce using rule 90 (empty -> .)
    GREATERAND      reduce using rule 90 (empty -> .)
    LESSER          reduce using rule 90 (empty -> .)
    LESSERAND       reduce using rule 90 (empty -> .)
    SAME            reduce using rule 90 (empty -> .)
    NOTSAME         reduce using rule 90 (empty -> .)
    NOT             reduce using rule 90 (empty -> .)
    AND             reduce using rule 90 (empty -> .)
    OR              reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)

  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]

    idarray                        shift and go to state 88
    paramsexp                      shift and go to state 89
    empty                          shift and go to state 91

state 53

    (44) reading -> READ . LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 93


state 54

    (37) writing -> WRITE . LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 94


state 55

    (47) returning -> RETURN . LEFTPAR exp RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 95


state 56

    (48) ifing -> IF . LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing

    LEFTPAR         shift and go to state 96


state 57

    (51) whiling -> WHILE . LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 97


state 58

    (52) foring -> FOR . ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR

    ID              shift and go to state 98


state 59

    (55) exp -> andexp . exp1
    (56) exp1 -> . OR exp
    (57) exp1 -> . empty
    (90) empty -> .

    OR              shift and go to state 100
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    LEFTPAR         reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)
    RIGHTSQR        reduce using rule 90 (empty -> .)
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)
    TO              reduce using rule 90 (empty -> .)
    DO              reduce using rule 90 (empty -> .)

    exp1                           shift and go to state 99
    empty                          shift and go to state 101

state 60

    (35) specialfunc -> empty .

    ID              reduce using rule 35 (specialfunc -> empty .)
    READ            reduce using rule 35 (specialfunc -> empty .)
    WRITE           reduce using rule 35 (specialfunc -> empty .)
    RETURN          reduce using rule 35 (specialfunc -> empty .)
    IF              reduce using rule 35 (specialfunc -> empty .)
    WHILE           reduce using rule 35 (specialfunc -> empty .)
    FOR             reduce using rule 35 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 35 (specialfunc -> empty .)
    CTEINT          reduce using rule 35 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 35 (specialfunc -> empty .)
    CTECHAR         reduce using rule 35 (specialfunc -> empty .)
    RIGHTBR         reduce using rule 35 (specialfunc -> empty .)


state 61

    (58) andexp -> boolexp . andexp1
    (59) andexp1 -> . AND andexp
    (60) andexp1 -> . empty
    (90) empty -> .

    AND             shift and go to state 103
    OR              reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    LEFTPAR         reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)
    RIGHTSQR        reduce using rule 90 (empty -> .)
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)
    TO              reduce using rule 90 (empty -> .)
    DO              reduce using rule 90 (empty -> .)

    andexp1                        shift and go to state 102
    empty                          shift and go to state 104

state 62

    (61) boolexp -> arithexp . boolexp1
    (62) boolexp1 -> . GREATER arithexp
    (63) boolexp1 -> . GREATERAND arithexp
    (64) boolexp1 -> . LESSER arithexp
    (65) boolexp1 -> . LESSERAND arithexp
    (66) boolexp1 -> . SAME arithexp
    (67) boolexp1 -> . NOTSAME arithexp
    (68) boolexp1 -> . NOT arithexp
    (69) boolexp1 -> . empty
    (90) empty -> .

    GREATER         shift and go to state 106
    GREATERAND      shift and go to state 107
    LESSER          shift and go to state 108
    LESSERAND       shift and go to state 109
    SAME            shift and go to state 110
    NOTSAME         shift and go to state 111
    NOT             shift and go to state 112
    AND             reduce using rule 90 (empty -> .)
    OR              reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    LEFTPAR         reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)
    RIGHTSQR        reduce using rule 90 (empty -> .)
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)
    TO              reduce using rule 90 (empty -> .)
    DO              reduce using rule 90 (empty -> .)

    boolexp1                       shift and go to state 105
    empty                          shift and go to state 113

state 63

    (70) arithexp -> geoexp . arithexp1
    (71) arithexp1 -> . PLUS arithexp
    (72) arithexp1 -> . REST arithexp
    (73) arithexp1 -> . empty
    (90) empty -> .

    PLUS            shift and go to state 115
    REST            shift and go to state 116
    GREATER         reduce using rule 90 (empty -> .)
    GREATERAND      reduce using rule 90 (empty -> .)
    LESSER          reduce using rule 90 (empty -> .)
    LESSERAND       reduce using rule 90 (empty -> .)
    SAME            reduce using rule 90 (empty -> .)
    NOTSAME         reduce using rule 90 (empty -> .)
    NOT             reduce using rule 90 (empty -> .)
    AND             reduce using rule 90 (empty -> .)
    OR              reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    LEFTPAR         reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)
    RIGHTSQR        reduce using rule 90 (empty -> .)
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)
    TO              reduce using rule 90 (empty -> .)
    DO              reduce using rule 90 (empty -> .)

    arithexp1                      shift and go to state 114
    empty                          shift and go to state 117

state 64

    (74) geoexp -> finexp . geoexp1
    (75) geoexp1 -> . TIMES geoexp
    (76) geoexp1 -> . DIVIDE geoexp
    (77) geoexp1 -> . empty
    (90) empty -> .

    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    PLUS            reduce using rule 90 (empty -> .)
    REST            reduce using rule 90 (empty -> .)
    GREATER         reduce using rule 90 (empty -> .)
    GREATERAND      reduce using rule 90 (empty -> .)
    LESSER          reduce using rule 90 (empty -> .)
    LESSERAND       reduce using rule 90 (empty -> .)
    SAME            reduce using rule 90 (empty -> .)
    NOTSAME         reduce using rule 90 (empty -> .)
    NOT             reduce using rule 90 (empty -> .)
    AND             reduce using rule 90 (empty -> .)
    OR              reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    LEFTPAR         reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)
    RIGHTSQR        reduce using rule 90 (empty -> .)
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)
    TO              reduce using rule 90 (empty -> .)
    DO              reduce using rule 90 (empty -> .)

    geoexp1                        shift and go to state 118
    empty                          shift and go to state 121

state 65

    (79) finexp -> cteexp .

    TIMES           reduce using rule 79 (finexp -> cteexp .)
    DIVIDE          reduce using rule 79 (finexp -> cteexp .)
    PLUS            reduce using rule 79 (finexp -> cteexp .)
    REST            reduce using rule 79 (finexp -> cteexp .)
    GREATER         reduce using rule 79 (finexp -> cteexp .)
    GREATERAND      reduce using rule 79 (finexp -> cteexp .)
    LESSER          reduce using rule 79 (finexp -> cteexp .)
    LESSERAND       reduce using rule 79 (finexp -> cteexp .)
    SAME            reduce using rule 79 (finexp -> cteexp .)
    NOTSAME         reduce using rule 79 (finexp -> cteexp .)
    NOT             reduce using rule 79 (finexp -> cteexp .)
    AND             reduce using rule 79 (finexp -> cteexp .)
    OR              reduce using rule 79 (finexp -> cteexp .)
    ID              reduce using rule 79 (finexp -> cteexp .)
    READ            reduce using rule 79 (finexp -> cteexp .)
    WRITE           reduce using rule 79 (finexp -> cteexp .)
    RETURN          reduce using rule 79 (finexp -> cteexp .)
    IF              reduce using rule 79 (finexp -> cteexp .)
    WHILE           reduce using rule 79 (finexp -> cteexp .)
    FOR             reduce using rule 79 (finexp -> cteexp .)
    LEFTPAR         reduce using rule 79 (finexp -> cteexp .)
    CTEINT          reduce using rule 79 (finexp -> cteexp .)
    CTEFLOAT        reduce using rule 79 (finexp -> cteexp .)
    CTECHAR         reduce using rule 79 (finexp -> cteexp .)
    RIGHTBR         reduce using rule 79 (finexp -> cteexp .)
    RIGHTPAR        reduce using rule 79 (finexp -> cteexp .)
    RIGHTSQR        reduce using rule 79 (finexp -> cteexp .)
    COMMA           reduce using rule 79 (finexp -> cteexp .)
    SEMICOLON       reduce using rule 79 (finexp -> cteexp .)
    TO              reduce using rule 79 (finexp -> cteexp .)
    DO              reduce using rule 79 (finexp -> cteexp .)


state 66

    (80) cteexp -> CTEINT .

    TIMES           reduce using rule 80 (cteexp -> CTEINT .)
    DIVIDE          reduce using rule 80 (cteexp -> CTEINT .)
    PLUS            reduce using rule 80 (cteexp -> CTEINT .)
    REST            reduce using rule 80 (cteexp -> CTEINT .)
    GREATER         reduce using rule 80 (cteexp -> CTEINT .)
    GREATERAND      reduce using rule 80 (cteexp -> CTEINT .)
    LESSER          reduce using rule 80 (cteexp -> CTEINT .)
    LESSERAND       reduce using rule 80 (cteexp -> CTEINT .)
    SAME            reduce using rule 80 (cteexp -> CTEINT .)
    NOTSAME         reduce using rule 80 (cteexp -> CTEINT .)
    NOT             reduce using rule 80 (cteexp -> CTEINT .)
    AND             reduce using rule 80 (cteexp -> CTEINT .)
    OR              reduce using rule 80 (cteexp -> CTEINT .)
    ID              reduce using rule 80 (cteexp -> CTEINT .)
    READ            reduce using rule 80 (cteexp -> CTEINT .)
    WRITE           reduce using rule 80 (cteexp -> CTEINT .)
    RETURN          reduce using rule 80 (cteexp -> CTEINT .)
    IF              reduce using rule 80 (cteexp -> CTEINT .)
    WHILE           reduce using rule 80 (cteexp -> CTEINT .)
    FOR             reduce using rule 80 (cteexp -> CTEINT .)
    LEFTPAR         reduce using rule 80 (cteexp -> CTEINT .)
    CTEINT          reduce using rule 80 (cteexp -> CTEINT .)
    CTEFLOAT        reduce using rule 80 (cteexp -> CTEINT .)
    CTECHAR         reduce using rule 80 (cteexp -> CTEINT .)
    RIGHTBR         reduce using rule 80 (cteexp -> CTEINT .)
    RIGHTPAR        reduce using rule 80 (cteexp -> CTEINT .)
    RIGHTSQR        reduce using rule 80 (cteexp -> CTEINT .)
    COMMA           reduce using rule 80 (cteexp -> CTEINT .)
    SEMICOLON       reduce using rule 80 (cteexp -> CTEINT .)
    TO              reduce using rule 80 (cteexp -> CTEINT .)
    DO              reduce using rule 80 (cteexp -> CTEINT .)


state 67

    (81) cteexp -> CTEFLOAT .

    TIMES           reduce using rule 81 (cteexp -> CTEFLOAT .)
    DIVIDE          reduce using rule 81 (cteexp -> CTEFLOAT .)
    PLUS            reduce using rule 81 (cteexp -> CTEFLOAT .)
    REST            reduce using rule 81 (cteexp -> CTEFLOAT .)
    GREATER         reduce using rule 81 (cteexp -> CTEFLOAT .)
    GREATERAND      reduce using rule 81 (cteexp -> CTEFLOAT .)
    LESSER          reduce using rule 81 (cteexp -> CTEFLOAT .)
    LESSERAND       reduce using rule 81 (cteexp -> CTEFLOAT .)
    SAME            reduce using rule 81 (cteexp -> CTEFLOAT .)
    NOTSAME         reduce using rule 81 (cteexp -> CTEFLOAT .)
    NOT             reduce using rule 81 (cteexp -> CTEFLOAT .)
    AND             reduce using rule 81 (cteexp -> CTEFLOAT .)
    OR              reduce using rule 81 (cteexp -> CTEFLOAT .)
    ID              reduce using rule 81 (cteexp -> CTEFLOAT .)
    READ            reduce using rule 81 (cteexp -> CTEFLOAT .)
    WRITE           reduce using rule 81 (cteexp -> CTEFLOAT .)
    RETURN          reduce using rule 81 (cteexp -> CTEFLOAT .)
    IF              reduce using rule 81 (cteexp -> CTEFLOAT .)
    WHILE           reduce using rule 81 (cteexp -> CTEFLOAT .)
    FOR             reduce using rule 81 (cteexp -> CTEFLOAT .)
    LEFTPAR         reduce using rule 81 (cteexp -> CTEFLOAT .)
    CTEINT          reduce using rule 81 (cteexp -> CTEFLOAT .)
    CTEFLOAT        reduce using rule 81 (cteexp -> CTEFLOAT .)
    CTECHAR         reduce using rule 81 (cteexp -> CTEFLOAT .)
    RIGHTBR         reduce using rule 81 (cteexp -> CTEFLOAT .)
    RIGHTPAR        reduce using rule 81 (cteexp -> CTEFLOAT .)
    RIGHTSQR        reduce using rule 81 (cteexp -> CTEFLOAT .)
    COMMA           reduce using rule 81 (cteexp -> CTEFLOAT .)
    SEMICOLON       reduce using rule 81 (cteexp -> CTEFLOAT .)
    TO              reduce using rule 81 (cteexp -> CTEFLOAT .)
    DO              reduce using rule 81 (cteexp -> CTEFLOAT .)


state 68

    (82) cteexp -> CTECHAR .

    TIMES           reduce using rule 82 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 82 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 82 (cteexp -> CTECHAR .)
    REST            reduce using rule 82 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 82 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 82 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 82 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 82 (cteexp -> CTECHAR .)
    SAME            reduce using rule 82 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 82 (cteexp -> CTECHAR .)
    NOT             reduce using rule 82 (cteexp -> CTECHAR .)
    AND             reduce using rule 82 (cteexp -> CTECHAR .)
    OR              reduce using rule 82 (cteexp -> CTECHAR .)
    ID              reduce using rule 82 (cteexp -> CTECHAR .)
    READ            reduce using rule 82 (cteexp -> CTECHAR .)
    WRITE           reduce using rule 82 (cteexp -> CTECHAR .)
    RETURN          reduce using rule 82 (cteexp -> CTECHAR .)
    IF              reduce using rule 82 (cteexp -> CTECHAR .)
    WHILE           reduce using rule 82 (cteexp -> CTECHAR .)
    FOR             reduce using rule 82 (cteexp -> CTECHAR .)
    LEFTPAR         reduce using rule 82 (cteexp -> CTECHAR .)
    CTEINT          reduce using rule 82 (cteexp -> CTECHAR .)
    CTEFLOAT        reduce using rule 82 (cteexp -> CTECHAR .)
    CTECHAR         reduce using rule 82 (cteexp -> CTECHAR .)
    RIGHTBR         reduce using rule 82 (cteexp -> CTECHAR .)
    RIGHTPAR        reduce using rule 82 (cteexp -> CTECHAR .)
    RIGHTSQR        reduce using rule 82 (cteexp -> CTECHAR .)
    COMMA           reduce using rule 82 (cteexp -> CTECHAR .)
    SEMICOLON       reduce using rule 82 (cteexp -> CTECHAR .)
    TO              reduce using rule 82 (cteexp -> CTECHAR .)
    DO              reduce using rule 82 (cteexp -> CTECHAR .)


state 69

    (16) funcparam -> LEFTPAR parameters RIGHTPAR . SEMICOLON varsgl LEFTBR statutes RIGHTBR modules

    SEMICOLON       shift and go to state 122


state 70

    (20) parameters -> typing COLON . ID idarray mulparams

    ID              shift and go to state 123


state 71

    (5) vars -> typing COLON neuralinsertvar varsarr varsmul vars .

    FUNCTION        reduce using rule 5 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    MAIN            reduce using rule 5 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    LEFTBR          reduce using rule 5 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)


state 72

    (10) varsmul -> COMMA neuralinsertvar . varsarr varsmul
    (8) varsarr -> . LEFTSQR CTEINT RIGHTSQR
    (9) varsarr -> . empty
    (90) empty -> .

    LEFTSQR         shift and go to state 31
    COMMA           reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)

    varsarr                        shift and go to state 124
    empty                          shift and go to state 32

state 73

    (8) varsarr -> LEFTSQR CTEINT RIGHTSQR .

    COMMA           reduce using rule 8 (varsarr -> LEFTSQR CTEINT RIGHTSQR .)
    SEMICOLON       reduce using rule 8 (varsarr -> LEFTSQR CTEINT RIGHTSQR .)


state 74

    (78) finexp -> LEFTPAR exp . RIGHTPAR

    RIGHTPAR        shift and go to state 125


state 75

    (83) cteexp -> ID . paramsexp
    (84) paramsexp -> . LEFTPAR paramsexp2 RIGHTPAR
    (85) paramsexp -> . idarray
    (53) idarray -> . LEFTSQR exp RIGHTSQR
    (54) idarray -> . empty
    (90) empty -> .

  ! shift/reduce conflict for LEFTPAR resolved as shift
    LEFTPAR         shift and go to state 92
    LEFTSQR         shift and go to state 90
    TIMES           reduce using rule 90 (empty -> .)
    DIVIDE          reduce using rule 90 (empty -> .)
    PLUS            reduce using rule 90 (empty -> .)
    REST            reduce using rule 90 (empty -> .)
    GREATER         reduce using rule 90 (empty -> .)
    GREATERAND      reduce using rule 90 (empty -> .)
    LESSER          reduce using rule 90 (empty -> .)
    LESSERAND       reduce using rule 90 (empty -> .)
    SAME            reduce using rule 90 (empty -> .)
    NOTSAME         reduce using rule 90 (empty -> .)
    NOT             reduce using rule 90 (empty -> .)
    AND             reduce using rule 90 (empty -> .)
    OR              reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)
    RIGHTSQR        reduce using rule 90 (empty -> .)
    COMMA           reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)
    SEMICOLON       reduce using rule 90 (empty -> .)
    TO              reduce using rule 90 (empty -> .)
    DO              reduce using rule 90 (empty -> .)

  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]

    paramsexp                      shift and go to state 89
    idarray                        shift and go to state 126
    empty                          shift and go to state 91

state 76

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR .

    $end            reduce using rule 1 (program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR .)


state 77

    (24) statutes -> assign statutesaux .

    RIGHTBR         reduce using rule 24 (statutes -> assign statutesaux .)


state 78

    (33) statutesaux -> statutes .

    RIGHTBR         reduce using rule 33 (statutesaux -> statutes .)


state 79

    (34) statutesaux -> empty .
    (35) specialfunc -> empty .

  ! reduce/reduce conflict for RIGHTBR resolved using rule 34 (statutesaux -> empty .)
    RIGHTBR         reduce using rule 34 (statutesaux -> empty .)
    ID              reduce using rule 35 (specialfunc -> empty .)
    READ            reduce using rule 35 (specialfunc -> empty .)
    WRITE           reduce using rule 35 (specialfunc -> empty .)
    RETURN          reduce using rule 35 (specialfunc -> empty .)
    IF              reduce using rule 35 (specialfunc -> empty .)
    WHILE           reduce using rule 35 (specialfunc -> empty .)
    FOR             reduce using rule 35 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 35 (specialfunc -> empty .)
    CTEINT          reduce using rule 35 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 35 (specialfunc -> empty .)
    CTECHAR         reduce using rule 35 (specialfunc -> empty .)

  ! RIGHTBR         [ reduce using rule 35 (specialfunc -> empty .) ]


state 80

    (25) statutes -> reading statutesaux .

    RIGHTBR         reduce using rule 25 (statutes -> reading statutesaux .)


state 81

    (26) statutes -> writing statutesaux .

    RIGHTBR         reduce using rule 26 (statutes -> writing statutesaux .)


state 82

    (27) statutes -> returning statutesaux .

    RIGHTBR         reduce using rule 27 (statutes -> returning statutesaux .)


state 83

    (28) statutes -> ifing statutesaux .

    RIGHTBR         reduce using rule 28 (statutes -> ifing statutesaux .)


state 84

    (29) statutes -> whiling statutesaux .

    RIGHTBR         reduce using rule 29 (statutes -> whiling statutesaux .)


state 85

    (30) statutes -> foring statutesaux .

    RIGHTBR         reduce using rule 30 (statutes -> foring statutesaux .)


state 86

    (31) statutes -> exp statutesaux .

    RIGHTBR         reduce using rule 31 (statutes -> exp statutesaux .)


state 87

    (32) statutes -> specialfunc statutesaux .

    RIGHTBR         reduce using rule 32 (statutes -> specialfunc statutesaux .)


state 88

    (36) assign -> ID idarray . EQUAL exp SEMICOLON
    (85) paramsexp -> idarray .

    EQUAL           shift and go to state 127
    TIMES           reduce using rule 85 (paramsexp -> idarray .)
    DIVIDE          reduce using rule 85 (paramsexp -> idarray .)
    PLUS            reduce using rule 85 (paramsexp -> idarray .)
    REST            reduce using rule 85 (paramsexp -> idarray .)
    GREATER         reduce using rule 85 (paramsexp -> idarray .)
    GREATERAND      reduce using rule 85 (paramsexp -> idarray .)
    LESSER          reduce using rule 85 (paramsexp -> idarray .)
    LESSERAND       reduce using rule 85 (paramsexp -> idarray .)
    SAME            reduce using rule 85 (paramsexp -> idarray .)
    NOTSAME         reduce using rule 85 (paramsexp -> idarray .)
    NOT             reduce using rule 85 (paramsexp -> idarray .)
    AND             reduce using rule 85 (paramsexp -> idarray .)
    OR              reduce using rule 85 (paramsexp -> idarray .)
    ID              reduce using rule 85 (paramsexp -> idarray .)
    READ            reduce using rule 85 (paramsexp -> idarray .)
    WRITE           reduce using rule 85 (paramsexp -> idarray .)
    RETURN          reduce using rule 85 (paramsexp -> idarray .)
    IF              reduce using rule 85 (paramsexp -> idarray .)
    WHILE           reduce using rule 85 (paramsexp -> idarray .)
    FOR             reduce using rule 85 (paramsexp -> idarray .)
    LEFTPAR         reduce using rule 85 (paramsexp -> idarray .)
    CTEINT          reduce using rule 85 (paramsexp -> idarray .)
    CTEFLOAT        reduce using rule 85 (paramsexp -> idarray .)
    CTECHAR         reduce using rule 85 (paramsexp -> idarray .)
    RIGHTBR         reduce using rule 85 (paramsexp -> idarray .)


state 89

    (83) cteexp -> ID paramsexp .

    TIMES           reduce using rule 83 (cteexp -> ID paramsexp .)
    DIVIDE          reduce using rule 83 (cteexp -> ID paramsexp .)
    PLUS            reduce using rule 83 (cteexp -> ID paramsexp .)
    REST            reduce using rule 83 (cteexp -> ID paramsexp .)
    GREATER         reduce using rule 83 (cteexp -> ID paramsexp .)
    GREATERAND      reduce using rule 83 (cteexp -> ID paramsexp .)
    LESSER          reduce using rule 83 (cteexp -> ID paramsexp .)
    LESSERAND       reduce using rule 83 (cteexp -> ID paramsexp .)
    SAME            reduce using rule 83 (cteexp -> ID paramsexp .)
    NOTSAME         reduce using rule 83 (cteexp -> ID paramsexp .)
    NOT             reduce using rule 83 (cteexp -> ID paramsexp .)
    AND             reduce using rule 83 (cteexp -> ID paramsexp .)
    OR              reduce using rule 83 (cteexp -> ID paramsexp .)
    ID              reduce using rule 83 (cteexp -> ID paramsexp .)
    READ            reduce using rule 83 (cteexp -> ID paramsexp .)
    WRITE           reduce using rule 83 (cteexp -> ID paramsexp .)
    RETURN          reduce using rule 83 (cteexp -> ID paramsexp .)
    IF              reduce using rule 83 (cteexp -> ID paramsexp .)
    WHILE           reduce using rule 83 (cteexp -> ID paramsexp .)
    FOR             reduce using rule 83 (cteexp -> ID paramsexp .)
    LEFTPAR         reduce using rule 83 (cteexp -> ID paramsexp .)
    CTEINT          reduce using rule 83 (cteexp -> ID paramsexp .)
    CTEFLOAT        reduce using rule 83 (cteexp -> ID paramsexp .)
    CTECHAR         reduce using rule 83 (cteexp -> ID paramsexp .)
    RIGHTBR         reduce using rule 83 (cteexp -> ID paramsexp .)
    RIGHTPAR        reduce using rule 83 (cteexp -> ID paramsexp .)
    RIGHTSQR        reduce using rule 83 (cteexp -> ID paramsexp .)
    COMMA           reduce using rule 83 (cteexp -> ID paramsexp .)
    SEMICOLON       reduce using rule 83 (cteexp -> ID paramsexp .)
    TO              reduce using rule 83 (cteexp -> ID paramsexp .)
    DO              reduce using rule 83 (cteexp -> ID paramsexp .)


state 90

    (53) idarray -> LEFTSQR . exp RIGHTSQR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 128
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 91

    (54) idarray -> empty .

    EQUAL           reduce using rule 54 (idarray -> empty .)
    TIMES           reduce using rule 54 (idarray -> empty .)
    DIVIDE          reduce using rule 54 (idarray -> empty .)
    PLUS            reduce using rule 54 (idarray -> empty .)
    REST            reduce using rule 54 (idarray -> empty .)
    GREATER         reduce using rule 54 (idarray -> empty .)
    GREATERAND      reduce using rule 54 (idarray -> empty .)
    LESSER          reduce using rule 54 (idarray -> empty .)
    LESSERAND       reduce using rule 54 (idarray -> empty .)
    SAME            reduce using rule 54 (idarray -> empty .)
    NOTSAME         reduce using rule 54 (idarray -> empty .)
    NOT             reduce using rule 54 (idarray -> empty .)
    AND             reduce using rule 54 (idarray -> empty .)
    OR              reduce using rule 54 (idarray -> empty .)
    ID              reduce using rule 54 (idarray -> empty .)
    READ            reduce using rule 54 (idarray -> empty .)
    WRITE           reduce using rule 54 (idarray -> empty .)
    RETURN          reduce using rule 54 (idarray -> empty .)
    IF              reduce using rule 54 (idarray -> empty .)
    WHILE           reduce using rule 54 (idarray -> empty .)
    FOR             reduce using rule 54 (idarray -> empty .)
    LEFTPAR         reduce using rule 54 (idarray -> empty .)
    CTEINT          reduce using rule 54 (idarray -> empty .)
    CTEFLOAT        reduce using rule 54 (idarray -> empty .)
    CTECHAR         reduce using rule 54 (idarray -> empty .)
    RIGHTBR         reduce using rule 54 (idarray -> empty .)
    RIGHTPAR        reduce using rule 54 (idarray -> empty .)
    RIGHTSQR        reduce using rule 54 (idarray -> empty .)
    COMMA           reduce using rule 54 (idarray -> empty .)
    SEMICOLON       reduce using rule 54 (idarray -> empty .)
    TO              reduce using rule 54 (idarray -> empty .)
    DO              reduce using rule 54 (idarray -> empty .)


state 92

    (84) paramsexp -> LEFTPAR . paramsexp2 RIGHTPAR
    (86) paramsexp2 -> . exp auxparamsexp2
    (87) paramsexp2 -> . empty
    (55) exp -> . andexp exp1
    (90) empty -> .
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    RIGHTPAR        reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    paramsexp2                     shift and go to state 129
    exp                            shift and go to state 130
    empty                          shift and go to state 131
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 93

    (44) reading -> READ LEFTPAR . ID idarray mulread RIGHTPAR SEMICOLON

    ID              shift and go to state 132


state 94

    (37) writing -> WRITE LEFTPAR . auxwrite mulwrite RIGHTPAR SEMICOLON
    (38) auxwrite -> . writetyping
    (39) auxwrite -> . exp
    (40) writetyping -> . STRING
    (41) writetyping -> . CTECHAR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    STRING          shift and go to state 136
    CTECHAR         shift and go to state 137
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    ID              shift and go to state 75

    auxwrite                       shift and go to state 133
    writetyping                    shift and go to state 134
    exp                            shift and go to state 135
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 95

    (47) returning -> RETURN LEFTPAR . exp RIGHTPAR SEMICOLON
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 138
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 96

    (48) ifing -> IF LEFTPAR . exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 139
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 97

    (51) whiling -> WHILE LEFTPAR . exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 140
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 98

    (52) foring -> FOR ID . idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (53) idarray -> . LEFTSQR exp RIGHTSQR
    (54) idarray -> . empty
    (90) empty -> .

    LEFTSQR         shift and go to state 90
    EQUAL           reduce using rule 90 (empty -> .)

    idarray                        shift and go to state 141
    empty                          shift and go to state 91

state 99

    (55) exp -> andexp exp1 .

    ID              reduce using rule 55 (exp -> andexp exp1 .)
    READ            reduce using rule 55 (exp -> andexp exp1 .)
    WRITE           reduce using rule 55 (exp -> andexp exp1 .)
    RETURN          reduce using rule 55 (exp -> andexp exp1 .)
    IF              reduce using rule 55 (exp -> andexp exp1 .)
    WHILE           reduce using rule 55 (exp -> andexp exp1 .)
    FOR             reduce using rule 55 (exp -> andexp exp1 .)
    LEFTPAR         reduce using rule 55 (exp -> andexp exp1 .)
    CTEINT          reduce using rule 55 (exp -> andexp exp1 .)
    CTEFLOAT        reduce using rule 55 (exp -> andexp exp1 .)
    CTECHAR         reduce using rule 55 (exp -> andexp exp1 .)
    RIGHTBR         reduce using rule 55 (exp -> andexp exp1 .)
    RIGHTPAR        reduce using rule 55 (exp -> andexp exp1 .)
    RIGHTSQR        reduce using rule 55 (exp -> andexp exp1 .)
    COMMA           reduce using rule 55 (exp -> andexp exp1 .)
    SEMICOLON       reduce using rule 55 (exp -> andexp exp1 .)
    TO              reduce using rule 55 (exp -> andexp exp1 .)
    DO              reduce using rule 55 (exp -> andexp exp1 .)


state 100

    (56) exp1 -> OR . exp
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 142
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 101

    (57) exp1 -> empty .

    ID              reduce using rule 57 (exp1 -> empty .)
    READ            reduce using rule 57 (exp1 -> empty .)
    WRITE           reduce using rule 57 (exp1 -> empty .)
    RETURN          reduce using rule 57 (exp1 -> empty .)
    IF              reduce using rule 57 (exp1 -> empty .)
    WHILE           reduce using rule 57 (exp1 -> empty .)
    FOR             reduce using rule 57 (exp1 -> empty .)
    LEFTPAR         reduce using rule 57 (exp1 -> empty .)
    CTEINT          reduce using rule 57 (exp1 -> empty .)
    CTEFLOAT        reduce using rule 57 (exp1 -> empty .)
    CTECHAR         reduce using rule 57 (exp1 -> empty .)
    RIGHTBR         reduce using rule 57 (exp1 -> empty .)
    RIGHTPAR        reduce using rule 57 (exp1 -> empty .)
    RIGHTSQR        reduce using rule 57 (exp1 -> empty .)
    COMMA           reduce using rule 57 (exp1 -> empty .)
    SEMICOLON       reduce using rule 57 (exp1 -> empty .)
    TO              reduce using rule 57 (exp1 -> empty .)
    DO              reduce using rule 57 (exp1 -> empty .)


state 102

    (58) andexp -> boolexp andexp1 .

    OR              reduce using rule 58 (andexp -> boolexp andexp1 .)
    ID              reduce using rule 58 (andexp -> boolexp andexp1 .)
    READ            reduce using rule 58 (andexp -> boolexp andexp1 .)
    WRITE           reduce using rule 58 (andexp -> boolexp andexp1 .)
    RETURN          reduce using rule 58 (andexp -> boolexp andexp1 .)
    IF              reduce using rule 58 (andexp -> boolexp andexp1 .)
    WHILE           reduce using rule 58 (andexp -> boolexp andexp1 .)
    FOR             reduce using rule 58 (andexp -> boolexp andexp1 .)
    LEFTPAR         reduce using rule 58 (andexp -> boolexp andexp1 .)
    CTEINT          reduce using rule 58 (andexp -> boolexp andexp1 .)
    CTEFLOAT        reduce using rule 58 (andexp -> boolexp andexp1 .)
    CTECHAR         reduce using rule 58 (andexp -> boolexp andexp1 .)
    RIGHTBR         reduce using rule 58 (andexp -> boolexp andexp1 .)
    RIGHTPAR        reduce using rule 58 (andexp -> boolexp andexp1 .)
    RIGHTSQR        reduce using rule 58 (andexp -> boolexp andexp1 .)
    COMMA           reduce using rule 58 (andexp -> boolexp andexp1 .)
    SEMICOLON       reduce using rule 58 (andexp -> boolexp andexp1 .)
    TO              reduce using rule 58 (andexp -> boolexp andexp1 .)
    DO              reduce using rule 58 (andexp -> boolexp andexp1 .)


state 103

    (59) andexp1 -> AND . andexp
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    andexp                         shift and go to state 143
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 104

    (60) andexp1 -> empty .

    OR              reduce using rule 60 (andexp1 -> empty .)
    ID              reduce using rule 60 (andexp1 -> empty .)
    READ            reduce using rule 60 (andexp1 -> empty .)
    WRITE           reduce using rule 60 (andexp1 -> empty .)
    RETURN          reduce using rule 60 (andexp1 -> empty .)
    IF              reduce using rule 60 (andexp1 -> empty .)
    WHILE           reduce using rule 60 (andexp1 -> empty .)
    FOR             reduce using rule 60 (andexp1 -> empty .)
    LEFTPAR         reduce using rule 60 (andexp1 -> empty .)
    CTEINT          reduce using rule 60 (andexp1 -> empty .)
    CTEFLOAT        reduce using rule 60 (andexp1 -> empty .)
    CTECHAR         reduce using rule 60 (andexp1 -> empty .)
    RIGHTBR         reduce using rule 60 (andexp1 -> empty .)
    RIGHTPAR        reduce using rule 60 (andexp1 -> empty .)
    RIGHTSQR        reduce using rule 60 (andexp1 -> empty .)
    COMMA           reduce using rule 60 (andexp1 -> empty .)
    SEMICOLON       reduce using rule 60 (andexp1 -> empty .)
    TO              reduce using rule 60 (andexp1 -> empty .)
    DO              reduce using rule 60 (andexp1 -> empty .)


state 105

    (61) boolexp -> arithexp boolexp1 .

    AND             reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    OR              reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    ID              reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    READ            reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    WRITE           reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    RETURN          reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    IF              reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    WHILE           reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    FOR             reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    LEFTPAR         reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    CTEINT          reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    CTEFLOAT        reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    CTECHAR         reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    RIGHTBR         reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    RIGHTPAR        reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    RIGHTSQR        reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    COMMA           reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    SEMICOLON       reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    TO              reduce using rule 61 (boolexp -> arithexp boolexp1 .)
    DO              reduce using rule 61 (boolexp -> arithexp boolexp1 .)


state 106

    (62) boolexp1 -> GREATER . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 144
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 107

    (63) boolexp1 -> GREATERAND . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 145
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 108

    (64) boolexp1 -> LESSER . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 146
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 109

    (65) boolexp1 -> LESSERAND . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 147
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 110

    (66) boolexp1 -> SAME . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 148
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 111

    (67) boolexp1 -> NOTSAME . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 149
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 112

    (68) boolexp1 -> NOT . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 150
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 113

    (69) boolexp1 -> empty .

    AND             reduce using rule 69 (boolexp1 -> empty .)
    OR              reduce using rule 69 (boolexp1 -> empty .)
    ID              reduce using rule 69 (boolexp1 -> empty .)
    READ            reduce using rule 69 (boolexp1 -> empty .)
    WRITE           reduce using rule 69 (boolexp1 -> empty .)
    RETURN          reduce using rule 69 (boolexp1 -> empty .)
    IF              reduce using rule 69 (boolexp1 -> empty .)
    WHILE           reduce using rule 69 (boolexp1 -> empty .)
    FOR             reduce using rule 69 (boolexp1 -> empty .)
    LEFTPAR         reduce using rule 69 (boolexp1 -> empty .)
    CTEINT          reduce using rule 69 (boolexp1 -> empty .)
    CTEFLOAT        reduce using rule 69 (boolexp1 -> empty .)
    CTECHAR         reduce using rule 69 (boolexp1 -> empty .)
    RIGHTBR         reduce using rule 69 (boolexp1 -> empty .)
    RIGHTPAR        reduce using rule 69 (boolexp1 -> empty .)
    RIGHTSQR        reduce using rule 69 (boolexp1 -> empty .)
    COMMA           reduce using rule 69 (boolexp1 -> empty .)
    SEMICOLON       reduce using rule 69 (boolexp1 -> empty .)
    TO              reduce using rule 69 (boolexp1 -> empty .)
    DO              reduce using rule 69 (boolexp1 -> empty .)


state 114

    (70) arithexp -> geoexp arithexp1 .

    GREATER         reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    GREATERAND      reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    LESSER          reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    LESSERAND       reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    SAME            reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    NOTSAME         reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    NOT             reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    AND             reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    OR              reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    ID              reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    READ            reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    WRITE           reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    RETURN          reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    IF              reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    WHILE           reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    FOR             reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    LEFTPAR         reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    CTEINT          reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    CTEFLOAT        reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    CTECHAR         reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    RIGHTBR         reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    RIGHTPAR        reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    RIGHTSQR        reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    COMMA           reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    SEMICOLON       reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    TO              reduce using rule 70 (arithexp -> geoexp arithexp1 .)
    DO              reduce using rule 70 (arithexp -> geoexp arithexp1 .)


state 115

    (71) arithexp1 -> PLUS . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 151
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 116

    (72) arithexp1 -> REST . arithexp
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    arithexp                       shift and go to state 152
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 117

    (73) arithexp1 -> empty .

    GREATER         reduce using rule 73 (arithexp1 -> empty .)
    GREATERAND      reduce using rule 73 (arithexp1 -> empty .)
    LESSER          reduce using rule 73 (arithexp1 -> empty .)
    LESSERAND       reduce using rule 73 (arithexp1 -> empty .)
    SAME            reduce using rule 73 (arithexp1 -> empty .)
    NOTSAME         reduce using rule 73 (arithexp1 -> empty .)
    NOT             reduce using rule 73 (arithexp1 -> empty .)
    AND             reduce using rule 73 (arithexp1 -> empty .)
    OR              reduce using rule 73 (arithexp1 -> empty .)
    ID              reduce using rule 73 (arithexp1 -> empty .)
    READ            reduce using rule 73 (arithexp1 -> empty .)
    WRITE           reduce using rule 73 (arithexp1 -> empty .)
    RETURN          reduce using rule 73 (arithexp1 -> empty .)
    IF              reduce using rule 73 (arithexp1 -> empty .)
    WHILE           reduce using rule 73 (arithexp1 -> empty .)
    FOR             reduce using rule 73 (arithexp1 -> empty .)
    LEFTPAR         reduce using rule 73 (arithexp1 -> empty .)
    CTEINT          reduce using rule 73 (arithexp1 -> empty .)
    CTEFLOAT        reduce using rule 73 (arithexp1 -> empty .)
    CTECHAR         reduce using rule 73 (arithexp1 -> empty .)
    RIGHTBR         reduce using rule 73 (arithexp1 -> empty .)
    RIGHTPAR        reduce using rule 73 (arithexp1 -> empty .)
    RIGHTSQR        reduce using rule 73 (arithexp1 -> empty .)
    COMMA           reduce using rule 73 (arithexp1 -> empty .)
    SEMICOLON       reduce using rule 73 (arithexp1 -> empty .)
    TO              reduce using rule 73 (arithexp1 -> empty .)
    DO              reduce using rule 73 (arithexp1 -> empty .)


state 118

    (74) geoexp -> finexp geoexp1 .

    PLUS            reduce using rule 74 (geoexp -> finexp geoexp1 .)
    REST            reduce using rule 74 (geoexp -> finexp geoexp1 .)
    GREATER         reduce using rule 74 (geoexp -> finexp geoexp1 .)
    GREATERAND      reduce using rule 74 (geoexp -> finexp geoexp1 .)
    LESSER          reduce using rule 74 (geoexp -> finexp geoexp1 .)
    LESSERAND       reduce using rule 74 (geoexp -> finexp geoexp1 .)
    SAME            reduce using rule 74 (geoexp -> finexp geoexp1 .)
    NOTSAME         reduce using rule 74 (geoexp -> finexp geoexp1 .)
    NOT             reduce using rule 74 (geoexp -> finexp geoexp1 .)
    AND             reduce using rule 74 (geoexp -> finexp geoexp1 .)
    OR              reduce using rule 74 (geoexp -> finexp geoexp1 .)
    ID              reduce using rule 74 (geoexp -> finexp geoexp1 .)
    READ            reduce using rule 74 (geoexp -> finexp geoexp1 .)
    WRITE           reduce using rule 74 (geoexp -> finexp geoexp1 .)
    RETURN          reduce using rule 74 (geoexp -> finexp geoexp1 .)
    IF              reduce using rule 74 (geoexp -> finexp geoexp1 .)
    WHILE           reduce using rule 74 (geoexp -> finexp geoexp1 .)
    FOR             reduce using rule 74 (geoexp -> finexp geoexp1 .)
    LEFTPAR         reduce using rule 74 (geoexp -> finexp geoexp1 .)
    CTEINT          reduce using rule 74 (geoexp -> finexp geoexp1 .)
    CTEFLOAT        reduce using rule 74 (geoexp -> finexp geoexp1 .)
    CTECHAR         reduce using rule 74 (geoexp -> finexp geoexp1 .)
    RIGHTBR         reduce using rule 74 (geoexp -> finexp geoexp1 .)
    RIGHTPAR        reduce using rule 74 (geoexp -> finexp geoexp1 .)
    RIGHTSQR        reduce using rule 74 (geoexp -> finexp geoexp1 .)
    COMMA           reduce using rule 74 (geoexp -> finexp geoexp1 .)
    SEMICOLON       reduce using rule 74 (geoexp -> finexp geoexp1 .)
    TO              reduce using rule 74 (geoexp -> finexp geoexp1 .)
    DO              reduce using rule 74 (geoexp -> finexp geoexp1 .)


state 119

    (75) geoexp1 -> TIMES . geoexp
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    geoexp                         shift and go to state 153
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 120

    (76) geoexp1 -> DIVIDE . geoexp
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    geoexp                         shift and go to state 154
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 121

    (77) geoexp1 -> empty .

    PLUS            reduce using rule 77 (geoexp1 -> empty .)
    REST            reduce using rule 77 (geoexp1 -> empty .)
    GREATER         reduce using rule 77 (geoexp1 -> empty .)
    GREATERAND      reduce using rule 77 (geoexp1 -> empty .)
    LESSER          reduce using rule 77 (geoexp1 -> empty .)
    LESSERAND       reduce using rule 77 (geoexp1 -> empty .)
    SAME            reduce using rule 77 (geoexp1 -> empty .)
    NOTSAME         reduce using rule 77 (geoexp1 -> empty .)
    NOT             reduce using rule 77 (geoexp1 -> empty .)
    AND             reduce using rule 77 (geoexp1 -> empty .)
    OR              reduce using rule 77 (geoexp1 -> empty .)
    ID              reduce using rule 77 (geoexp1 -> empty .)
    READ            reduce using rule 77 (geoexp1 -> empty .)
    WRITE           reduce using rule 77 (geoexp1 -> empty .)
    RETURN          reduce using rule 77 (geoexp1 -> empty .)
    IF              reduce using rule 77 (geoexp1 -> empty .)
    WHILE           reduce using rule 77 (geoexp1 -> empty .)
    FOR             reduce using rule 77 (geoexp1 -> empty .)
    LEFTPAR         reduce using rule 77 (geoexp1 -> empty .)
    CTEINT          reduce using rule 77 (geoexp1 -> empty .)
    CTEFLOAT        reduce using rule 77 (geoexp1 -> empty .)
    CTECHAR         reduce using rule 77 (geoexp1 -> empty .)
    RIGHTBR         reduce using rule 77 (geoexp1 -> empty .)
    RIGHTPAR        reduce using rule 77 (geoexp1 -> empty .)
    RIGHTSQR        reduce using rule 77 (geoexp1 -> empty .)
    COMMA           reduce using rule 77 (geoexp1 -> empty .)
    SEMICOLON       reduce using rule 77 (geoexp1 -> empty .)
    TO              reduce using rule 77 (geoexp1 -> empty .)
    DO              reduce using rule 77 (geoexp1 -> empty .)


state 122

    (16) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON . varsgl LEFTBR statutes RIGHTBR modules
    (3) varsgl -> . VARS vars
    (4) varsgl -> . empty
    (90) empty -> .

    VARS            shift and go to state 7
    LEFTBR          reduce using rule 90 (empty -> .)

    varsgl                         shift and go to state 155
    empty                          shift and go to state 8

state 123

    (20) parameters -> typing COLON ID . idarray mulparams
    (53) idarray -> . LEFTSQR exp RIGHTSQR
    (54) idarray -> . empty
    (90) empty -> .

    LEFTSQR         shift and go to state 90
    COMMA           reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)

    idarray                        shift and go to state 156
    empty                          shift and go to state 91

state 124

    (10) varsmul -> COMMA neuralinsertvar varsarr . varsmul
    (10) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (11) varsmul -> . SEMICOLON

    COMMA           shift and go to state 38
    SEMICOLON       shift and go to state 39

    varsmul                        shift and go to state 157

state 125

    (78) finexp -> LEFTPAR exp RIGHTPAR .

    TIMES           reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    DIVIDE          reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    PLUS            reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    REST            reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    GREATER         reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    GREATERAND      reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    LESSER          reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    LESSERAND       reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    SAME            reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    NOTSAME         reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    NOT             reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    AND             reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    OR              reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    ID              reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    READ            reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    WRITE           reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    RETURN          reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    IF              reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    WHILE           reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    FOR             reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    LEFTPAR         reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    CTEINT          reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    CTEFLOAT        reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    CTECHAR         reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    RIGHTBR         reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    RIGHTPAR        reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    RIGHTSQR        reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    COMMA           reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    SEMICOLON       reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    TO              reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)
    DO              reduce using rule 78 (finexp -> LEFTPAR exp RIGHTPAR .)


state 126

    (85) paramsexp -> idarray .

    TIMES           reduce using rule 85 (paramsexp -> idarray .)
    DIVIDE          reduce using rule 85 (paramsexp -> idarray .)
    PLUS            reduce using rule 85 (paramsexp -> idarray .)
    REST            reduce using rule 85 (paramsexp -> idarray .)
    GREATER         reduce using rule 85 (paramsexp -> idarray .)
    GREATERAND      reduce using rule 85 (paramsexp -> idarray .)
    LESSER          reduce using rule 85 (paramsexp -> idarray .)
    LESSERAND       reduce using rule 85 (paramsexp -> idarray .)
    SAME            reduce using rule 85 (paramsexp -> idarray .)
    NOTSAME         reduce using rule 85 (paramsexp -> idarray .)
    NOT             reduce using rule 85 (paramsexp -> idarray .)
    AND             reduce using rule 85 (paramsexp -> idarray .)
    OR              reduce using rule 85 (paramsexp -> idarray .)
    RIGHTPAR        reduce using rule 85 (paramsexp -> idarray .)
    RIGHTSQR        reduce using rule 85 (paramsexp -> idarray .)
    COMMA           reduce using rule 85 (paramsexp -> idarray .)
    ID              reduce using rule 85 (paramsexp -> idarray .)
    READ            reduce using rule 85 (paramsexp -> idarray .)
    WRITE           reduce using rule 85 (paramsexp -> idarray .)
    RETURN          reduce using rule 85 (paramsexp -> idarray .)
    IF              reduce using rule 85 (paramsexp -> idarray .)
    WHILE           reduce using rule 85 (paramsexp -> idarray .)
    FOR             reduce using rule 85 (paramsexp -> idarray .)
    LEFTPAR         reduce using rule 85 (paramsexp -> idarray .)
    CTEINT          reduce using rule 85 (paramsexp -> idarray .)
    CTEFLOAT        reduce using rule 85 (paramsexp -> idarray .)
    CTECHAR         reduce using rule 85 (paramsexp -> idarray .)
    RIGHTBR         reduce using rule 85 (paramsexp -> idarray .)
    SEMICOLON       reduce using rule 85 (paramsexp -> idarray .)
    TO              reduce using rule 85 (paramsexp -> idarray .)
    DO              reduce using rule 85 (paramsexp -> idarray .)


state 127

    (36) assign -> ID idarray EQUAL . exp SEMICOLON
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 158
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 128

    (53) idarray -> LEFTSQR exp . RIGHTSQR

    RIGHTSQR        shift and go to state 159


state 129

    (84) paramsexp -> LEFTPAR paramsexp2 . RIGHTPAR

    RIGHTPAR        shift and go to state 160


state 130

    (86) paramsexp2 -> exp . auxparamsexp2
    (88) auxparamsexp2 -> . COMMA exp auxparamsexp2
    (89) auxparamsexp2 -> . empty
    (90) empty -> .

    COMMA           shift and go to state 162
    RIGHTPAR        reduce using rule 90 (empty -> .)

    auxparamsexp2                  shift and go to state 161
    empty                          shift and go to state 163

state 131

    (87) paramsexp2 -> empty .

    RIGHTPAR        reduce using rule 87 (paramsexp2 -> empty .)


state 132

    (44) reading -> READ LEFTPAR ID . idarray mulread RIGHTPAR SEMICOLON
    (53) idarray -> . LEFTSQR exp RIGHTSQR
    (54) idarray -> . empty
    (90) empty -> .

    LEFTSQR         shift and go to state 90
    COMMA           reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)

    idarray                        shift and go to state 164
    empty                          shift and go to state 91

state 133

    (37) writing -> WRITE LEFTPAR auxwrite . mulwrite RIGHTPAR SEMICOLON
    (42) mulwrite -> . COMMA auxwrite mulwrite
    (43) mulwrite -> . empty
    (90) empty -> .

    COMMA           shift and go to state 166
    RIGHTPAR        reduce using rule 90 (empty -> .)

    mulwrite                       shift and go to state 165
    empty                          shift and go to state 167

state 134

    (38) auxwrite -> writetyping .

    COMMA           reduce using rule 38 (auxwrite -> writetyping .)
    RIGHTPAR        reduce using rule 38 (auxwrite -> writetyping .)


state 135

    (39) auxwrite -> exp .

    COMMA           reduce using rule 39 (auxwrite -> exp .)
    RIGHTPAR        reduce using rule 39 (auxwrite -> exp .)


state 136

    (40) writetyping -> STRING .

    COMMA           reduce using rule 40 (writetyping -> STRING .)
    RIGHTPAR        reduce using rule 40 (writetyping -> STRING .)


state 137

    (41) writetyping -> CTECHAR .
    (82) cteexp -> CTECHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 41 (writetyping -> CTECHAR .)
  ! reduce/reduce conflict for RIGHTPAR resolved using rule 41 (writetyping -> CTECHAR .)
    COMMA           reduce using rule 41 (writetyping -> CTECHAR .)
    RIGHTPAR        reduce using rule 41 (writetyping -> CTECHAR .)
    TIMES           reduce using rule 82 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 82 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 82 (cteexp -> CTECHAR .)
    REST            reduce using rule 82 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 82 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 82 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 82 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 82 (cteexp -> CTECHAR .)
    SAME            reduce using rule 82 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 82 (cteexp -> CTECHAR .)
    NOT             reduce using rule 82 (cteexp -> CTECHAR .)
    AND             reduce using rule 82 (cteexp -> CTECHAR .)
    OR              reduce using rule 82 (cteexp -> CTECHAR .)

  ! COMMA           [ reduce using rule 82 (cteexp -> CTECHAR .) ]
  ! RIGHTPAR        [ reduce using rule 82 (cteexp -> CTECHAR .) ]


state 138

    (47) returning -> RETURN LEFTPAR exp . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 168


state 139

    (48) ifing -> IF LEFTPAR exp . RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing

    RIGHTPAR        shift and go to state 169


state 140

    (51) whiling -> WHILE LEFTPAR exp . RIGHTPAR DO LEFTBR statutes RIGHTBR

    RIGHTPAR        shift and go to state 170


state 141

    (52) foring -> FOR ID idarray . EQUAL exp TO exp DO LEFTBR statutes RIGHTBR

    EQUAL           shift and go to state 171


state 142

    (56) exp1 -> OR exp .

    ID              reduce using rule 56 (exp1 -> OR exp .)
    READ            reduce using rule 56 (exp1 -> OR exp .)
    WRITE           reduce using rule 56 (exp1 -> OR exp .)
    RETURN          reduce using rule 56 (exp1 -> OR exp .)
    IF              reduce using rule 56 (exp1 -> OR exp .)
    WHILE           reduce using rule 56 (exp1 -> OR exp .)
    FOR             reduce using rule 56 (exp1 -> OR exp .)
    LEFTPAR         reduce using rule 56 (exp1 -> OR exp .)
    CTEINT          reduce using rule 56 (exp1 -> OR exp .)
    CTEFLOAT        reduce using rule 56 (exp1 -> OR exp .)
    CTECHAR         reduce using rule 56 (exp1 -> OR exp .)
    RIGHTBR         reduce using rule 56 (exp1 -> OR exp .)
    RIGHTPAR        reduce using rule 56 (exp1 -> OR exp .)
    RIGHTSQR        reduce using rule 56 (exp1 -> OR exp .)
    COMMA           reduce using rule 56 (exp1 -> OR exp .)
    SEMICOLON       reduce using rule 56 (exp1 -> OR exp .)
    TO              reduce using rule 56 (exp1 -> OR exp .)
    DO              reduce using rule 56 (exp1 -> OR exp .)


state 143

    (59) andexp1 -> AND andexp .

    OR              reduce using rule 59 (andexp1 -> AND andexp .)
    ID              reduce using rule 59 (andexp1 -> AND andexp .)
    READ            reduce using rule 59 (andexp1 -> AND andexp .)
    WRITE           reduce using rule 59 (andexp1 -> AND andexp .)
    RETURN          reduce using rule 59 (andexp1 -> AND andexp .)
    IF              reduce using rule 59 (andexp1 -> AND andexp .)
    WHILE           reduce using rule 59 (andexp1 -> AND andexp .)
    FOR             reduce using rule 59 (andexp1 -> AND andexp .)
    LEFTPAR         reduce using rule 59 (andexp1 -> AND andexp .)
    CTEINT          reduce using rule 59 (andexp1 -> AND andexp .)
    CTEFLOAT        reduce using rule 59 (andexp1 -> AND andexp .)
    CTECHAR         reduce using rule 59 (andexp1 -> AND andexp .)
    RIGHTBR         reduce using rule 59 (andexp1 -> AND andexp .)
    RIGHTPAR        reduce using rule 59 (andexp1 -> AND andexp .)
    RIGHTSQR        reduce using rule 59 (andexp1 -> AND andexp .)
    COMMA           reduce using rule 59 (andexp1 -> AND andexp .)
    SEMICOLON       reduce using rule 59 (andexp1 -> AND andexp .)
    TO              reduce using rule 59 (andexp1 -> AND andexp .)
    DO              reduce using rule 59 (andexp1 -> AND andexp .)


state 144

    (62) boolexp1 -> GREATER arithexp .

    AND             reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    OR              reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    ID              reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    READ            reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    WRITE           reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    RETURN          reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    IF              reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    WHILE           reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    FOR             reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    LEFTPAR         reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    CTEINT          reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    CTEFLOAT        reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    CTECHAR         reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    RIGHTBR         reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    RIGHTPAR        reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    RIGHTSQR        reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    COMMA           reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    SEMICOLON       reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    TO              reduce using rule 62 (boolexp1 -> GREATER arithexp .)
    DO              reduce using rule 62 (boolexp1 -> GREATER arithexp .)


state 145

    (63) boolexp1 -> GREATERAND arithexp .

    AND             reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    OR              reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    ID              reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    READ            reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    WRITE           reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    RETURN          reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    IF              reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    WHILE           reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    FOR             reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    LEFTPAR         reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    CTEINT          reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    CTEFLOAT        reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    CTECHAR         reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    RIGHTBR         reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    RIGHTPAR        reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    RIGHTSQR        reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    COMMA           reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    SEMICOLON       reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    TO              reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)
    DO              reduce using rule 63 (boolexp1 -> GREATERAND arithexp .)


state 146

    (64) boolexp1 -> LESSER arithexp .

    AND             reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    OR              reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    ID              reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    READ            reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    WRITE           reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    RETURN          reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    IF              reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    WHILE           reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    FOR             reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    LEFTPAR         reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    CTEINT          reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    CTEFLOAT        reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    CTECHAR         reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    RIGHTBR         reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    RIGHTPAR        reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    RIGHTSQR        reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    COMMA           reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    SEMICOLON       reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    TO              reduce using rule 64 (boolexp1 -> LESSER arithexp .)
    DO              reduce using rule 64 (boolexp1 -> LESSER arithexp .)


state 147

    (65) boolexp1 -> LESSERAND arithexp .

    AND             reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    OR              reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    ID              reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    READ            reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    WRITE           reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    RETURN          reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    IF              reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    WHILE           reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    FOR             reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    LEFTPAR         reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    CTEINT          reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    CTEFLOAT        reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    CTECHAR         reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    RIGHTBR         reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    RIGHTPAR        reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    RIGHTSQR        reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    COMMA           reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    SEMICOLON       reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    TO              reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)
    DO              reduce using rule 65 (boolexp1 -> LESSERAND arithexp .)


state 148

    (66) boolexp1 -> SAME arithexp .

    AND             reduce using rule 66 (boolexp1 -> SAME arithexp .)
    OR              reduce using rule 66 (boolexp1 -> SAME arithexp .)
    ID              reduce using rule 66 (boolexp1 -> SAME arithexp .)
    READ            reduce using rule 66 (boolexp1 -> SAME arithexp .)
    WRITE           reduce using rule 66 (boolexp1 -> SAME arithexp .)
    RETURN          reduce using rule 66 (boolexp1 -> SAME arithexp .)
    IF              reduce using rule 66 (boolexp1 -> SAME arithexp .)
    WHILE           reduce using rule 66 (boolexp1 -> SAME arithexp .)
    FOR             reduce using rule 66 (boolexp1 -> SAME arithexp .)
    LEFTPAR         reduce using rule 66 (boolexp1 -> SAME arithexp .)
    CTEINT          reduce using rule 66 (boolexp1 -> SAME arithexp .)
    CTEFLOAT        reduce using rule 66 (boolexp1 -> SAME arithexp .)
    CTECHAR         reduce using rule 66 (boolexp1 -> SAME arithexp .)
    RIGHTBR         reduce using rule 66 (boolexp1 -> SAME arithexp .)
    RIGHTPAR        reduce using rule 66 (boolexp1 -> SAME arithexp .)
    RIGHTSQR        reduce using rule 66 (boolexp1 -> SAME arithexp .)
    COMMA           reduce using rule 66 (boolexp1 -> SAME arithexp .)
    SEMICOLON       reduce using rule 66 (boolexp1 -> SAME arithexp .)
    TO              reduce using rule 66 (boolexp1 -> SAME arithexp .)
    DO              reduce using rule 66 (boolexp1 -> SAME arithexp .)


state 149

    (67) boolexp1 -> NOTSAME arithexp .

    AND             reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    OR              reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    ID              reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    READ            reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    WRITE           reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    RETURN          reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    IF              reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    WHILE           reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    FOR             reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    LEFTPAR         reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    CTEINT          reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    CTEFLOAT        reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    CTECHAR         reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    RIGHTBR         reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    RIGHTPAR        reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    RIGHTSQR        reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    COMMA           reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    SEMICOLON       reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    TO              reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)
    DO              reduce using rule 67 (boolexp1 -> NOTSAME arithexp .)


state 150

    (68) boolexp1 -> NOT arithexp .

    AND             reduce using rule 68 (boolexp1 -> NOT arithexp .)
    OR              reduce using rule 68 (boolexp1 -> NOT arithexp .)
    ID              reduce using rule 68 (boolexp1 -> NOT arithexp .)
    READ            reduce using rule 68 (boolexp1 -> NOT arithexp .)
    WRITE           reduce using rule 68 (boolexp1 -> NOT arithexp .)
    RETURN          reduce using rule 68 (boolexp1 -> NOT arithexp .)
    IF              reduce using rule 68 (boolexp1 -> NOT arithexp .)
    WHILE           reduce using rule 68 (boolexp1 -> NOT arithexp .)
    FOR             reduce using rule 68 (boolexp1 -> NOT arithexp .)
    LEFTPAR         reduce using rule 68 (boolexp1 -> NOT arithexp .)
    CTEINT          reduce using rule 68 (boolexp1 -> NOT arithexp .)
    CTEFLOAT        reduce using rule 68 (boolexp1 -> NOT arithexp .)
    CTECHAR         reduce using rule 68 (boolexp1 -> NOT arithexp .)
    RIGHTBR         reduce using rule 68 (boolexp1 -> NOT arithexp .)
    RIGHTPAR        reduce using rule 68 (boolexp1 -> NOT arithexp .)
    RIGHTSQR        reduce using rule 68 (boolexp1 -> NOT arithexp .)
    COMMA           reduce using rule 68 (boolexp1 -> NOT arithexp .)
    SEMICOLON       reduce using rule 68 (boolexp1 -> NOT arithexp .)
    TO              reduce using rule 68 (boolexp1 -> NOT arithexp .)
    DO              reduce using rule 68 (boolexp1 -> NOT arithexp .)


state 151

    (71) arithexp1 -> PLUS arithexp .

    GREATER         reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    GREATERAND      reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    LESSER          reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    LESSERAND       reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    SAME            reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    NOTSAME         reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    NOT             reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    AND             reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    OR              reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    ID              reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    READ            reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    WRITE           reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    RETURN          reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    IF              reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    WHILE           reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    FOR             reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    LEFTPAR         reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    CTEINT          reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    CTEFLOAT        reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    CTECHAR         reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    RIGHTBR         reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    RIGHTPAR        reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    RIGHTSQR        reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    COMMA           reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    SEMICOLON       reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    TO              reduce using rule 71 (arithexp1 -> PLUS arithexp .)
    DO              reduce using rule 71 (arithexp1 -> PLUS arithexp .)


state 152

    (72) arithexp1 -> REST arithexp .

    GREATER         reduce using rule 72 (arithexp1 -> REST arithexp .)
    GREATERAND      reduce using rule 72 (arithexp1 -> REST arithexp .)
    LESSER          reduce using rule 72 (arithexp1 -> REST arithexp .)
    LESSERAND       reduce using rule 72 (arithexp1 -> REST arithexp .)
    SAME            reduce using rule 72 (arithexp1 -> REST arithexp .)
    NOTSAME         reduce using rule 72 (arithexp1 -> REST arithexp .)
    NOT             reduce using rule 72 (arithexp1 -> REST arithexp .)
    AND             reduce using rule 72 (arithexp1 -> REST arithexp .)
    OR              reduce using rule 72 (arithexp1 -> REST arithexp .)
    ID              reduce using rule 72 (arithexp1 -> REST arithexp .)
    READ            reduce using rule 72 (arithexp1 -> REST arithexp .)
    WRITE           reduce using rule 72 (arithexp1 -> REST arithexp .)
    RETURN          reduce using rule 72 (arithexp1 -> REST arithexp .)
    IF              reduce using rule 72 (arithexp1 -> REST arithexp .)
    WHILE           reduce using rule 72 (arithexp1 -> REST arithexp .)
    FOR             reduce using rule 72 (arithexp1 -> REST arithexp .)
    LEFTPAR         reduce using rule 72 (arithexp1 -> REST arithexp .)
    CTEINT          reduce using rule 72 (arithexp1 -> REST arithexp .)
    CTEFLOAT        reduce using rule 72 (arithexp1 -> REST arithexp .)
    CTECHAR         reduce using rule 72 (arithexp1 -> REST arithexp .)
    RIGHTBR         reduce using rule 72 (arithexp1 -> REST arithexp .)
    RIGHTPAR        reduce using rule 72 (arithexp1 -> REST arithexp .)
    RIGHTSQR        reduce using rule 72 (arithexp1 -> REST arithexp .)
    COMMA           reduce using rule 72 (arithexp1 -> REST arithexp .)
    SEMICOLON       reduce using rule 72 (arithexp1 -> REST arithexp .)
    TO              reduce using rule 72 (arithexp1 -> REST arithexp .)
    DO              reduce using rule 72 (arithexp1 -> REST arithexp .)


state 153

    (75) geoexp1 -> TIMES geoexp .

    PLUS            reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    REST            reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    GREATER         reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    GREATERAND      reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    LESSER          reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    LESSERAND       reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    SAME            reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    NOTSAME         reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    NOT             reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    AND             reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    OR              reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    ID              reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    READ            reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    WRITE           reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    RETURN          reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    IF              reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    WHILE           reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    FOR             reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    LEFTPAR         reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    CTEINT          reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    CTEFLOAT        reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    CTECHAR         reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    RIGHTBR         reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    RIGHTPAR        reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    RIGHTSQR        reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    COMMA           reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    SEMICOLON       reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    TO              reduce using rule 75 (geoexp1 -> TIMES geoexp .)
    DO              reduce using rule 75 (geoexp1 -> TIMES geoexp .)


state 154

    (76) geoexp1 -> DIVIDE geoexp .

    PLUS            reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    REST            reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    GREATER         reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    GREATERAND      reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    LESSER          reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    LESSERAND       reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    SAME            reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    NOTSAME         reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    NOT             reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    AND             reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    OR              reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    ID              reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    READ            reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    WRITE           reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    RETURN          reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    IF              reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    WHILE           reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    FOR             reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    LEFTPAR         reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    CTEINT          reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    CTEFLOAT        reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    CTECHAR         reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    RIGHTBR         reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    RIGHTPAR        reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    RIGHTSQR        reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    COMMA           reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    SEMICOLON       reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    TO              reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)
    DO              reduce using rule 76 (geoexp1 -> DIVIDE geoexp .)


state 155

    (16) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl . LEFTBR statutes RIGHTBR modules

    LEFTBR          shift and go to state 172


state 156

    (20) parameters -> typing COLON ID idarray . mulparams
    (22) mulparams -> . COMMA parameters
    (23) mulparams -> . empty
    (90) empty -> .

    COMMA           shift and go to state 174
    RIGHTPAR        reduce using rule 90 (empty -> .)

    mulparams                      shift and go to state 173
    empty                          shift and go to state 175

state 157

    (10) varsmul -> COMMA neuralinsertvar varsarr varsmul .

    INT             reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FLOAT           reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    CHAR            reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FUNCTION        reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    MAIN            reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    LEFTBR          reduce using rule 10 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)


state 158

    (36) assign -> ID idarray EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 176


state 159

    (53) idarray -> LEFTSQR exp RIGHTSQR .

    EQUAL           reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    TIMES           reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    DIVIDE          reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    PLUS            reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    REST            reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    GREATER         reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    GREATERAND      reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    LESSER          reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    LESSERAND       reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    SAME            reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    NOTSAME         reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    NOT             reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    AND             reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    OR              reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    ID              reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    READ            reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    WRITE           reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    RETURN          reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    IF              reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    WHILE           reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    FOR             reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    LEFTPAR         reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTEINT          reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTEFLOAT        reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTECHAR         reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTBR         reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTPAR        reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTSQR        reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    COMMA           reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    SEMICOLON       reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    TO              reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)
    DO              reduce using rule 53 (idarray -> LEFTSQR exp RIGHTSQR .)


state 160

    (84) paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .

    TIMES           reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    DIVIDE          reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    PLUS            reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    REST            reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    GREATER         reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    GREATERAND      reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    LESSER          reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    LESSERAND       reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    SAME            reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    NOTSAME         reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    NOT             reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    AND             reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    OR              reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    ID              reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    READ            reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    WRITE           reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RETURN          reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    IF              reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    WHILE           reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    FOR             reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    LEFTPAR         reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    CTEINT          reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    CTEFLOAT        reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    CTECHAR         reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RIGHTBR         reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RIGHTPAR        reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    RIGHTSQR        reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    COMMA           reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    SEMICOLON       reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    TO              reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)
    DO              reduce using rule 84 (paramsexp -> LEFTPAR paramsexp2 RIGHTPAR .)


state 161

    (86) paramsexp2 -> exp auxparamsexp2 .

    RIGHTPAR        reduce using rule 86 (paramsexp2 -> exp auxparamsexp2 .)


state 162

    (88) auxparamsexp2 -> COMMA . exp auxparamsexp2
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 177
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 163

    (89) auxparamsexp2 -> empty .

    RIGHTPAR        reduce using rule 89 (auxparamsexp2 -> empty .)


state 164

    (44) reading -> READ LEFTPAR ID idarray . mulread RIGHTPAR SEMICOLON
    (45) mulread -> . COMMA ID idarray mulread
    (46) mulread -> . empty
    (90) empty -> .

    COMMA           shift and go to state 179
    RIGHTPAR        reduce using rule 90 (empty -> .)

    mulread                        shift and go to state 178
    empty                          shift and go to state 180

state 165

    (37) writing -> WRITE LEFTPAR auxwrite mulwrite . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 181


state 166

    (42) mulwrite -> COMMA . auxwrite mulwrite
    (38) auxwrite -> . writetyping
    (39) auxwrite -> . exp
    (40) writetyping -> . STRING
    (41) writetyping -> . CTECHAR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    STRING          shift and go to state 136
    CTECHAR         shift and go to state 137
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    ID              shift and go to state 75

    auxwrite                       shift and go to state 182
    writetyping                    shift and go to state 134
    exp                            shift and go to state 135
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 167

    (43) mulwrite -> empty .

    RIGHTPAR        reduce using rule 43 (mulwrite -> empty .)


state 168

    (47) returning -> RETURN LEFTPAR exp RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 183


state 169

    (48) ifing -> IF LEFTPAR exp RIGHTPAR . THEN LEFTBR statutes RIGHTBR elsing

    THEN            shift and go to state 184


state 170

    (51) whiling -> WHILE LEFTPAR exp RIGHTPAR . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 185


state 171

    (52) foring -> FOR ID idarray EQUAL . exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 186
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 172

    (16) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR . statutes RIGHTBR modules
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (90) empty -> .
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    RIGHTBR         reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    statutes                       shift and go to state 187
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    empty                          shift and go to state 60
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 173

    (20) parameters -> typing COLON ID idarray mulparams .

    RIGHTPAR        reduce using rule 20 (parameters -> typing COLON ID idarray mulparams .)


state 174

    (22) mulparams -> COMMA . parameters
    (20) parameters -> . typing COLON ID idarray mulparams
    (21) parameters -> . empty
    (17) typing -> . INT
    (18) typing -> . FLOAT
    (19) typing -> . CHAR
    (90) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 90 (empty -> .)

    parameters                     shift and go to state 188
    typing                         shift and go to state 35
    empty                          shift and go to state 36

state 175

    (23) mulparams -> empty .

    RIGHTPAR        reduce using rule 23 (mulparams -> empty .)


state 176

    (36) assign -> ID idarray EQUAL exp SEMICOLON .

    ID              reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    READ            reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    WRITE           reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    IF              reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    FOR             reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    LEFTPAR         reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    CTEINT          reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    CTEFLOAT        reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    CTECHAR         reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)
    RIGHTBR         reduce using rule 36 (assign -> ID idarray EQUAL exp SEMICOLON .)


state 177

    (88) auxparamsexp2 -> COMMA exp . auxparamsexp2
    (88) auxparamsexp2 -> . COMMA exp auxparamsexp2
    (89) auxparamsexp2 -> . empty
    (90) empty -> .

    COMMA           shift and go to state 162
    RIGHTPAR        reduce using rule 90 (empty -> .)

    auxparamsexp2                  shift and go to state 189
    empty                          shift and go to state 163

state 178

    (44) reading -> READ LEFTPAR ID idarray mulread . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 190


state 179

    (45) mulread -> COMMA . ID idarray mulread

    ID              shift and go to state 191


state 180

    (46) mulread -> empty .

    RIGHTPAR        reduce using rule 46 (mulread -> empty .)


state 181

    (37) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 192


state 182

    (42) mulwrite -> COMMA auxwrite . mulwrite
    (42) mulwrite -> . COMMA auxwrite mulwrite
    (43) mulwrite -> . empty
    (90) empty -> .

    COMMA           shift and go to state 166
    RIGHTPAR        reduce using rule 90 (empty -> .)

    mulwrite                       shift and go to state 193
    empty                          shift and go to state 167

state 183

    (47) returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .

    ID              reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    READ            reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    IF              reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 47 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)


state 184

    (48) ifing -> IF LEFTPAR exp RIGHTPAR THEN . LEFTBR statutes RIGHTBR elsing

    LEFTBR          shift and go to state 194


state 185

    (51) whiling -> WHILE LEFTPAR exp RIGHTPAR DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 195


state 186

    (52) foring -> FOR ID idarray EQUAL exp . TO exp DO LEFTBR statutes RIGHTBR

    TO              shift and go to state 196


state 187

    (16) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes . RIGHTBR modules

    RIGHTBR         shift and go to state 197


state 188

    (22) mulparams -> COMMA parameters .

    RIGHTPAR        reduce using rule 22 (mulparams -> COMMA parameters .)


state 189

    (88) auxparamsexp2 -> COMMA exp auxparamsexp2 .

    RIGHTPAR        reduce using rule 88 (auxparamsexp2 -> COMMA exp auxparamsexp2 .)


state 190

    (44) reading -> READ LEFTPAR ID idarray mulread RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 198


state 191

    (45) mulread -> COMMA ID . idarray mulread
    (53) idarray -> . LEFTSQR exp RIGHTSQR
    (54) idarray -> . empty
    (90) empty -> .

    LEFTSQR         shift and go to state 90
    COMMA           reduce using rule 90 (empty -> .)
    RIGHTPAR        reduce using rule 90 (empty -> .)

    idarray                        shift and go to state 199
    empty                          shift and go to state 91

state 192

    (37) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .

    ID              reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    READ            reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    IF              reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 37 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)


state 193

    (42) mulwrite -> COMMA auxwrite mulwrite .

    RIGHTPAR        reduce using rule 42 (mulwrite -> COMMA auxwrite mulwrite .)


state 194

    (48) ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR . statutes RIGHTBR elsing
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (90) empty -> .
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    RIGHTBR         reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    exp                            shift and go to state 50
    statutes                       shift and go to state 200
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    empty                          shift and go to state 60
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 195

    (51) whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR . statutes RIGHTBR
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (90) empty -> .
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    RIGHTBR         reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    exp                            shift and go to state 50
    statutes                       shift and go to state 201
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    empty                          shift and go to state 60
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 196

    (52) foring -> FOR ID idarray EQUAL exp TO . exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (58) andexp -> . boolexp andexp1
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68
    ID              shift and go to state 75

    exp                            shift and go to state 202
    andexp                         shift and go to state 59
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 197

    (16) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR . modules
    (12) modules -> . FUNCTION functype ID funcparam
    (13) modules -> . empty
    (90) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 90 (empty -> .)

    modules                        shift and go to state 203
    empty                          shift and go to state 11

state 198

    (44) reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .

    ID              reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    READ            reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    IF              reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 44 (reading -> READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON .)


state 199

    (45) mulread -> COMMA ID idarray . mulread
    (45) mulread -> . COMMA ID idarray mulread
    (46) mulread -> . empty
    (90) empty -> .

    COMMA           shift and go to state 179
    RIGHTPAR        reduce using rule 90 (empty -> .)

    mulread                        shift and go to state 204
    empty                          shift and go to state 180

state 200

    (48) ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes . RIGHTBR elsing

    RIGHTBR         shift and go to state 205


state 201

    (51) whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 206


state 202

    (52) foring -> FOR ID idarray EQUAL exp TO exp . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 207


state 203

    (16) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR modules .

    MAIN            reduce using rule 16 (funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR statutes RIGHTBR modules .)


state 204

    (45) mulread -> COMMA ID idarray mulread .

    RIGHTPAR        reduce using rule 45 (mulread -> COMMA ID idarray mulread .)


state 205

    (48) ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR . elsing
    (49) elsing -> . ELSE LEFTBR statutes RIGHTBR
    (50) elsing -> . empty
    (90) empty -> .

    ELSE            shift and go to state 209
    ID              reduce using rule 90 (empty -> .)
    READ            reduce using rule 90 (empty -> .)
    WRITE           reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    WHILE           reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    LEFTPAR         reduce using rule 90 (empty -> .)
    CTEINT          reduce using rule 90 (empty -> .)
    CTEFLOAT        reduce using rule 90 (empty -> .)
    CTECHAR         reduce using rule 90 (empty -> .)
    RIGHTBR         reduce using rule 90 (empty -> .)

    elsing                         shift and go to state 208
    empty                          shift and go to state 210

state 206

    (51) whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .

    ID              reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 51 (whiling -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)


state 207

    (52) foring -> FOR ID idarray EQUAL exp TO exp DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 211


state 208

    (48) ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .

    ID              reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    READ            reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    WRITE           reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    RETURN          reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    IF              reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    WHILE           reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    FOR             reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    LEFTPAR         reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    CTEINT          reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    CTEFLOAT        reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    CTECHAR         reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)
    RIGHTBR         reduce using rule 48 (ifing -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing .)


state 209

    (49) elsing -> ELSE . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 212


state 210

    (50) elsing -> empty .

    ID              reduce using rule 50 (elsing -> empty .)
    READ            reduce using rule 50 (elsing -> empty .)
    WRITE           reduce using rule 50 (elsing -> empty .)
    RETURN          reduce using rule 50 (elsing -> empty .)
    IF              reduce using rule 50 (elsing -> empty .)
    WHILE           reduce using rule 50 (elsing -> empty .)
    FOR             reduce using rule 50 (elsing -> empty .)
    LEFTPAR         reduce using rule 50 (elsing -> empty .)
    CTEINT          reduce using rule 50 (elsing -> empty .)
    CTEFLOAT        reduce using rule 50 (elsing -> empty .)
    CTECHAR         reduce using rule 50 (elsing -> empty .)
    RIGHTBR         reduce using rule 50 (elsing -> empty .)


state 211

    (52) foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR . statutes RIGHTBR
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (90) empty -> .
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    RIGHTBR         reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    exp                            shift and go to state 50
    statutes                       shift and go to state 213
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    empty                          shift and go to state 60
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 212

    (49) elsing -> ELSE LEFTBR . statutes RIGHTBR
    (24) statutes -> . assign statutesaux
    (25) statutes -> . reading statutesaux
    (26) statutes -> . writing statutesaux
    (27) statutes -> . returning statutesaux
    (28) statutes -> . ifing statutesaux
    (29) statutes -> . whiling statutesaux
    (30) statutes -> . foring statutesaux
    (31) statutes -> . exp statutesaux
    (32) statutes -> . specialfunc statutesaux
    (36) assign -> . ID idarray EQUAL exp SEMICOLON
    (44) reading -> . READ LEFTPAR ID idarray mulread RIGHTPAR SEMICOLON
    (37) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (47) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (48) ifing -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR elsing
    (51) whiling -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (52) foring -> . FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR
    (55) exp -> . andexp exp1
    (35) specialfunc -> . empty
    (58) andexp -> . boolexp andexp1
    (90) empty -> .
    (61) boolexp -> . arithexp boolexp1
    (70) arithexp -> . geoexp arithexp1
    (74) geoexp -> . finexp geoexp1
    (78) finexp -> . LEFTPAR exp RIGHTPAR
    (79) finexp -> . cteexp
    (80) cteexp -> . CTEINT
    (81) cteexp -> . CTEFLOAT
    (82) cteexp -> . CTECHAR
    (83) cteexp -> . ID paramsexp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    ID              shift and go to state 52
    READ            shift and go to state 53
    WRITE           shift and go to state 54
    RETURN          shift and go to state 55
    IF              shift and go to state 56
    WHILE           shift and go to state 57
    FOR             shift and go to state 58
    RIGHTBR         reduce using rule 90 (empty -> .)
    LEFTPAR         shift and go to state 41
    CTEINT          shift and go to state 66
    CTEFLOAT        shift and go to state 67
    CTECHAR         shift and go to state 68

  ! ID              [ reduce using rule 90 (empty -> .) ]
  ! READ            [ reduce using rule 90 (empty -> .) ]
  ! WRITE           [ reduce using rule 90 (empty -> .) ]
  ! RETURN          [ reduce using rule 90 (empty -> .) ]
  ! IF              [ reduce using rule 90 (empty -> .) ]
  ! WHILE           [ reduce using rule 90 (empty -> .) ]
  ! FOR             [ reduce using rule 90 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 90 (empty -> .) ]
  ! CTEINT          [ reduce using rule 90 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 90 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 90 (empty -> .) ]

    statutes                       shift and go to state 214
    assign                         shift and go to state 43
    reading                        shift and go to state 44
    writing                        shift and go to state 45
    returning                      shift and go to state 46
    ifing                          shift and go to state 47
    whiling                        shift and go to state 48
    foring                         shift and go to state 49
    exp                            shift and go to state 50
    specialfunc                    shift and go to state 51
    andexp                         shift and go to state 59
    empty                          shift and go to state 60
    boolexp                        shift and go to state 61
    arithexp                       shift and go to state 62
    geoexp                         shift and go to state 63
    finexp                         shift and go to state 64
    cteexp                         shift and go to state 65

state 213

    (52) foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 215


state 214

    (49) elsing -> ELSE LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 216


state 215

    (52) foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .

    ID              reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 52 (foring -> FOR ID idarray EQUAL exp TO exp DO LEFTBR statutes RIGHTBR .)


state 216

    (49) elsing -> ELSE LEFTBR statutes RIGHTBR .

    ID              reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 49 (elsing -> ELSE LEFTBR statutes RIGHTBR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 33 resolved as shift
WARNING: shift/reduce conflict for READ in state 33 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 33 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 33 resolved as shift
WARNING: shift/reduce conflict for IF in state 33 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 33 resolved as shift
WARNING: shift/reduce conflict for FOR in state 33 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 33 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 33 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 33 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 33 resolved as shift
WARNING: shift/reduce conflict for ID in state 43 resolved as shift
WARNING: shift/reduce conflict for READ in state 43 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 43 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 43 resolved as shift
WARNING: shift/reduce conflict for FOR in state 43 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 43 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 43 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 43 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 44 resolved as shift
WARNING: shift/reduce conflict for READ in state 44 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 44 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 44 resolved as shift
WARNING: shift/reduce conflict for FOR in state 44 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 44 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 44 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 44 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 44 resolved as shift
WARNING: shift/reduce conflict for ID in state 45 resolved as shift
WARNING: shift/reduce conflict for READ in state 45 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 45 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 45 resolved as shift
WARNING: shift/reduce conflict for FOR in state 45 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 45 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 45 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 45 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 45 resolved as shift
WARNING: shift/reduce conflict for ID in state 46 resolved as shift
WARNING: shift/reduce conflict for READ in state 46 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 46 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 46 resolved as shift
WARNING: shift/reduce conflict for FOR in state 46 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 46 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 46 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 46 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 46 resolved as shift
WARNING: shift/reduce conflict for ID in state 47 resolved as shift
WARNING: shift/reduce conflict for READ in state 47 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for FOR in state 47 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 47 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 47 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 47 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 48 resolved as shift
WARNING: shift/reduce conflict for READ in state 48 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 48 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 48 resolved as shift
WARNING: shift/reduce conflict for IF in state 48 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 48 resolved as shift
WARNING: shift/reduce conflict for FOR in state 48 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 48 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 48 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 48 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 48 resolved as shift
WARNING: shift/reduce conflict for ID in state 49 resolved as shift
WARNING: shift/reduce conflict for READ in state 49 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 49 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 49 resolved as shift
WARNING: shift/reduce conflict for IF in state 49 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 49 resolved as shift
WARNING: shift/reduce conflict for FOR in state 49 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 49 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 49 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 49 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 49 resolved as shift
WARNING: shift/reduce conflict for ID in state 50 resolved as shift
WARNING: shift/reduce conflict for READ in state 50 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 50 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 50 resolved as shift
WARNING: shift/reduce conflict for IF in state 50 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 50 resolved as shift
WARNING: shift/reduce conflict for FOR in state 50 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 50 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 50 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 50 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 50 resolved as shift
WARNING: shift/reduce conflict for ID in state 51 resolved as shift
WARNING: shift/reduce conflict for READ in state 51 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 51 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 51 resolved as shift
WARNING: shift/reduce conflict for IF in state 51 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 51 resolved as shift
WARNING: shift/reduce conflict for FOR in state 51 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 51 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 51 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 51 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 51 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 52 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 75 resolved as shift
WARNING: shift/reduce conflict for ID in state 172 resolved as shift
WARNING: shift/reduce conflict for READ in state 172 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 172 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 172 resolved as shift
WARNING: shift/reduce conflict for IF in state 172 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 172 resolved as shift
WARNING: shift/reduce conflict for FOR in state 172 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 172 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 172 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 172 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 172 resolved as shift
WARNING: shift/reduce conflict for ID in state 194 resolved as shift
WARNING: shift/reduce conflict for READ in state 194 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 194 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 194 resolved as shift
WARNING: shift/reduce conflict for IF in state 194 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 194 resolved as shift
WARNING: shift/reduce conflict for FOR in state 194 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 194 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 194 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 194 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 194 resolved as shift
WARNING: shift/reduce conflict for ID in state 195 resolved as shift
WARNING: shift/reduce conflict for READ in state 195 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 195 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 195 resolved as shift
WARNING: shift/reduce conflict for IF in state 195 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 195 resolved as shift
WARNING: shift/reduce conflict for FOR in state 195 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 195 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 195 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 195 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 195 resolved as shift
WARNING: shift/reduce conflict for ID in state 211 resolved as shift
WARNING: shift/reduce conflict for READ in state 211 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 211 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 211 resolved as shift
WARNING: shift/reduce conflict for IF in state 211 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 211 resolved as shift
WARNING: shift/reduce conflict for FOR in state 211 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 211 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 211 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 211 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 211 resolved as shift
WARNING: shift/reduce conflict for ID in state 212 resolved as shift
WARNING: shift/reduce conflict for READ in state 212 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 212 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 212 resolved as shift
WARNING: shift/reduce conflict for IF in state 212 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 212 resolved as shift
WARNING: shift/reduce conflict for FOR in state 212 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 212 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 212 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 212 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 212 resolved as shift
WARNING: reduce/reduce conflict in state 79 resolved using rule (statutesaux -> empty)
WARNING: rejected rule (specialfunc -> empty) in state 79
WARNING: reduce/reduce conflict in state 137 resolved using rule (writetyping -> CTECHAR)
WARNING: rejected rule (cteexp -> CTECHAR) in state 137
