Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    STR
    TRUE
    FALSE
    MEDIA
    MEDIANA
    MODA
    VARIANZA
    STDEV
    PLOTXY

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
Rule 2     neuraltablefunctions -> ID
Rule 3     neuralmainjump -> <empty>
Rule 4     varsgl -> VARS vars
Rule 5     varsgl -> empty
Rule 6     vars -> typing COLON neuralinsertvar varsarr varsmul vars
Rule 7     vars -> empty
Rule 8     neuralinsertvar -> ID
Rule 9     varsmul -> COMMA neuralinsertvar varsarr varsmul
Rule 10    varsmul -> SEMICOLON
Rule 11    varsarr -> initdim CTEINT enddim
Rule 12    varsarr -> empty
Rule 13    initdim -> LEFTSQR
Rule 14    enddim -> RIGHTSQR
Rule 15    idarray -> initarray exp verify RIGHTSQR
Rule 16    idarray -> empty
Rule 17    initarray -> LEFTSQR
Rule 18    verify -> <empty>
Rule 19    typing -> INT
Rule 20    typing -> FLOAT
Rule 21    typing -> CHAR
Rule 22    modules -> FUNCTION functype neuralinsertfuncname funcparam
Rule 23    modules -> empty
Rule 24    neuralinsertfuncname -> ID
Rule 25    functype -> VOID
Rule 26    functype -> typing
Rule 27    funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules
Rule 28    neuralendfuncs -> <empty>
Rule 29    funcsize -> <empty>
Rule 30    startfunc -> <empty>
Rule 31    parameters -> typing COLON neuralinsertid idarray mulparams
Rule 32    parameters -> empty
Rule 33    neuralinsertid -> ID
Rule 34    mulparams -> COMMA parameters
Rule 35    mulparams -> empty
Rule 36    returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON
Rule 37    paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar
Rule 38    paramsexp -> idarray
Rule 39    paramsexp2 -> exp neuralpar2 auxparamsexp2
Rule 40    paramsexp2 -> empty
Rule 41    auxparamsexp2 -> COMMA exp neuralpar2 auxparamsexp2
Rule 42    auxparamsexp2 -> empty
Rule 43    neuralera -> <empty>
Rule 44    neuralpar -> RIGHTPAR
Rule 45    neuralpar2 -> <empty>
Rule 46    statutes -> assign statutesaux
Rule 47    statutes -> reading statutesaux
Rule 48    statutes -> writing statutesaux
Rule 49    statutes -> returning statutesaux
Rule 50    statutes -> ifing statutesaux
Rule 51    statutes -> whiling statutesaux
Rule 52    statutes -> foring statutesaux
Rule 53    statutes -> exp statutesaux
Rule 54    statutes -> specialfunc statutesaux
Rule 55    statutesaux -> statutes
Rule 56    statutesaux -> empty
Rule 57    specialfunc -> empty
Rule 58    assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON
Rule 59    neuralassign1 -> ID
Rule 60    neuralassign2 -> EQUAL
Rule 61    assignexp -> exp
Rule 62    writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
Rule 63    auxwrite -> writetyping
Rule 64    auxwrite -> exp
Rule 65    writetyping -> STRING
Rule 66    writetyping -> CTECHAR
Rule 67    mulwrite -> COMMA auxwrite mulwrite
Rule 68    mulwrite -> empty
Rule 69    reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
Rule 70    neuralread -> ID
Rule 71    mulread -> COMMA ID idarray mulread
Rule 72    mulread -> empty
Rule 73    ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
Rule 74    neuralif -> RIGHTPAR
Rule 75    elsing -> neuralelse LEFTBR statutes RIGHTBR
Rule 76    elsing -> empty
Rule 77    neuralelse -> ELSE
Rule 78    whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
Rule 79    neuralwhile1 -> WHILE
Rule 80    neuralwhile2 -> RIGHTPAR
Rule 81    foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
Rule 82    neuralfor1 -> ID
Rule 83    neuralfor2 -> TO
Rule 84    neuralfor3 -> DO
Rule 85    exp -> andexp exp1
Rule 86    exp1 -> OR exp
Rule 87    exp1 -> empty
Rule 88    andexp -> boolexp andexp1
Rule 89    andexp1 -> neuraland andexp
Rule 90    andexp1 -> empty
Rule 91    neuraland -> AND
Rule 92    boolexp -> arithexp boolexp1
Rule 93    boolexp1 -> neuralbool arithexp
Rule 94    boolexp1 -> empty
Rule 95    neuralbool -> GREATER
Rule 96    neuralbool -> GREATERAND
Rule 97    neuralbool -> LESSER
Rule 98    neuralbool -> LESSERAND
Rule 99    neuralbool -> SAME
Rule 100   neuralbool -> NOTSAME
Rule 101   neuralbool -> NOT
Rule 102   arithexp -> geoexp arithexp1
Rule 103   arithexp1 -> neuralarith arithexp
Rule 104   arithexp1 -> empty
Rule 105   neuralarith -> PLUS
Rule 106   neuralarith -> REST
Rule 107   geoexp -> finexp geoexp1
Rule 108   geoexp1 -> neuralgeo geoexp
Rule 109   geoexp1 -> empty
Rule 110   neuralgeo -> TIMES
Rule 111   neuralgeo -> DIVIDE
Rule 112   addparenth -> LEFTPAR
Rule 113   popparenth -> RIGHTPAR
Rule 114   finexp -> addparenth exp popparenth
Rule 115   finexp -> cteexp
Rule 116   cteexp -> CTEINT
Rule 117   cteexp -> CTEFLOAT
Rule 118   cteexp -> CTECHAR
Rule 119   cteexp -> ID neuralexist paramsexp
Rule 120   neuralexist -> <empty>
Rule 121   empty -> <empty>
Rule 122   debug -> empty

Terminals, with rules where they appear

AND                  : 91
CHAR                 : 21
COLON                : 6 31
COMMA                : 9 34 41 67 71
CTECHAR              : 66 118
CTEFLOAT             : 117
CTEINT               : 11 116
DIVIDE               : 111
DO                   : 78 84
ELSE                 : 77
EQUAL                : 60 81
FALSE                : 
FLOAT                : 20
FOR                  : 81
FUNCTION             : 22
GREATER              : 95
GREATERAND           : 96
ID                   : 2 8 24 33 59 70 71 82 119
IF                   : 73
INT                  : 19
LEFTBR               : 1 27 73 75 78 81
LEFTPAR              : 1 27 36 37 62 69 73 78 112
LEFTSQR              : 13 17
LESSER               : 97
LESSERAND            : 98
MAIN                 : 1
MEDIA                : 
MEDIANA              : 
MODA                 : 
NOT                  : 101
NOTSAME              : 100
OR                   : 86
PLOTXY               : 
PLUS                 : 105
PROGRAM              : 1
READ                 : 69
REST                 : 106
RETURN               : 36
RIGHTBR              : 1 27 73 75 78 81
RIGHTPAR             : 1 27 36 44 62 69 74 80 113
RIGHTSQR             : 14 15
SAME                 : 99
SEMICOLON            : 1 10 27 36 58 62 69
STDEV                : 
STR                  : 
STRING               : 65
THEN                 : 73
TIMES                : 110
TO                   : 83
TRUE                 : 
VARIANZA             : 
VARS                 : 4
VOID                 : 25
WHILE                : 79
WRITE                : 62
error                : 

Nonterminals, with rules where they appear

addparenth           : 114
andexp               : 85 89
andexp1              : 88
arithexp             : 92 93 103
arithexp1            : 102
assign               : 46
assignexp            : 58
auxparamsexp2        : 39 41
auxwrite             : 62 67
boolexp              : 88
boolexp1             : 92
cteexp               : 115
debug                : 
elsing               : 73
empty                : 5 7 12 16 23 32 35 40 42 56 57 68 72 76 87 90 94 104 109 122
enddim               : 11
exp                  : 15 36 39 41 53 61 64 73 78 81 81 86 114
exp1                 : 85
finexp               : 107
foring               : 52
funcparam            : 22
funcsize             : 27
functype             : 22
geoexp               : 102 108
geoexp1              : 107
idarray              : 31 38 58 69 71 81
ifing                : 50
initarray            : 15
initdim              : 11
modules              : 1 27
mulparams            : 31
mulread              : 69 71
mulwrite             : 62 67
neuraland            : 89
neuralarith          : 103
neuralassign1        : 58
neuralassign2        : 58
neuralbool           : 93
neuralelse           : 75
neuralendfuncs       : 27
neuralera            : 37
neuralexist          : 119
neuralfor1           : 81
neuralfor2           : 81
neuralfor3           : 81
neuralgeo            : 108
neuralif             : 73
neuralinsertfuncname : 22
neuralinsertid       : 31
neuralinsertvar      : 6 9
neuralmainjump       : 1
neuralpar            : 37
neuralpar2           : 39 41
neuralread           : 69
neuraltablefunctions : 1
neuralwhile1         : 78
neuralwhile2         : 78
parameters           : 27 34
paramsexp            : 119
paramsexp2           : 37
popparenth           : 114
program              : 0
reading              : 47
returning            : 49
specialfunc          : 54
startfunc            : 27
statutes             : 1 27 55 73 75 78 81
statutesaux          : 46 47 48 49 50 51 52 53 54
typing               : 6 26 31
vars                 : 4 6
varsarr              : 6 9
varsgl               : 1 27
varsmul              : 6 9
verify               : 15
whiling              : 51
writetyping          : 63
writing              : 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
    (2) neuraltablefunctions -> . ID

    ID              shift and go to state 4

    neuraltablefunctions           shift and go to state 3

state 3

    (1) program -> PROGRAM neuraltablefunctions . SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    SEMICOLON       shift and go to state 5


state 4

    (2) neuraltablefunctions -> ID .

    SEMICOLON       reduce using rule 2 (neuraltablefunctions -> ID .)


state 5

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON . varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
    (4) varsgl -> . VARS vars
    (5) varsgl -> . empty
    (121) empty -> .

    VARS            shift and go to state 7
    FUNCTION        reduce using rule 121 (empty -> .)
    MAIN            reduce using rule 121 (empty -> .)

    varsgl                         shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl . modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
    (22) modules -> . FUNCTION functype neuralinsertfuncname funcparam
    (23) modules -> . empty
    (121) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 121 (empty -> .)

    modules                        shift and go to state 9
    empty                          shift and go to state 11

state 7

    (4) varsgl -> VARS . vars
    (6) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (7) vars -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (121) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 121 (empty -> .)
    MAIN            reduce using rule 121 (empty -> .)
    LEFTBR          reduce using rule 121 (empty -> .)

    vars                           shift and go to state 12
    typing                         shift and go to state 13
    empty                          shift and go to state 14

state 8

    (5) varsgl -> empty .

    FUNCTION        reduce using rule 5 (varsgl -> empty .)
    MAIN            reduce using rule 5 (varsgl -> empty .)
    LEFTBR          reduce using rule 5 (varsgl -> empty .)


state 9

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules . MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    MAIN            shift and go to state 18


state 10

    (22) modules -> FUNCTION . functype neuralinsertfuncname funcparam
    (25) functype -> . VOID
    (26) functype -> . typing
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR

    VOID            shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    functype                       shift and go to state 19
    typing                         shift and go to state 21

state 11

    (23) modules -> empty .

    MAIN            reduce using rule 23 (modules -> empty .)


state 12

    (4) varsgl -> VARS vars .

    FUNCTION        reduce using rule 4 (varsgl -> VARS vars .)
    MAIN            reduce using rule 4 (varsgl -> VARS vars .)
    LEFTBR          reduce using rule 4 (varsgl -> VARS vars .)


state 13

    (6) vars -> typing . COLON neuralinsertvar varsarr varsmul vars

    COLON           shift and go to state 22


state 14

    (7) vars -> empty .

    FUNCTION        reduce using rule 7 (vars -> empty .)
    MAIN            reduce using rule 7 (vars -> empty .)
    LEFTBR          reduce using rule 7 (vars -> empty .)


state 15

    (19) typing -> INT .

    COLON           reduce using rule 19 (typing -> INT .)
    ID              reduce using rule 19 (typing -> INT .)


state 16

    (20) typing -> FLOAT .

    COLON           reduce using rule 20 (typing -> FLOAT .)
    ID              reduce using rule 20 (typing -> FLOAT .)


state 17

    (21) typing -> CHAR .

    COLON           reduce using rule 21 (typing -> CHAR .)
    ID              reduce using rule 21 (typing -> CHAR .)


state 18

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN . LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    LEFTPAR         shift and go to state 23


state 19

    (22) modules -> FUNCTION functype . neuralinsertfuncname funcparam
    (24) neuralinsertfuncname -> . ID

    ID              shift and go to state 25

    neuralinsertfuncname           shift and go to state 24

state 20

    (25) functype -> VOID .

    ID              reduce using rule 25 (functype -> VOID .)


state 21

    (26) functype -> typing .

    ID              reduce using rule 26 (functype -> typing .)


state 22

    (6) vars -> typing COLON . neuralinsertvar varsarr varsmul vars
    (8) neuralinsertvar -> . ID

    ID              shift and go to state 27

    neuralinsertvar                shift and go to state 26

state 23

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR . RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    RIGHTPAR        shift and go to state 28


state 24

    (22) modules -> FUNCTION functype neuralinsertfuncname . funcparam
    (27) funcparam -> . LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    LEFTPAR         shift and go to state 30

    funcparam                      shift and go to state 29

state 25

    (24) neuralinsertfuncname -> ID .

    LEFTPAR         reduce using rule 24 (neuralinsertfuncname -> ID .)


state 26

    (6) vars -> typing COLON neuralinsertvar . varsarr varsmul vars
    (11) varsarr -> . initdim CTEINT enddim
    (12) varsarr -> . empty
    (13) initdim -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 34
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)

    varsarr                        shift and go to state 31
    initdim                        shift and go to state 32
    empty                          shift and go to state 33

state 27

    (8) neuralinsertvar -> ID .

    LEFTSQR         reduce using rule 8 (neuralinsertvar -> ID .)
    COMMA           reduce using rule 8 (neuralinsertvar -> ID .)
    SEMICOLON       reduce using rule 8 (neuralinsertvar -> ID .)


state 28

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR . LEFTBR neuralmainjump statutes RIGHTBR

    LEFTBR          shift and go to state 35


state 29

    (22) modules -> FUNCTION functype neuralinsertfuncname funcparam .

    MAIN            reduce using rule 22 (modules -> FUNCTION functype neuralinsertfuncname funcparam .)


state 30

    (27) funcparam -> LEFTPAR . parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules
    (31) parameters -> . typing COLON neuralinsertid idarray mulparams
    (32) parameters -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (121) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 121 (empty -> .)

    parameters                     shift and go to state 36
    typing                         shift and go to state 37
    empty                          shift and go to state 38

state 31

    (6) vars -> typing COLON neuralinsertvar varsarr . varsmul vars
    (9) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (10) varsmul -> . SEMICOLON

    COMMA           shift and go to state 40
    SEMICOLON       shift and go to state 41

    varsmul                        shift and go to state 39

state 32

    (11) varsarr -> initdim . CTEINT enddim

    CTEINT          shift and go to state 42


state 33

    (12) varsarr -> empty .

    COMMA           reduce using rule 12 (varsarr -> empty .)
    SEMICOLON       reduce using rule 12 (varsarr -> empty .)


state 34

    (13) initdim -> LEFTSQR .

    CTEINT          reduce using rule 13 (initdim -> LEFTSQR .)


state 35

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR . neuralmainjump statutes RIGHTBR
    (3) neuralmainjump -> .

    READ            reduce using rule 3 (neuralmainjump -> .)
    WRITE           reduce using rule 3 (neuralmainjump -> .)
    RETURN          reduce using rule 3 (neuralmainjump -> .)
    IF              reduce using rule 3 (neuralmainjump -> .)
    FOR             reduce using rule 3 (neuralmainjump -> .)
    ID              reduce using rule 3 (neuralmainjump -> .)
    WHILE           reduce using rule 3 (neuralmainjump -> .)
    LEFTPAR         reduce using rule 3 (neuralmainjump -> .)
    CTEINT          reduce using rule 3 (neuralmainjump -> .)
    CTEFLOAT        reduce using rule 3 (neuralmainjump -> .)
    CTECHAR         reduce using rule 3 (neuralmainjump -> .)
    RIGHTBR         reduce using rule 3 (neuralmainjump -> .)

    neuralmainjump                 shift and go to state 43

state 36

    (27) funcparam -> LEFTPAR parameters . RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    RIGHTPAR        shift and go to state 44


state 37

    (31) parameters -> typing . COLON neuralinsertid idarray mulparams

    COLON           shift and go to state 45


state 38

    (32) parameters -> empty .

    RIGHTPAR        reduce using rule 32 (parameters -> empty .)


state 39

    (6) vars -> typing COLON neuralinsertvar varsarr varsmul . vars
    (6) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (7) vars -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (121) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 121 (empty -> .)
    MAIN            reduce using rule 121 (empty -> .)
    LEFTBR          reduce using rule 121 (empty -> .)

    typing                         shift and go to state 13
    vars                           shift and go to state 46
    empty                          shift and go to state 14

state 40

    (9) varsmul -> COMMA . neuralinsertvar varsarr varsmul
    (8) neuralinsertvar -> . ID

    ID              shift and go to state 27

    neuralinsertvar                shift and go to state 47

state 41

    (10) varsmul -> SEMICOLON .

    INT             reduce using rule 10 (varsmul -> SEMICOLON .)
    FLOAT           reduce using rule 10 (varsmul -> SEMICOLON .)
    CHAR            reduce using rule 10 (varsmul -> SEMICOLON .)
    FUNCTION        reduce using rule 10 (varsmul -> SEMICOLON .)
    MAIN            reduce using rule 10 (varsmul -> SEMICOLON .)
    LEFTBR          reduce using rule 10 (varsmul -> SEMICOLON .)


state 42

    (11) varsarr -> initdim CTEINT . enddim
    (14) enddim -> . RIGHTSQR

    RIGHTSQR        shift and go to state 49

    enddim                         shift and go to state 48

state 43

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump . statutes RIGHTBR
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (121) empty -> .
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    RIGHTBR         reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    statutes                       shift and go to state 51
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    empty                          shift and go to state 69
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 44

    (27) funcparam -> LEFTPAR parameters RIGHTPAR . SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    SEMICOLON       shift and go to state 81


state 45

    (31) parameters -> typing COLON . neuralinsertid idarray mulparams
    (33) neuralinsertid -> . ID

    ID              shift and go to state 83

    neuralinsertid                 shift and go to state 82

state 46

    (6) vars -> typing COLON neuralinsertvar varsarr varsmul vars .

    FUNCTION        reduce using rule 6 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    MAIN            reduce using rule 6 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    LEFTBR          reduce using rule 6 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)


state 47

    (9) varsmul -> COMMA neuralinsertvar . varsarr varsmul
    (11) varsarr -> . initdim CTEINT enddim
    (12) varsarr -> . empty
    (13) initdim -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 34
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)

    varsarr                        shift and go to state 84
    initdim                        shift and go to state 32
    empty                          shift and go to state 33

state 48

    (11) varsarr -> initdim CTEINT enddim .

    COMMA           reduce using rule 11 (varsarr -> initdim CTEINT enddim .)
    SEMICOLON       reduce using rule 11 (varsarr -> initdim CTEINT enddim .)


state 49

    (14) enddim -> RIGHTSQR .

    COMMA           reduce using rule 14 (enddim -> RIGHTSQR .)
    SEMICOLON       reduce using rule 14 (enddim -> RIGHTSQR .)


state 50

    (112) addparenth -> LEFTPAR .

    LEFTPAR         reduce using rule 112 (addparenth -> LEFTPAR .)
    CTEINT          reduce using rule 112 (addparenth -> LEFTPAR .)
    CTEFLOAT        reduce using rule 112 (addparenth -> LEFTPAR .)
    CTECHAR         reduce using rule 112 (addparenth -> LEFTPAR .)
    ID              reduce using rule 112 (addparenth -> LEFTPAR .)


state 51

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes . RIGHTBR

    RIGHTBR         shift and go to state 85


state 52

    (46) statutes -> assign . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    assign                         shift and go to state 52
    statutesaux                    shift and go to state 86
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 53

    (47) statutes -> reading . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    reading                        shift and go to state 53
    statutesaux                    shift and go to state 89
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 54

    (48) statutes -> writing . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    writing                        shift and go to state 54
    statutesaux                    shift and go to state 90
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 55

    (49) statutes -> returning . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    returning                      shift and go to state 55
    statutesaux                    shift and go to state 91
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 56

    (50) statutes -> ifing . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    ifing                          shift and go to state 56
    statutesaux                    shift and go to state 92
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 57

    (51) statutes -> whiling . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    whiling                        shift and go to state 57
    statutesaux                    shift and go to state 93
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 58

    (52) statutes -> foring . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    foring                         shift and go to state 58
    statutesaux                    shift and go to state 94
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 59

    (53) statutes -> exp . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    exp                            shift and go to state 59
    statutesaux                    shift and go to state 95
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 60

    (54) statutes -> specialfunc . statutesaux
    (55) statutesaux -> . statutes
    (56) statutesaux -> . empty
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (121) empty -> .
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 121 (empty -> .)
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    specialfunc                    shift and go to state 60
    statutesaux                    shift and go to state 96
    statutes                       shift and go to state 87
    empty                          shift and go to state 88
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 61

    (58) assign -> neuralassign1 . idarray neuralassign2 assignexp SEMICOLON
    (15) idarray -> . initarray exp verify RIGHTSQR
    (16) idarray -> . empty
    (17) initarray -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 100
    EQUAL           reduce using rule 121 (empty -> .)

    idarray                        shift and go to state 97
    initarray                      shift and go to state 98
    empty                          shift and go to state 99

state 62

    (69) reading -> READ . LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 101


state 63

    (62) writing -> WRITE . LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 102


state 64

    (36) returning -> RETURN . LEFTPAR exp RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 103


state 65

    (73) ifing -> IF . LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing

    LEFTPAR         shift and go to state 104


state 66

    (78) whiling -> neuralwhile1 . LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 105


state 67

    (81) foring -> FOR . neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (82) neuralfor1 -> . ID

    ID              shift and go to state 107

    neuralfor1                     shift and go to state 106

state 68

    (85) exp -> andexp . exp1
    (86) exp1 -> . OR exp
    (87) exp1 -> . empty
    (121) empty -> .

    OR              shift and go to state 109
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    LEFTPAR         reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)
    RIGHTSQR        reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    DO              reduce using rule 121 (empty -> .)

    exp1                           shift and go to state 108
    empty                          shift and go to state 110

state 69

    (57) specialfunc -> empty .

    READ            reduce using rule 57 (specialfunc -> empty .)
    WRITE           reduce using rule 57 (specialfunc -> empty .)
    RETURN          reduce using rule 57 (specialfunc -> empty .)
    IF              reduce using rule 57 (specialfunc -> empty .)
    FOR             reduce using rule 57 (specialfunc -> empty .)
    ID              reduce using rule 57 (specialfunc -> empty .)
    WHILE           reduce using rule 57 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 57 (specialfunc -> empty .)
    CTEINT          reduce using rule 57 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 57 (specialfunc -> empty .)
    CTECHAR         reduce using rule 57 (specialfunc -> empty .)
    RIGHTBR         reduce using rule 57 (specialfunc -> empty .)


state 70

    (59) neuralassign1 -> ID .
    (119) cteexp -> ID . neuralexist paramsexp
    (120) neuralexist -> .

  ! reduce/reduce conflict for LEFTSQR resolved using rule 59 (neuralassign1 -> ID .)
    LEFTSQR         reduce using rule 59 (neuralassign1 -> ID .)
    EQUAL           reduce using rule 59 (neuralassign1 -> ID .)
    LEFTPAR         reduce using rule 120 (neuralexist -> .)
    TIMES           reduce using rule 120 (neuralexist -> .)
    DIVIDE          reduce using rule 120 (neuralexist -> .)
    PLUS            reduce using rule 120 (neuralexist -> .)
    REST            reduce using rule 120 (neuralexist -> .)
    GREATER         reduce using rule 120 (neuralexist -> .)
    GREATERAND      reduce using rule 120 (neuralexist -> .)
    LESSER          reduce using rule 120 (neuralexist -> .)
    LESSERAND       reduce using rule 120 (neuralexist -> .)
    SAME            reduce using rule 120 (neuralexist -> .)
    NOTSAME         reduce using rule 120 (neuralexist -> .)
    NOT             reduce using rule 120 (neuralexist -> .)
    AND             reduce using rule 120 (neuralexist -> .)
    OR              reduce using rule 120 (neuralexist -> .)
    READ            reduce using rule 120 (neuralexist -> .)
    WRITE           reduce using rule 120 (neuralexist -> .)
    RETURN          reduce using rule 120 (neuralexist -> .)
    IF              reduce using rule 120 (neuralexist -> .)
    FOR             reduce using rule 120 (neuralexist -> .)
    ID              reduce using rule 120 (neuralexist -> .)
    WHILE           reduce using rule 120 (neuralexist -> .)
    CTEINT          reduce using rule 120 (neuralexist -> .)
    CTEFLOAT        reduce using rule 120 (neuralexist -> .)
    CTECHAR         reduce using rule 120 (neuralexist -> .)
    RIGHTBR         reduce using rule 120 (neuralexist -> .)

  ! LEFTSQR         [ reduce using rule 120 (neuralexist -> .) ]

    neuralexist                    shift and go to state 111

state 71

    (79) neuralwhile1 -> WHILE .

    LEFTPAR         reduce using rule 79 (neuralwhile1 -> WHILE .)


state 72

    (88) andexp -> boolexp . andexp1
    (89) andexp1 -> . neuraland andexp
    (90) andexp1 -> . empty
    (91) neuraland -> . AND
    (121) empty -> .

    AND             shift and go to state 115
    OR              reduce using rule 121 (empty -> .)
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    LEFTPAR         reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)
    RIGHTSQR        reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    DO              reduce using rule 121 (empty -> .)

    andexp1                        shift and go to state 112
    neuraland                      shift and go to state 113
    empty                          shift and go to state 114

state 73

    (92) boolexp -> arithexp . boolexp1
    (93) boolexp1 -> . neuralbool arithexp
    (94) boolexp1 -> . empty
    (95) neuralbool -> . GREATER
    (96) neuralbool -> . GREATERAND
    (97) neuralbool -> . LESSER
    (98) neuralbool -> . LESSERAND
    (99) neuralbool -> . SAME
    (100) neuralbool -> . NOTSAME
    (101) neuralbool -> . NOT
    (121) empty -> .

    GREATER         shift and go to state 119
    GREATERAND      shift and go to state 120
    LESSER          shift and go to state 121
    LESSERAND       shift and go to state 122
    SAME            shift and go to state 123
    NOTSAME         shift and go to state 124
    NOT             shift and go to state 125
    AND             reduce using rule 121 (empty -> .)
    OR              reduce using rule 121 (empty -> .)
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    LEFTPAR         reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)
    RIGHTSQR        reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    DO              reduce using rule 121 (empty -> .)

    boolexp1                       shift and go to state 116
    neuralbool                     shift and go to state 117
    empty                          shift and go to state 118

state 74

    (102) arithexp -> geoexp . arithexp1
    (103) arithexp1 -> . neuralarith arithexp
    (104) arithexp1 -> . empty
    (105) neuralarith -> . PLUS
    (106) neuralarith -> . REST
    (121) empty -> .

    PLUS            shift and go to state 129
    REST            shift and go to state 130
    GREATER         reduce using rule 121 (empty -> .)
    GREATERAND      reduce using rule 121 (empty -> .)
    LESSER          reduce using rule 121 (empty -> .)
    LESSERAND       reduce using rule 121 (empty -> .)
    SAME            reduce using rule 121 (empty -> .)
    NOTSAME         reduce using rule 121 (empty -> .)
    NOT             reduce using rule 121 (empty -> .)
    AND             reduce using rule 121 (empty -> .)
    OR              reduce using rule 121 (empty -> .)
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    LEFTPAR         reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)
    RIGHTSQR        reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    DO              reduce using rule 121 (empty -> .)

    arithexp1                      shift and go to state 126
    neuralarith                    shift and go to state 127
    empty                          shift and go to state 128

state 75

    (107) geoexp -> finexp . geoexp1
    (108) geoexp1 -> . neuralgeo geoexp
    (109) geoexp1 -> . empty
    (110) neuralgeo -> . TIMES
    (111) neuralgeo -> . DIVIDE
    (121) empty -> .

    TIMES           shift and go to state 134
    DIVIDE          shift and go to state 135
    PLUS            reduce using rule 121 (empty -> .)
    REST            reduce using rule 121 (empty -> .)
    GREATER         reduce using rule 121 (empty -> .)
    GREATERAND      reduce using rule 121 (empty -> .)
    LESSER          reduce using rule 121 (empty -> .)
    LESSERAND       reduce using rule 121 (empty -> .)
    SAME            reduce using rule 121 (empty -> .)
    NOTSAME         reduce using rule 121 (empty -> .)
    NOT             reduce using rule 121 (empty -> .)
    AND             reduce using rule 121 (empty -> .)
    OR              reduce using rule 121 (empty -> .)
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    LEFTPAR         reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)
    RIGHTSQR        reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    DO              reduce using rule 121 (empty -> .)

    geoexp1                        shift and go to state 131
    neuralgeo                      shift and go to state 132
    empty                          shift and go to state 133

state 76

    (114) finexp -> addparenth . exp popparenth
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    addparenth                     shift and go to state 76
    exp                            shift and go to state 136
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    cteexp                         shift and go to state 77

state 77

    (115) finexp -> cteexp .

    TIMES           reduce using rule 115 (finexp -> cteexp .)
    DIVIDE          reduce using rule 115 (finexp -> cteexp .)
    PLUS            reduce using rule 115 (finexp -> cteexp .)
    REST            reduce using rule 115 (finexp -> cteexp .)
    GREATER         reduce using rule 115 (finexp -> cteexp .)
    GREATERAND      reduce using rule 115 (finexp -> cteexp .)
    LESSER          reduce using rule 115 (finexp -> cteexp .)
    LESSERAND       reduce using rule 115 (finexp -> cteexp .)
    SAME            reduce using rule 115 (finexp -> cteexp .)
    NOTSAME         reduce using rule 115 (finexp -> cteexp .)
    NOT             reduce using rule 115 (finexp -> cteexp .)
    AND             reduce using rule 115 (finexp -> cteexp .)
    OR              reduce using rule 115 (finexp -> cteexp .)
    READ            reduce using rule 115 (finexp -> cteexp .)
    WRITE           reduce using rule 115 (finexp -> cteexp .)
    RETURN          reduce using rule 115 (finexp -> cteexp .)
    IF              reduce using rule 115 (finexp -> cteexp .)
    FOR             reduce using rule 115 (finexp -> cteexp .)
    ID              reduce using rule 115 (finexp -> cteexp .)
    WHILE           reduce using rule 115 (finexp -> cteexp .)
    LEFTPAR         reduce using rule 115 (finexp -> cteexp .)
    CTEINT          reduce using rule 115 (finexp -> cteexp .)
    CTEFLOAT        reduce using rule 115 (finexp -> cteexp .)
    CTECHAR         reduce using rule 115 (finexp -> cteexp .)
    RIGHTBR         reduce using rule 115 (finexp -> cteexp .)
    RIGHTPAR        reduce using rule 115 (finexp -> cteexp .)
    RIGHTSQR        reduce using rule 115 (finexp -> cteexp .)
    COMMA           reduce using rule 115 (finexp -> cteexp .)
    SEMICOLON       reduce using rule 115 (finexp -> cteexp .)
    TO              reduce using rule 115 (finexp -> cteexp .)
    DO              reduce using rule 115 (finexp -> cteexp .)


state 78

    (116) cteexp -> CTEINT .

    TIMES           reduce using rule 116 (cteexp -> CTEINT .)
    DIVIDE          reduce using rule 116 (cteexp -> CTEINT .)
    PLUS            reduce using rule 116 (cteexp -> CTEINT .)
    REST            reduce using rule 116 (cteexp -> CTEINT .)
    GREATER         reduce using rule 116 (cteexp -> CTEINT .)
    GREATERAND      reduce using rule 116 (cteexp -> CTEINT .)
    LESSER          reduce using rule 116 (cteexp -> CTEINT .)
    LESSERAND       reduce using rule 116 (cteexp -> CTEINT .)
    SAME            reduce using rule 116 (cteexp -> CTEINT .)
    NOTSAME         reduce using rule 116 (cteexp -> CTEINT .)
    NOT             reduce using rule 116 (cteexp -> CTEINT .)
    AND             reduce using rule 116 (cteexp -> CTEINT .)
    OR              reduce using rule 116 (cteexp -> CTEINT .)
    READ            reduce using rule 116 (cteexp -> CTEINT .)
    WRITE           reduce using rule 116 (cteexp -> CTEINT .)
    RETURN          reduce using rule 116 (cteexp -> CTEINT .)
    IF              reduce using rule 116 (cteexp -> CTEINT .)
    FOR             reduce using rule 116 (cteexp -> CTEINT .)
    ID              reduce using rule 116 (cteexp -> CTEINT .)
    WHILE           reduce using rule 116 (cteexp -> CTEINT .)
    LEFTPAR         reduce using rule 116 (cteexp -> CTEINT .)
    CTEINT          reduce using rule 116 (cteexp -> CTEINT .)
    CTEFLOAT        reduce using rule 116 (cteexp -> CTEINT .)
    CTECHAR         reduce using rule 116 (cteexp -> CTEINT .)
    RIGHTBR         reduce using rule 116 (cteexp -> CTEINT .)
    RIGHTPAR        reduce using rule 116 (cteexp -> CTEINT .)
    RIGHTSQR        reduce using rule 116 (cteexp -> CTEINT .)
    COMMA           reduce using rule 116 (cteexp -> CTEINT .)
    SEMICOLON       reduce using rule 116 (cteexp -> CTEINT .)
    TO              reduce using rule 116 (cteexp -> CTEINT .)
    DO              reduce using rule 116 (cteexp -> CTEINT .)


state 79

    (117) cteexp -> CTEFLOAT .

    TIMES           reduce using rule 117 (cteexp -> CTEFLOAT .)
    DIVIDE          reduce using rule 117 (cteexp -> CTEFLOAT .)
    PLUS            reduce using rule 117 (cteexp -> CTEFLOAT .)
    REST            reduce using rule 117 (cteexp -> CTEFLOAT .)
    GREATER         reduce using rule 117 (cteexp -> CTEFLOAT .)
    GREATERAND      reduce using rule 117 (cteexp -> CTEFLOAT .)
    LESSER          reduce using rule 117 (cteexp -> CTEFLOAT .)
    LESSERAND       reduce using rule 117 (cteexp -> CTEFLOAT .)
    SAME            reduce using rule 117 (cteexp -> CTEFLOAT .)
    NOTSAME         reduce using rule 117 (cteexp -> CTEFLOAT .)
    NOT             reduce using rule 117 (cteexp -> CTEFLOAT .)
    AND             reduce using rule 117 (cteexp -> CTEFLOAT .)
    OR              reduce using rule 117 (cteexp -> CTEFLOAT .)
    READ            reduce using rule 117 (cteexp -> CTEFLOAT .)
    WRITE           reduce using rule 117 (cteexp -> CTEFLOAT .)
    RETURN          reduce using rule 117 (cteexp -> CTEFLOAT .)
    IF              reduce using rule 117 (cteexp -> CTEFLOAT .)
    FOR             reduce using rule 117 (cteexp -> CTEFLOAT .)
    ID              reduce using rule 117 (cteexp -> CTEFLOAT .)
    WHILE           reduce using rule 117 (cteexp -> CTEFLOAT .)
    LEFTPAR         reduce using rule 117 (cteexp -> CTEFLOAT .)
    CTEINT          reduce using rule 117 (cteexp -> CTEFLOAT .)
    CTEFLOAT        reduce using rule 117 (cteexp -> CTEFLOAT .)
    CTECHAR         reduce using rule 117 (cteexp -> CTEFLOAT .)
    RIGHTBR         reduce using rule 117 (cteexp -> CTEFLOAT .)
    RIGHTPAR        reduce using rule 117 (cteexp -> CTEFLOAT .)
    RIGHTSQR        reduce using rule 117 (cteexp -> CTEFLOAT .)
    COMMA           reduce using rule 117 (cteexp -> CTEFLOAT .)
    SEMICOLON       reduce using rule 117 (cteexp -> CTEFLOAT .)
    TO              reduce using rule 117 (cteexp -> CTEFLOAT .)
    DO              reduce using rule 117 (cteexp -> CTEFLOAT .)


state 80

    (118) cteexp -> CTECHAR .

    TIMES           reduce using rule 118 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 118 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 118 (cteexp -> CTECHAR .)
    REST            reduce using rule 118 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 118 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 118 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 118 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 118 (cteexp -> CTECHAR .)
    SAME            reduce using rule 118 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 118 (cteexp -> CTECHAR .)
    NOT             reduce using rule 118 (cteexp -> CTECHAR .)
    AND             reduce using rule 118 (cteexp -> CTECHAR .)
    OR              reduce using rule 118 (cteexp -> CTECHAR .)
    READ            reduce using rule 118 (cteexp -> CTECHAR .)
    WRITE           reduce using rule 118 (cteexp -> CTECHAR .)
    RETURN          reduce using rule 118 (cteexp -> CTECHAR .)
    IF              reduce using rule 118 (cteexp -> CTECHAR .)
    FOR             reduce using rule 118 (cteexp -> CTECHAR .)
    ID              reduce using rule 118 (cteexp -> CTECHAR .)
    WHILE           reduce using rule 118 (cteexp -> CTECHAR .)
    LEFTPAR         reduce using rule 118 (cteexp -> CTECHAR .)
    CTEINT          reduce using rule 118 (cteexp -> CTECHAR .)
    CTEFLOAT        reduce using rule 118 (cteexp -> CTECHAR .)
    CTECHAR         reduce using rule 118 (cteexp -> CTECHAR .)
    RIGHTBR         reduce using rule 118 (cteexp -> CTECHAR .)
    RIGHTPAR        reduce using rule 118 (cteexp -> CTECHAR .)
    RIGHTSQR        reduce using rule 118 (cteexp -> CTECHAR .)
    COMMA           reduce using rule 118 (cteexp -> CTECHAR .)
    SEMICOLON       reduce using rule 118 (cteexp -> CTECHAR .)
    TO              reduce using rule 118 (cteexp -> CTECHAR .)
    DO              reduce using rule 118 (cteexp -> CTECHAR .)


state 81

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON . varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules
    (4) varsgl -> . VARS vars
    (5) varsgl -> . empty
    (121) empty -> .

    VARS            shift and go to state 7
    LEFTBR          reduce using rule 121 (empty -> .)

    varsgl                         shift and go to state 138
    empty                          shift and go to state 8

state 82

    (31) parameters -> typing COLON neuralinsertid . idarray mulparams
    (15) idarray -> . initarray exp verify RIGHTSQR
    (16) idarray -> . empty
    (17) initarray -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 100
    COMMA           reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)

    idarray                        shift and go to state 139
    initarray                      shift and go to state 98
    empty                          shift and go to state 99

state 83

    (33) neuralinsertid -> ID .

    LEFTSQR         reduce using rule 33 (neuralinsertid -> ID .)
    COMMA           reduce using rule 33 (neuralinsertid -> ID .)
    RIGHTPAR        reduce using rule 33 (neuralinsertid -> ID .)


state 84

    (9) varsmul -> COMMA neuralinsertvar varsarr . varsmul
    (9) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (10) varsmul -> . SEMICOLON

    COMMA           shift and go to state 40
    SEMICOLON       shift and go to state 41

    varsmul                        shift and go to state 140

state 85

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR .

    $end            reduce using rule 1 (program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR .)


state 86

    (46) statutes -> assign statutesaux .

    RIGHTBR         reduce using rule 46 (statutes -> assign statutesaux .)


state 87

    (55) statutesaux -> statutes .

    RIGHTBR         reduce using rule 55 (statutesaux -> statutes .)


state 88

    (56) statutesaux -> empty .
    (57) specialfunc -> empty .

  ! reduce/reduce conflict for RIGHTBR resolved using rule 56 (statutesaux -> empty .)
    RIGHTBR         reduce using rule 56 (statutesaux -> empty .)
    READ            reduce using rule 57 (specialfunc -> empty .)
    WRITE           reduce using rule 57 (specialfunc -> empty .)
    RETURN          reduce using rule 57 (specialfunc -> empty .)
    IF              reduce using rule 57 (specialfunc -> empty .)
    FOR             reduce using rule 57 (specialfunc -> empty .)
    ID              reduce using rule 57 (specialfunc -> empty .)
    WHILE           reduce using rule 57 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 57 (specialfunc -> empty .)
    CTEINT          reduce using rule 57 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 57 (specialfunc -> empty .)
    CTECHAR         reduce using rule 57 (specialfunc -> empty .)

  ! RIGHTBR         [ reduce using rule 57 (specialfunc -> empty .) ]


state 89

    (47) statutes -> reading statutesaux .

    RIGHTBR         reduce using rule 47 (statutes -> reading statutesaux .)


state 90

    (48) statutes -> writing statutesaux .

    RIGHTBR         reduce using rule 48 (statutes -> writing statutesaux .)


state 91

    (49) statutes -> returning statutesaux .

    RIGHTBR         reduce using rule 49 (statutes -> returning statutesaux .)


state 92

    (50) statutes -> ifing statutesaux .

    RIGHTBR         reduce using rule 50 (statutes -> ifing statutesaux .)


state 93

    (51) statutes -> whiling statutesaux .

    RIGHTBR         reduce using rule 51 (statutes -> whiling statutesaux .)


state 94

    (52) statutes -> foring statutesaux .

    RIGHTBR         reduce using rule 52 (statutes -> foring statutesaux .)


state 95

    (53) statutes -> exp statutesaux .

    RIGHTBR         reduce using rule 53 (statutes -> exp statutesaux .)


state 96

    (54) statutes -> specialfunc statutesaux .

    RIGHTBR         reduce using rule 54 (statutes -> specialfunc statutesaux .)


state 97

    (58) assign -> neuralassign1 idarray . neuralassign2 assignexp SEMICOLON
    (60) neuralassign2 -> . EQUAL

    EQUAL           shift and go to state 142

    neuralassign2                  shift and go to state 141

state 98

    (15) idarray -> initarray . exp verify RIGHTSQR
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 143
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 99

    (16) idarray -> empty .

    EQUAL           reduce using rule 16 (idarray -> empty .)
    COMMA           reduce using rule 16 (idarray -> empty .)
    RIGHTPAR        reduce using rule 16 (idarray -> empty .)
    TIMES           reduce using rule 16 (idarray -> empty .)
    DIVIDE          reduce using rule 16 (idarray -> empty .)
    PLUS            reduce using rule 16 (idarray -> empty .)
    REST            reduce using rule 16 (idarray -> empty .)
    GREATER         reduce using rule 16 (idarray -> empty .)
    GREATERAND      reduce using rule 16 (idarray -> empty .)
    LESSER          reduce using rule 16 (idarray -> empty .)
    LESSERAND       reduce using rule 16 (idarray -> empty .)
    SAME            reduce using rule 16 (idarray -> empty .)
    NOTSAME         reduce using rule 16 (idarray -> empty .)
    NOT             reduce using rule 16 (idarray -> empty .)
    AND             reduce using rule 16 (idarray -> empty .)
    OR              reduce using rule 16 (idarray -> empty .)
    READ            reduce using rule 16 (idarray -> empty .)
    WRITE           reduce using rule 16 (idarray -> empty .)
    RETURN          reduce using rule 16 (idarray -> empty .)
    IF              reduce using rule 16 (idarray -> empty .)
    FOR             reduce using rule 16 (idarray -> empty .)
    ID              reduce using rule 16 (idarray -> empty .)
    WHILE           reduce using rule 16 (idarray -> empty .)
    LEFTPAR         reduce using rule 16 (idarray -> empty .)
    CTEINT          reduce using rule 16 (idarray -> empty .)
    CTEFLOAT        reduce using rule 16 (idarray -> empty .)
    CTECHAR         reduce using rule 16 (idarray -> empty .)
    RIGHTBR         reduce using rule 16 (idarray -> empty .)
    RIGHTSQR        reduce using rule 16 (idarray -> empty .)
    SEMICOLON       reduce using rule 16 (idarray -> empty .)
    TO              reduce using rule 16 (idarray -> empty .)
    DO              reduce using rule 16 (idarray -> empty .)


state 100

    (17) initarray -> LEFTSQR .

    LEFTPAR         reduce using rule 17 (initarray -> LEFTSQR .)
    CTEINT          reduce using rule 17 (initarray -> LEFTSQR .)
    CTEFLOAT        reduce using rule 17 (initarray -> LEFTSQR .)
    CTECHAR         reduce using rule 17 (initarray -> LEFTSQR .)
    ID              reduce using rule 17 (initarray -> LEFTSQR .)


state 101

    (69) reading -> READ LEFTPAR . neuralread idarray mulread RIGHTPAR SEMICOLON
    (70) neuralread -> . ID

    ID              shift and go to state 145

    neuralread                     shift and go to state 144

state 102

    (62) writing -> WRITE LEFTPAR . auxwrite mulwrite RIGHTPAR SEMICOLON
    (63) auxwrite -> . writetyping
    (64) auxwrite -> . exp
    (65) writetyping -> . STRING
    (66) writetyping -> . CTECHAR
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    STRING          shift and go to state 149
    CTECHAR         shift and go to state 150
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    ID              shift and go to state 137

    auxwrite                       shift and go to state 146
    writetyping                    shift and go to state 147
    exp                            shift and go to state 148
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 103

    (36) returning -> RETURN LEFTPAR . exp RIGHTPAR SEMICOLON
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 151
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 104

    (73) ifing -> IF LEFTPAR . exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 152
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 105

    (78) whiling -> neuralwhile1 LEFTPAR . exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 153
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 106

    (81) foring -> FOR neuralfor1 . idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (15) idarray -> . initarray exp verify RIGHTSQR
    (16) idarray -> . empty
    (17) initarray -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 100
    EQUAL           reduce using rule 121 (empty -> .)

    idarray                        shift and go to state 154
    initarray                      shift and go to state 98
    empty                          shift and go to state 99

state 107

    (82) neuralfor1 -> ID .

    LEFTSQR         reduce using rule 82 (neuralfor1 -> ID .)
    EQUAL           reduce using rule 82 (neuralfor1 -> ID .)


state 108

    (85) exp -> andexp exp1 .

    READ            reduce using rule 85 (exp -> andexp exp1 .)
    WRITE           reduce using rule 85 (exp -> andexp exp1 .)
    RETURN          reduce using rule 85 (exp -> andexp exp1 .)
    IF              reduce using rule 85 (exp -> andexp exp1 .)
    FOR             reduce using rule 85 (exp -> andexp exp1 .)
    ID              reduce using rule 85 (exp -> andexp exp1 .)
    WHILE           reduce using rule 85 (exp -> andexp exp1 .)
    LEFTPAR         reduce using rule 85 (exp -> andexp exp1 .)
    CTEINT          reduce using rule 85 (exp -> andexp exp1 .)
    CTEFLOAT        reduce using rule 85 (exp -> andexp exp1 .)
    CTECHAR         reduce using rule 85 (exp -> andexp exp1 .)
    RIGHTBR         reduce using rule 85 (exp -> andexp exp1 .)
    RIGHTPAR        reduce using rule 85 (exp -> andexp exp1 .)
    RIGHTSQR        reduce using rule 85 (exp -> andexp exp1 .)
    COMMA           reduce using rule 85 (exp -> andexp exp1 .)
    SEMICOLON       reduce using rule 85 (exp -> andexp exp1 .)
    TO              reduce using rule 85 (exp -> andexp exp1 .)
    DO              reduce using rule 85 (exp -> andexp exp1 .)


state 109

    (86) exp1 -> OR . exp
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 155
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 110

    (87) exp1 -> empty .

    READ            reduce using rule 87 (exp1 -> empty .)
    WRITE           reduce using rule 87 (exp1 -> empty .)
    RETURN          reduce using rule 87 (exp1 -> empty .)
    IF              reduce using rule 87 (exp1 -> empty .)
    FOR             reduce using rule 87 (exp1 -> empty .)
    ID              reduce using rule 87 (exp1 -> empty .)
    WHILE           reduce using rule 87 (exp1 -> empty .)
    LEFTPAR         reduce using rule 87 (exp1 -> empty .)
    CTEINT          reduce using rule 87 (exp1 -> empty .)
    CTEFLOAT        reduce using rule 87 (exp1 -> empty .)
    CTECHAR         reduce using rule 87 (exp1 -> empty .)
    RIGHTBR         reduce using rule 87 (exp1 -> empty .)
    RIGHTPAR        reduce using rule 87 (exp1 -> empty .)
    RIGHTSQR        reduce using rule 87 (exp1 -> empty .)
    COMMA           reduce using rule 87 (exp1 -> empty .)
    SEMICOLON       reduce using rule 87 (exp1 -> empty .)
    TO              reduce using rule 87 (exp1 -> empty .)
    DO              reduce using rule 87 (exp1 -> empty .)


state 111

    (119) cteexp -> ID neuralexist . paramsexp
    (37) paramsexp -> . LEFTPAR neuralera paramsexp2 neuralpar
    (38) paramsexp -> . idarray
    (15) idarray -> . initarray exp verify RIGHTSQR
    (16) idarray -> . empty
    (17) initarray -> . LEFTSQR
    (121) empty -> .

  ! shift/reduce conflict for LEFTPAR resolved as shift
    LEFTPAR         shift and go to state 157
    LEFTSQR         shift and go to state 100
    TIMES           reduce using rule 121 (empty -> .)
    DIVIDE          reduce using rule 121 (empty -> .)
    PLUS            reduce using rule 121 (empty -> .)
    REST            reduce using rule 121 (empty -> .)
    GREATER         reduce using rule 121 (empty -> .)
    GREATERAND      reduce using rule 121 (empty -> .)
    LESSER          reduce using rule 121 (empty -> .)
    LESSERAND       reduce using rule 121 (empty -> .)
    SAME            reduce using rule 121 (empty -> .)
    NOTSAME         reduce using rule 121 (empty -> .)
    NOT             reduce using rule 121 (empty -> .)
    AND             reduce using rule 121 (empty -> .)
    OR              reduce using rule 121 (empty -> .)
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)
    RIGHTSQR        reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    DO              reduce using rule 121 (empty -> .)

  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]

    paramsexp                      shift and go to state 156
    idarray                        shift and go to state 158
    initarray                      shift and go to state 98
    empty                          shift and go to state 99

state 112

    (88) andexp -> boolexp andexp1 .

    OR              reduce using rule 88 (andexp -> boolexp andexp1 .)
    READ            reduce using rule 88 (andexp -> boolexp andexp1 .)
    WRITE           reduce using rule 88 (andexp -> boolexp andexp1 .)
    RETURN          reduce using rule 88 (andexp -> boolexp andexp1 .)
    IF              reduce using rule 88 (andexp -> boolexp andexp1 .)
    FOR             reduce using rule 88 (andexp -> boolexp andexp1 .)
    ID              reduce using rule 88 (andexp -> boolexp andexp1 .)
    WHILE           reduce using rule 88 (andexp -> boolexp andexp1 .)
    LEFTPAR         reduce using rule 88 (andexp -> boolexp andexp1 .)
    CTEINT          reduce using rule 88 (andexp -> boolexp andexp1 .)
    CTEFLOAT        reduce using rule 88 (andexp -> boolexp andexp1 .)
    CTECHAR         reduce using rule 88 (andexp -> boolexp andexp1 .)
    RIGHTBR         reduce using rule 88 (andexp -> boolexp andexp1 .)
    RIGHTPAR        reduce using rule 88 (andexp -> boolexp andexp1 .)
    RIGHTSQR        reduce using rule 88 (andexp -> boolexp andexp1 .)
    COMMA           reduce using rule 88 (andexp -> boolexp andexp1 .)
    SEMICOLON       reduce using rule 88 (andexp -> boolexp andexp1 .)
    TO              reduce using rule 88 (andexp -> boolexp andexp1 .)
    DO              reduce using rule 88 (andexp -> boolexp andexp1 .)


state 113

    (89) andexp1 -> neuraland . andexp
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    andexp                         shift and go to state 159
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 114

    (90) andexp1 -> empty .

    OR              reduce using rule 90 (andexp1 -> empty .)
    READ            reduce using rule 90 (andexp1 -> empty .)
    WRITE           reduce using rule 90 (andexp1 -> empty .)
    RETURN          reduce using rule 90 (andexp1 -> empty .)
    IF              reduce using rule 90 (andexp1 -> empty .)
    FOR             reduce using rule 90 (andexp1 -> empty .)
    ID              reduce using rule 90 (andexp1 -> empty .)
    WHILE           reduce using rule 90 (andexp1 -> empty .)
    LEFTPAR         reduce using rule 90 (andexp1 -> empty .)
    CTEINT          reduce using rule 90 (andexp1 -> empty .)
    CTEFLOAT        reduce using rule 90 (andexp1 -> empty .)
    CTECHAR         reduce using rule 90 (andexp1 -> empty .)
    RIGHTBR         reduce using rule 90 (andexp1 -> empty .)
    RIGHTPAR        reduce using rule 90 (andexp1 -> empty .)
    RIGHTSQR        reduce using rule 90 (andexp1 -> empty .)
    COMMA           reduce using rule 90 (andexp1 -> empty .)
    SEMICOLON       reduce using rule 90 (andexp1 -> empty .)
    TO              reduce using rule 90 (andexp1 -> empty .)
    DO              reduce using rule 90 (andexp1 -> empty .)


state 115

    (91) neuraland -> AND .

    LEFTPAR         reduce using rule 91 (neuraland -> AND .)
    CTEINT          reduce using rule 91 (neuraland -> AND .)
    CTEFLOAT        reduce using rule 91 (neuraland -> AND .)
    CTECHAR         reduce using rule 91 (neuraland -> AND .)
    ID              reduce using rule 91 (neuraland -> AND .)


state 116

    (92) boolexp -> arithexp boolexp1 .

    AND             reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    OR              reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    READ            reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    WRITE           reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    RETURN          reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    IF              reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    FOR             reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    ID              reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    WHILE           reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    LEFTPAR         reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    CTEINT          reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    CTEFLOAT        reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    CTECHAR         reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    RIGHTBR         reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    RIGHTPAR        reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    RIGHTSQR        reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    COMMA           reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    SEMICOLON       reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    TO              reduce using rule 92 (boolexp -> arithexp boolexp1 .)
    DO              reduce using rule 92 (boolexp -> arithexp boolexp1 .)


state 117

    (93) boolexp1 -> neuralbool . arithexp
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    arithexp                       shift and go to state 160
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 118

    (94) boolexp1 -> empty .

    AND             reduce using rule 94 (boolexp1 -> empty .)
    OR              reduce using rule 94 (boolexp1 -> empty .)
    READ            reduce using rule 94 (boolexp1 -> empty .)
    WRITE           reduce using rule 94 (boolexp1 -> empty .)
    RETURN          reduce using rule 94 (boolexp1 -> empty .)
    IF              reduce using rule 94 (boolexp1 -> empty .)
    FOR             reduce using rule 94 (boolexp1 -> empty .)
    ID              reduce using rule 94 (boolexp1 -> empty .)
    WHILE           reduce using rule 94 (boolexp1 -> empty .)
    LEFTPAR         reduce using rule 94 (boolexp1 -> empty .)
    CTEINT          reduce using rule 94 (boolexp1 -> empty .)
    CTEFLOAT        reduce using rule 94 (boolexp1 -> empty .)
    CTECHAR         reduce using rule 94 (boolexp1 -> empty .)
    RIGHTBR         reduce using rule 94 (boolexp1 -> empty .)
    RIGHTPAR        reduce using rule 94 (boolexp1 -> empty .)
    RIGHTSQR        reduce using rule 94 (boolexp1 -> empty .)
    COMMA           reduce using rule 94 (boolexp1 -> empty .)
    SEMICOLON       reduce using rule 94 (boolexp1 -> empty .)
    TO              reduce using rule 94 (boolexp1 -> empty .)
    DO              reduce using rule 94 (boolexp1 -> empty .)


state 119

    (95) neuralbool -> GREATER .

    LEFTPAR         reduce using rule 95 (neuralbool -> GREATER .)
    CTEINT          reduce using rule 95 (neuralbool -> GREATER .)
    CTEFLOAT        reduce using rule 95 (neuralbool -> GREATER .)
    CTECHAR         reduce using rule 95 (neuralbool -> GREATER .)
    ID              reduce using rule 95 (neuralbool -> GREATER .)


state 120

    (96) neuralbool -> GREATERAND .

    LEFTPAR         reduce using rule 96 (neuralbool -> GREATERAND .)
    CTEINT          reduce using rule 96 (neuralbool -> GREATERAND .)
    CTEFLOAT        reduce using rule 96 (neuralbool -> GREATERAND .)
    CTECHAR         reduce using rule 96 (neuralbool -> GREATERAND .)
    ID              reduce using rule 96 (neuralbool -> GREATERAND .)


state 121

    (97) neuralbool -> LESSER .

    LEFTPAR         reduce using rule 97 (neuralbool -> LESSER .)
    CTEINT          reduce using rule 97 (neuralbool -> LESSER .)
    CTEFLOAT        reduce using rule 97 (neuralbool -> LESSER .)
    CTECHAR         reduce using rule 97 (neuralbool -> LESSER .)
    ID              reduce using rule 97 (neuralbool -> LESSER .)


state 122

    (98) neuralbool -> LESSERAND .

    LEFTPAR         reduce using rule 98 (neuralbool -> LESSERAND .)
    CTEINT          reduce using rule 98 (neuralbool -> LESSERAND .)
    CTEFLOAT        reduce using rule 98 (neuralbool -> LESSERAND .)
    CTECHAR         reduce using rule 98 (neuralbool -> LESSERAND .)
    ID              reduce using rule 98 (neuralbool -> LESSERAND .)


state 123

    (99) neuralbool -> SAME .

    LEFTPAR         reduce using rule 99 (neuralbool -> SAME .)
    CTEINT          reduce using rule 99 (neuralbool -> SAME .)
    CTEFLOAT        reduce using rule 99 (neuralbool -> SAME .)
    CTECHAR         reduce using rule 99 (neuralbool -> SAME .)
    ID              reduce using rule 99 (neuralbool -> SAME .)


state 124

    (100) neuralbool -> NOTSAME .

    LEFTPAR         reduce using rule 100 (neuralbool -> NOTSAME .)
    CTEINT          reduce using rule 100 (neuralbool -> NOTSAME .)
    CTEFLOAT        reduce using rule 100 (neuralbool -> NOTSAME .)
    CTECHAR         reduce using rule 100 (neuralbool -> NOTSAME .)
    ID              reduce using rule 100 (neuralbool -> NOTSAME .)


state 125

    (101) neuralbool -> NOT .

    LEFTPAR         reduce using rule 101 (neuralbool -> NOT .)
    CTEINT          reduce using rule 101 (neuralbool -> NOT .)
    CTEFLOAT        reduce using rule 101 (neuralbool -> NOT .)
    CTECHAR         reduce using rule 101 (neuralbool -> NOT .)
    ID              reduce using rule 101 (neuralbool -> NOT .)


state 126

    (102) arithexp -> geoexp arithexp1 .

    GREATER         reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    GREATERAND      reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    LESSER          reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    LESSERAND       reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    SAME            reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    NOTSAME         reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    NOT             reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    AND             reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    OR              reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    READ            reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    WRITE           reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    RETURN          reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    IF              reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    FOR             reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    ID              reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    WHILE           reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    LEFTPAR         reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    CTEINT          reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    CTEFLOAT        reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    CTECHAR         reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    RIGHTBR         reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    RIGHTPAR        reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    RIGHTSQR        reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    COMMA           reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    SEMICOLON       reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    TO              reduce using rule 102 (arithexp -> geoexp arithexp1 .)
    DO              reduce using rule 102 (arithexp -> geoexp arithexp1 .)


state 127

    (103) arithexp1 -> neuralarith . arithexp
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    arithexp                       shift and go to state 161
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 128

    (104) arithexp1 -> empty .

    GREATER         reduce using rule 104 (arithexp1 -> empty .)
    GREATERAND      reduce using rule 104 (arithexp1 -> empty .)
    LESSER          reduce using rule 104 (arithexp1 -> empty .)
    LESSERAND       reduce using rule 104 (arithexp1 -> empty .)
    SAME            reduce using rule 104 (arithexp1 -> empty .)
    NOTSAME         reduce using rule 104 (arithexp1 -> empty .)
    NOT             reduce using rule 104 (arithexp1 -> empty .)
    AND             reduce using rule 104 (arithexp1 -> empty .)
    OR              reduce using rule 104 (arithexp1 -> empty .)
    READ            reduce using rule 104 (arithexp1 -> empty .)
    WRITE           reduce using rule 104 (arithexp1 -> empty .)
    RETURN          reduce using rule 104 (arithexp1 -> empty .)
    IF              reduce using rule 104 (arithexp1 -> empty .)
    FOR             reduce using rule 104 (arithexp1 -> empty .)
    ID              reduce using rule 104 (arithexp1 -> empty .)
    WHILE           reduce using rule 104 (arithexp1 -> empty .)
    LEFTPAR         reduce using rule 104 (arithexp1 -> empty .)
    CTEINT          reduce using rule 104 (arithexp1 -> empty .)
    CTEFLOAT        reduce using rule 104 (arithexp1 -> empty .)
    CTECHAR         reduce using rule 104 (arithexp1 -> empty .)
    RIGHTBR         reduce using rule 104 (arithexp1 -> empty .)
    RIGHTPAR        reduce using rule 104 (arithexp1 -> empty .)
    RIGHTSQR        reduce using rule 104 (arithexp1 -> empty .)
    COMMA           reduce using rule 104 (arithexp1 -> empty .)
    SEMICOLON       reduce using rule 104 (arithexp1 -> empty .)
    TO              reduce using rule 104 (arithexp1 -> empty .)
    DO              reduce using rule 104 (arithexp1 -> empty .)


state 129

    (105) neuralarith -> PLUS .

    LEFTPAR         reduce using rule 105 (neuralarith -> PLUS .)
    CTEINT          reduce using rule 105 (neuralarith -> PLUS .)
    CTEFLOAT        reduce using rule 105 (neuralarith -> PLUS .)
    CTECHAR         reduce using rule 105 (neuralarith -> PLUS .)
    ID              reduce using rule 105 (neuralarith -> PLUS .)


state 130

    (106) neuralarith -> REST .

    LEFTPAR         reduce using rule 106 (neuralarith -> REST .)
    CTEINT          reduce using rule 106 (neuralarith -> REST .)
    CTEFLOAT        reduce using rule 106 (neuralarith -> REST .)
    CTECHAR         reduce using rule 106 (neuralarith -> REST .)
    ID              reduce using rule 106 (neuralarith -> REST .)


state 131

    (107) geoexp -> finexp geoexp1 .

    PLUS            reduce using rule 107 (geoexp -> finexp geoexp1 .)
    REST            reduce using rule 107 (geoexp -> finexp geoexp1 .)
    GREATER         reduce using rule 107 (geoexp -> finexp geoexp1 .)
    GREATERAND      reduce using rule 107 (geoexp -> finexp geoexp1 .)
    LESSER          reduce using rule 107 (geoexp -> finexp geoexp1 .)
    LESSERAND       reduce using rule 107 (geoexp -> finexp geoexp1 .)
    SAME            reduce using rule 107 (geoexp -> finexp geoexp1 .)
    NOTSAME         reduce using rule 107 (geoexp -> finexp geoexp1 .)
    NOT             reduce using rule 107 (geoexp -> finexp geoexp1 .)
    AND             reduce using rule 107 (geoexp -> finexp geoexp1 .)
    OR              reduce using rule 107 (geoexp -> finexp geoexp1 .)
    READ            reduce using rule 107 (geoexp -> finexp geoexp1 .)
    WRITE           reduce using rule 107 (geoexp -> finexp geoexp1 .)
    RETURN          reduce using rule 107 (geoexp -> finexp geoexp1 .)
    IF              reduce using rule 107 (geoexp -> finexp geoexp1 .)
    FOR             reduce using rule 107 (geoexp -> finexp geoexp1 .)
    ID              reduce using rule 107 (geoexp -> finexp geoexp1 .)
    WHILE           reduce using rule 107 (geoexp -> finexp geoexp1 .)
    LEFTPAR         reduce using rule 107 (geoexp -> finexp geoexp1 .)
    CTEINT          reduce using rule 107 (geoexp -> finexp geoexp1 .)
    CTEFLOAT        reduce using rule 107 (geoexp -> finexp geoexp1 .)
    CTECHAR         reduce using rule 107 (geoexp -> finexp geoexp1 .)
    RIGHTBR         reduce using rule 107 (geoexp -> finexp geoexp1 .)
    RIGHTPAR        reduce using rule 107 (geoexp -> finexp geoexp1 .)
    RIGHTSQR        reduce using rule 107 (geoexp -> finexp geoexp1 .)
    COMMA           reduce using rule 107 (geoexp -> finexp geoexp1 .)
    SEMICOLON       reduce using rule 107 (geoexp -> finexp geoexp1 .)
    TO              reduce using rule 107 (geoexp -> finexp geoexp1 .)
    DO              reduce using rule 107 (geoexp -> finexp geoexp1 .)


state 132

    (108) geoexp1 -> neuralgeo . geoexp
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    geoexp                         shift and go to state 162
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 133

    (109) geoexp1 -> empty .

    PLUS            reduce using rule 109 (geoexp1 -> empty .)
    REST            reduce using rule 109 (geoexp1 -> empty .)
    GREATER         reduce using rule 109 (geoexp1 -> empty .)
    GREATERAND      reduce using rule 109 (geoexp1 -> empty .)
    LESSER          reduce using rule 109 (geoexp1 -> empty .)
    LESSERAND       reduce using rule 109 (geoexp1 -> empty .)
    SAME            reduce using rule 109 (geoexp1 -> empty .)
    NOTSAME         reduce using rule 109 (geoexp1 -> empty .)
    NOT             reduce using rule 109 (geoexp1 -> empty .)
    AND             reduce using rule 109 (geoexp1 -> empty .)
    OR              reduce using rule 109 (geoexp1 -> empty .)
    READ            reduce using rule 109 (geoexp1 -> empty .)
    WRITE           reduce using rule 109 (geoexp1 -> empty .)
    RETURN          reduce using rule 109 (geoexp1 -> empty .)
    IF              reduce using rule 109 (geoexp1 -> empty .)
    FOR             reduce using rule 109 (geoexp1 -> empty .)
    ID              reduce using rule 109 (geoexp1 -> empty .)
    WHILE           reduce using rule 109 (geoexp1 -> empty .)
    LEFTPAR         reduce using rule 109 (geoexp1 -> empty .)
    CTEINT          reduce using rule 109 (geoexp1 -> empty .)
    CTEFLOAT        reduce using rule 109 (geoexp1 -> empty .)
    CTECHAR         reduce using rule 109 (geoexp1 -> empty .)
    RIGHTBR         reduce using rule 109 (geoexp1 -> empty .)
    RIGHTPAR        reduce using rule 109 (geoexp1 -> empty .)
    RIGHTSQR        reduce using rule 109 (geoexp1 -> empty .)
    COMMA           reduce using rule 109 (geoexp1 -> empty .)
    SEMICOLON       reduce using rule 109 (geoexp1 -> empty .)
    TO              reduce using rule 109 (geoexp1 -> empty .)
    DO              reduce using rule 109 (geoexp1 -> empty .)


state 134

    (110) neuralgeo -> TIMES .

    LEFTPAR         reduce using rule 110 (neuralgeo -> TIMES .)
    CTEINT          reduce using rule 110 (neuralgeo -> TIMES .)
    CTEFLOAT        reduce using rule 110 (neuralgeo -> TIMES .)
    CTECHAR         reduce using rule 110 (neuralgeo -> TIMES .)
    ID              reduce using rule 110 (neuralgeo -> TIMES .)


state 135

    (111) neuralgeo -> DIVIDE .

    LEFTPAR         reduce using rule 111 (neuralgeo -> DIVIDE .)
    CTEINT          reduce using rule 111 (neuralgeo -> DIVIDE .)
    CTEFLOAT        reduce using rule 111 (neuralgeo -> DIVIDE .)
    CTECHAR         reduce using rule 111 (neuralgeo -> DIVIDE .)
    ID              reduce using rule 111 (neuralgeo -> DIVIDE .)


state 136

    (114) finexp -> addparenth exp . popparenth
    (113) popparenth -> . RIGHTPAR

    RIGHTPAR        shift and go to state 164

    popparenth                     shift and go to state 163

state 137

    (119) cteexp -> ID . neuralexist paramsexp
    (120) neuralexist -> .

    LEFTPAR         reduce using rule 120 (neuralexist -> .)
    LEFTSQR         reduce using rule 120 (neuralexist -> .)
    TIMES           reduce using rule 120 (neuralexist -> .)
    DIVIDE          reduce using rule 120 (neuralexist -> .)
    PLUS            reduce using rule 120 (neuralexist -> .)
    REST            reduce using rule 120 (neuralexist -> .)
    GREATER         reduce using rule 120 (neuralexist -> .)
    GREATERAND      reduce using rule 120 (neuralexist -> .)
    LESSER          reduce using rule 120 (neuralexist -> .)
    LESSERAND       reduce using rule 120 (neuralexist -> .)
    SAME            reduce using rule 120 (neuralexist -> .)
    NOTSAME         reduce using rule 120 (neuralexist -> .)
    NOT             reduce using rule 120 (neuralexist -> .)
    AND             reduce using rule 120 (neuralexist -> .)
    OR              reduce using rule 120 (neuralexist -> .)
    RIGHTPAR        reduce using rule 120 (neuralexist -> .)
    RIGHTSQR        reduce using rule 120 (neuralexist -> .)
    COMMA           reduce using rule 120 (neuralexist -> .)
    READ            reduce using rule 120 (neuralexist -> .)
    WRITE           reduce using rule 120 (neuralexist -> .)
    RETURN          reduce using rule 120 (neuralexist -> .)
    IF              reduce using rule 120 (neuralexist -> .)
    FOR             reduce using rule 120 (neuralexist -> .)
    ID              reduce using rule 120 (neuralexist -> .)
    WHILE           reduce using rule 120 (neuralexist -> .)
    CTEINT          reduce using rule 120 (neuralexist -> .)
    CTEFLOAT        reduce using rule 120 (neuralexist -> .)
    CTECHAR         reduce using rule 120 (neuralexist -> .)
    RIGHTBR         reduce using rule 120 (neuralexist -> .)
    SEMICOLON       reduce using rule 120 (neuralexist -> .)
    TO              reduce using rule 120 (neuralexist -> .)
    DO              reduce using rule 120 (neuralexist -> .)

    neuralexist                    shift and go to state 111

state 138

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl . LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    LEFTBR          shift and go to state 165


state 139

    (31) parameters -> typing COLON neuralinsertid idarray . mulparams
    (34) mulparams -> . COMMA parameters
    (35) mulparams -> . empty
    (121) empty -> .

    COMMA           shift and go to state 167
    RIGHTPAR        reduce using rule 121 (empty -> .)

    mulparams                      shift and go to state 166
    empty                          shift and go to state 168

state 140

    (9) varsmul -> COMMA neuralinsertvar varsarr varsmul .

    INT             reduce using rule 9 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FLOAT           reduce using rule 9 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    CHAR            reduce using rule 9 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FUNCTION        reduce using rule 9 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    MAIN            reduce using rule 9 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    LEFTBR          reduce using rule 9 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)


state 141

    (58) assign -> neuralassign1 idarray neuralassign2 . assignexp SEMICOLON
    (61) assignexp -> . exp
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    assignexp                      shift and go to state 169
    exp                            shift and go to state 170
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 142

    (60) neuralassign2 -> EQUAL .

    LEFTPAR         reduce using rule 60 (neuralassign2 -> EQUAL .)
    CTEINT          reduce using rule 60 (neuralassign2 -> EQUAL .)
    CTEFLOAT        reduce using rule 60 (neuralassign2 -> EQUAL .)
    CTECHAR         reduce using rule 60 (neuralassign2 -> EQUAL .)
    ID              reduce using rule 60 (neuralassign2 -> EQUAL .)


state 143

    (15) idarray -> initarray exp . verify RIGHTSQR
    (18) verify -> .

    RIGHTSQR        reduce using rule 18 (verify -> .)

    verify                         shift and go to state 171

state 144

    (69) reading -> READ LEFTPAR neuralread . idarray mulread RIGHTPAR SEMICOLON
    (15) idarray -> . initarray exp verify RIGHTSQR
    (16) idarray -> . empty
    (17) initarray -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 100
    COMMA           reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)

    idarray                        shift and go to state 172
    initarray                      shift and go to state 98
    empty                          shift and go to state 99

state 145

    (70) neuralread -> ID .

    LEFTSQR         reduce using rule 70 (neuralread -> ID .)
    COMMA           reduce using rule 70 (neuralread -> ID .)
    RIGHTPAR        reduce using rule 70 (neuralread -> ID .)


state 146

    (62) writing -> WRITE LEFTPAR auxwrite . mulwrite RIGHTPAR SEMICOLON
    (67) mulwrite -> . COMMA auxwrite mulwrite
    (68) mulwrite -> . empty
    (121) empty -> .

    COMMA           shift and go to state 174
    RIGHTPAR        reduce using rule 121 (empty -> .)

    mulwrite                       shift and go to state 173
    empty                          shift and go to state 175

state 147

    (63) auxwrite -> writetyping .

    COMMA           reduce using rule 63 (auxwrite -> writetyping .)
    RIGHTPAR        reduce using rule 63 (auxwrite -> writetyping .)


state 148

    (64) auxwrite -> exp .

    COMMA           reduce using rule 64 (auxwrite -> exp .)
    RIGHTPAR        reduce using rule 64 (auxwrite -> exp .)


state 149

    (65) writetyping -> STRING .

    COMMA           reduce using rule 65 (writetyping -> STRING .)
    RIGHTPAR        reduce using rule 65 (writetyping -> STRING .)


state 150

    (66) writetyping -> CTECHAR .
    (118) cteexp -> CTECHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 66 (writetyping -> CTECHAR .)
  ! reduce/reduce conflict for RIGHTPAR resolved using rule 66 (writetyping -> CTECHAR .)
    COMMA           reduce using rule 66 (writetyping -> CTECHAR .)
    RIGHTPAR        reduce using rule 66 (writetyping -> CTECHAR .)
    TIMES           reduce using rule 118 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 118 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 118 (cteexp -> CTECHAR .)
    REST            reduce using rule 118 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 118 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 118 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 118 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 118 (cteexp -> CTECHAR .)
    SAME            reduce using rule 118 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 118 (cteexp -> CTECHAR .)
    NOT             reduce using rule 118 (cteexp -> CTECHAR .)
    AND             reduce using rule 118 (cteexp -> CTECHAR .)
    OR              reduce using rule 118 (cteexp -> CTECHAR .)

  ! COMMA           [ reduce using rule 118 (cteexp -> CTECHAR .) ]
  ! RIGHTPAR        [ reduce using rule 118 (cteexp -> CTECHAR .) ]


state 151

    (36) returning -> RETURN LEFTPAR exp . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 176


state 152

    (73) ifing -> IF LEFTPAR exp . neuralif THEN LEFTBR statutes RIGHTBR elsing
    (74) neuralif -> . RIGHTPAR

    RIGHTPAR        shift and go to state 178

    neuralif                       shift and go to state 177

state 153

    (78) whiling -> neuralwhile1 LEFTPAR exp . neuralwhile2 DO LEFTBR statutes RIGHTBR
    (80) neuralwhile2 -> . RIGHTPAR

    RIGHTPAR        shift and go to state 180

    neuralwhile2                   shift and go to state 179

state 154

    (81) foring -> FOR neuralfor1 idarray . EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR

    EQUAL           shift and go to state 181


state 155

    (86) exp1 -> OR exp .

    READ            reduce using rule 86 (exp1 -> OR exp .)
    WRITE           reduce using rule 86 (exp1 -> OR exp .)
    RETURN          reduce using rule 86 (exp1 -> OR exp .)
    IF              reduce using rule 86 (exp1 -> OR exp .)
    FOR             reduce using rule 86 (exp1 -> OR exp .)
    ID              reduce using rule 86 (exp1 -> OR exp .)
    WHILE           reduce using rule 86 (exp1 -> OR exp .)
    LEFTPAR         reduce using rule 86 (exp1 -> OR exp .)
    CTEINT          reduce using rule 86 (exp1 -> OR exp .)
    CTEFLOAT        reduce using rule 86 (exp1 -> OR exp .)
    CTECHAR         reduce using rule 86 (exp1 -> OR exp .)
    RIGHTBR         reduce using rule 86 (exp1 -> OR exp .)
    RIGHTPAR        reduce using rule 86 (exp1 -> OR exp .)
    RIGHTSQR        reduce using rule 86 (exp1 -> OR exp .)
    COMMA           reduce using rule 86 (exp1 -> OR exp .)
    SEMICOLON       reduce using rule 86 (exp1 -> OR exp .)
    TO              reduce using rule 86 (exp1 -> OR exp .)
    DO              reduce using rule 86 (exp1 -> OR exp .)


state 156

    (119) cteexp -> ID neuralexist paramsexp .

    TIMES           reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    DIVIDE          reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    PLUS            reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    REST            reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    GREATER         reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    GREATERAND      reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    LESSER          reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    LESSERAND       reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    SAME            reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    NOTSAME         reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    NOT             reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    AND             reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    OR              reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    READ            reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    WRITE           reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    RETURN          reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    IF              reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    FOR             reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    ID              reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    WHILE           reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    LEFTPAR         reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    CTEINT          reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    CTEFLOAT        reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    CTECHAR         reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    RIGHTBR         reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    RIGHTPAR        reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    RIGHTSQR        reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    COMMA           reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    SEMICOLON       reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    TO              reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)
    DO              reduce using rule 119 (cteexp -> ID neuralexist paramsexp .)


state 157

    (37) paramsexp -> LEFTPAR . neuralera paramsexp2 neuralpar
    (43) neuralera -> .

    LEFTPAR         reduce using rule 43 (neuralera -> .)
    CTEINT          reduce using rule 43 (neuralera -> .)
    CTEFLOAT        reduce using rule 43 (neuralera -> .)
    CTECHAR         reduce using rule 43 (neuralera -> .)
    ID              reduce using rule 43 (neuralera -> .)
    RIGHTPAR        reduce using rule 43 (neuralera -> .)

    neuralera                      shift and go to state 182

state 158

    (38) paramsexp -> idarray .

    TIMES           reduce using rule 38 (paramsexp -> idarray .)
    DIVIDE          reduce using rule 38 (paramsexp -> idarray .)
    PLUS            reduce using rule 38 (paramsexp -> idarray .)
    REST            reduce using rule 38 (paramsexp -> idarray .)
    GREATER         reduce using rule 38 (paramsexp -> idarray .)
    GREATERAND      reduce using rule 38 (paramsexp -> idarray .)
    LESSER          reduce using rule 38 (paramsexp -> idarray .)
    LESSERAND       reduce using rule 38 (paramsexp -> idarray .)
    SAME            reduce using rule 38 (paramsexp -> idarray .)
    NOTSAME         reduce using rule 38 (paramsexp -> idarray .)
    NOT             reduce using rule 38 (paramsexp -> idarray .)
    AND             reduce using rule 38 (paramsexp -> idarray .)
    OR              reduce using rule 38 (paramsexp -> idarray .)
    READ            reduce using rule 38 (paramsexp -> idarray .)
    WRITE           reduce using rule 38 (paramsexp -> idarray .)
    RETURN          reduce using rule 38 (paramsexp -> idarray .)
    IF              reduce using rule 38 (paramsexp -> idarray .)
    FOR             reduce using rule 38 (paramsexp -> idarray .)
    ID              reduce using rule 38 (paramsexp -> idarray .)
    WHILE           reduce using rule 38 (paramsexp -> idarray .)
    LEFTPAR         reduce using rule 38 (paramsexp -> idarray .)
    CTEINT          reduce using rule 38 (paramsexp -> idarray .)
    CTEFLOAT        reduce using rule 38 (paramsexp -> idarray .)
    CTECHAR         reduce using rule 38 (paramsexp -> idarray .)
    RIGHTBR         reduce using rule 38 (paramsexp -> idarray .)
    RIGHTPAR        reduce using rule 38 (paramsexp -> idarray .)
    RIGHTSQR        reduce using rule 38 (paramsexp -> idarray .)
    COMMA           reduce using rule 38 (paramsexp -> idarray .)
    SEMICOLON       reduce using rule 38 (paramsexp -> idarray .)
    TO              reduce using rule 38 (paramsexp -> idarray .)
    DO              reduce using rule 38 (paramsexp -> idarray .)


state 159

    (89) andexp1 -> neuraland andexp .

    OR              reduce using rule 89 (andexp1 -> neuraland andexp .)
    READ            reduce using rule 89 (andexp1 -> neuraland andexp .)
    WRITE           reduce using rule 89 (andexp1 -> neuraland andexp .)
    RETURN          reduce using rule 89 (andexp1 -> neuraland andexp .)
    IF              reduce using rule 89 (andexp1 -> neuraland andexp .)
    FOR             reduce using rule 89 (andexp1 -> neuraland andexp .)
    ID              reduce using rule 89 (andexp1 -> neuraland andexp .)
    WHILE           reduce using rule 89 (andexp1 -> neuraland andexp .)
    LEFTPAR         reduce using rule 89 (andexp1 -> neuraland andexp .)
    CTEINT          reduce using rule 89 (andexp1 -> neuraland andexp .)
    CTEFLOAT        reduce using rule 89 (andexp1 -> neuraland andexp .)
    CTECHAR         reduce using rule 89 (andexp1 -> neuraland andexp .)
    RIGHTBR         reduce using rule 89 (andexp1 -> neuraland andexp .)
    RIGHTPAR        reduce using rule 89 (andexp1 -> neuraland andexp .)
    RIGHTSQR        reduce using rule 89 (andexp1 -> neuraland andexp .)
    COMMA           reduce using rule 89 (andexp1 -> neuraland andexp .)
    SEMICOLON       reduce using rule 89 (andexp1 -> neuraland andexp .)
    TO              reduce using rule 89 (andexp1 -> neuraland andexp .)
    DO              reduce using rule 89 (andexp1 -> neuraland andexp .)


state 160

    (93) boolexp1 -> neuralbool arithexp .

    AND             reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    OR              reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    READ            reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    WRITE           reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    RETURN          reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    IF              reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    FOR             reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    ID              reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    WHILE           reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    LEFTPAR         reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    CTEINT          reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    CTEFLOAT        reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    CTECHAR         reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    RIGHTBR         reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    RIGHTPAR        reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    RIGHTSQR        reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    COMMA           reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    SEMICOLON       reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    TO              reduce using rule 93 (boolexp1 -> neuralbool arithexp .)
    DO              reduce using rule 93 (boolexp1 -> neuralbool arithexp .)


state 161

    (103) arithexp1 -> neuralarith arithexp .

    GREATER         reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    GREATERAND      reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    LESSER          reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    LESSERAND       reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    SAME            reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    NOTSAME         reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    NOT             reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    AND             reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    OR              reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    READ            reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    WRITE           reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    RETURN          reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    IF              reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    FOR             reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    ID              reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    WHILE           reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    LEFTPAR         reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    CTEINT          reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    CTEFLOAT        reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    CTECHAR         reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    RIGHTBR         reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    RIGHTPAR        reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    RIGHTSQR        reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    COMMA           reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    SEMICOLON       reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    TO              reduce using rule 103 (arithexp1 -> neuralarith arithexp .)
    DO              reduce using rule 103 (arithexp1 -> neuralarith arithexp .)


state 162

    (108) geoexp1 -> neuralgeo geoexp .

    PLUS            reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    REST            reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    GREATER         reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    GREATERAND      reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    LESSER          reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    LESSERAND       reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    SAME            reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    NOTSAME         reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    NOT             reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    AND             reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    OR              reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    READ            reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    WRITE           reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    RETURN          reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    IF              reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    FOR             reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    ID              reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    WHILE           reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    LEFTPAR         reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    CTEINT          reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    CTEFLOAT        reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    CTECHAR         reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    RIGHTBR         reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    RIGHTPAR        reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    RIGHTSQR        reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    COMMA           reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    SEMICOLON       reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    TO              reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)
    DO              reduce using rule 108 (geoexp1 -> neuralgeo geoexp .)


state 163

    (114) finexp -> addparenth exp popparenth .

    TIMES           reduce using rule 114 (finexp -> addparenth exp popparenth .)
    DIVIDE          reduce using rule 114 (finexp -> addparenth exp popparenth .)
    PLUS            reduce using rule 114 (finexp -> addparenth exp popparenth .)
    REST            reduce using rule 114 (finexp -> addparenth exp popparenth .)
    GREATER         reduce using rule 114 (finexp -> addparenth exp popparenth .)
    GREATERAND      reduce using rule 114 (finexp -> addparenth exp popparenth .)
    LESSER          reduce using rule 114 (finexp -> addparenth exp popparenth .)
    LESSERAND       reduce using rule 114 (finexp -> addparenth exp popparenth .)
    SAME            reduce using rule 114 (finexp -> addparenth exp popparenth .)
    NOTSAME         reduce using rule 114 (finexp -> addparenth exp popparenth .)
    NOT             reduce using rule 114 (finexp -> addparenth exp popparenth .)
    AND             reduce using rule 114 (finexp -> addparenth exp popparenth .)
    OR              reduce using rule 114 (finexp -> addparenth exp popparenth .)
    READ            reduce using rule 114 (finexp -> addparenth exp popparenth .)
    WRITE           reduce using rule 114 (finexp -> addparenth exp popparenth .)
    RETURN          reduce using rule 114 (finexp -> addparenth exp popparenth .)
    IF              reduce using rule 114 (finexp -> addparenth exp popparenth .)
    FOR             reduce using rule 114 (finexp -> addparenth exp popparenth .)
    ID              reduce using rule 114 (finexp -> addparenth exp popparenth .)
    WHILE           reduce using rule 114 (finexp -> addparenth exp popparenth .)
    LEFTPAR         reduce using rule 114 (finexp -> addparenth exp popparenth .)
    CTEINT          reduce using rule 114 (finexp -> addparenth exp popparenth .)
    CTEFLOAT        reduce using rule 114 (finexp -> addparenth exp popparenth .)
    CTECHAR         reduce using rule 114 (finexp -> addparenth exp popparenth .)
    RIGHTBR         reduce using rule 114 (finexp -> addparenth exp popparenth .)
    RIGHTPAR        reduce using rule 114 (finexp -> addparenth exp popparenth .)
    RIGHTSQR        reduce using rule 114 (finexp -> addparenth exp popparenth .)
    COMMA           reduce using rule 114 (finexp -> addparenth exp popparenth .)
    SEMICOLON       reduce using rule 114 (finexp -> addparenth exp popparenth .)
    TO              reduce using rule 114 (finexp -> addparenth exp popparenth .)
    DO              reduce using rule 114 (finexp -> addparenth exp popparenth .)


state 164

    (113) popparenth -> RIGHTPAR .

    TIMES           reduce using rule 113 (popparenth -> RIGHTPAR .)
    DIVIDE          reduce using rule 113 (popparenth -> RIGHTPAR .)
    PLUS            reduce using rule 113 (popparenth -> RIGHTPAR .)
    REST            reduce using rule 113 (popparenth -> RIGHTPAR .)
    GREATER         reduce using rule 113 (popparenth -> RIGHTPAR .)
    GREATERAND      reduce using rule 113 (popparenth -> RIGHTPAR .)
    LESSER          reduce using rule 113 (popparenth -> RIGHTPAR .)
    LESSERAND       reduce using rule 113 (popparenth -> RIGHTPAR .)
    SAME            reduce using rule 113 (popparenth -> RIGHTPAR .)
    NOTSAME         reduce using rule 113 (popparenth -> RIGHTPAR .)
    NOT             reduce using rule 113 (popparenth -> RIGHTPAR .)
    AND             reduce using rule 113 (popparenth -> RIGHTPAR .)
    OR              reduce using rule 113 (popparenth -> RIGHTPAR .)
    READ            reduce using rule 113 (popparenth -> RIGHTPAR .)
    WRITE           reduce using rule 113 (popparenth -> RIGHTPAR .)
    RETURN          reduce using rule 113 (popparenth -> RIGHTPAR .)
    IF              reduce using rule 113 (popparenth -> RIGHTPAR .)
    FOR             reduce using rule 113 (popparenth -> RIGHTPAR .)
    ID              reduce using rule 113 (popparenth -> RIGHTPAR .)
    WHILE           reduce using rule 113 (popparenth -> RIGHTPAR .)
    LEFTPAR         reduce using rule 113 (popparenth -> RIGHTPAR .)
    CTEINT          reduce using rule 113 (popparenth -> RIGHTPAR .)
    CTEFLOAT        reduce using rule 113 (popparenth -> RIGHTPAR .)
    CTECHAR         reduce using rule 113 (popparenth -> RIGHTPAR .)
    RIGHTBR         reduce using rule 113 (popparenth -> RIGHTPAR .)
    RIGHTPAR        reduce using rule 113 (popparenth -> RIGHTPAR .)
    RIGHTSQR        reduce using rule 113 (popparenth -> RIGHTPAR .)
    COMMA           reduce using rule 113 (popparenth -> RIGHTPAR .)
    SEMICOLON       reduce using rule 113 (popparenth -> RIGHTPAR .)
    TO              reduce using rule 113 (popparenth -> RIGHTPAR .)
    DO              reduce using rule 113 (popparenth -> RIGHTPAR .)


state 165

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR . startfunc statutes RIGHTBR funcsize neuralendfuncs modules
    (30) startfunc -> .

    READ            reduce using rule 30 (startfunc -> .)
    WRITE           reduce using rule 30 (startfunc -> .)
    RETURN          reduce using rule 30 (startfunc -> .)
    IF              reduce using rule 30 (startfunc -> .)
    FOR             reduce using rule 30 (startfunc -> .)
    ID              reduce using rule 30 (startfunc -> .)
    WHILE           reduce using rule 30 (startfunc -> .)
    LEFTPAR         reduce using rule 30 (startfunc -> .)
    CTEINT          reduce using rule 30 (startfunc -> .)
    CTEFLOAT        reduce using rule 30 (startfunc -> .)
    CTECHAR         reduce using rule 30 (startfunc -> .)
    RIGHTBR         reduce using rule 30 (startfunc -> .)

    startfunc                      shift and go to state 183

state 166

    (31) parameters -> typing COLON neuralinsertid idarray mulparams .

    RIGHTPAR        reduce using rule 31 (parameters -> typing COLON neuralinsertid idarray mulparams .)


state 167

    (34) mulparams -> COMMA . parameters
    (31) parameters -> . typing COLON neuralinsertid idarray mulparams
    (32) parameters -> . empty
    (19) typing -> . INT
    (20) typing -> . FLOAT
    (21) typing -> . CHAR
    (121) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 121 (empty -> .)

    parameters                     shift and go to state 184
    typing                         shift and go to state 37
    empty                          shift and go to state 38

state 168

    (35) mulparams -> empty .

    RIGHTPAR        reduce using rule 35 (mulparams -> empty .)


state 169

    (58) assign -> neuralassign1 idarray neuralassign2 assignexp . SEMICOLON

    SEMICOLON       shift and go to state 185


state 170

    (61) assignexp -> exp .

    SEMICOLON       reduce using rule 61 (assignexp -> exp .)


state 171

    (15) idarray -> initarray exp verify . RIGHTSQR

    RIGHTSQR        shift and go to state 186


state 172

    (69) reading -> READ LEFTPAR neuralread idarray . mulread RIGHTPAR SEMICOLON
    (71) mulread -> . COMMA ID idarray mulread
    (72) mulread -> . empty
    (121) empty -> .

    COMMA           shift and go to state 188
    RIGHTPAR        reduce using rule 121 (empty -> .)

    mulread                        shift and go to state 187
    empty                          shift and go to state 189

state 173

    (62) writing -> WRITE LEFTPAR auxwrite mulwrite . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 190


state 174

    (67) mulwrite -> COMMA . auxwrite mulwrite
    (63) auxwrite -> . writetyping
    (64) auxwrite -> . exp
    (65) writetyping -> . STRING
    (66) writetyping -> . CTECHAR
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    STRING          shift and go to state 149
    CTECHAR         shift and go to state 150
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    ID              shift and go to state 137

    auxwrite                       shift and go to state 191
    writetyping                    shift and go to state 147
    exp                            shift and go to state 148
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 175

    (68) mulwrite -> empty .

    RIGHTPAR        reduce using rule 68 (mulwrite -> empty .)


state 176

    (36) returning -> RETURN LEFTPAR exp RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 192


state 177

    (73) ifing -> IF LEFTPAR exp neuralif . THEN LEFTBR statutes RIGHTBR elsing

    THEN            shift and go to state 193


state 178

    (74) neuralif -> RIGHTPAR .

    THEN            reduce using rule 74 (neuralif -> RIGHTPAR .)


state 179

    (78) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 194


state 180

    (80) neuralwhile2 -> RIGHTPAR .

    DO              reduce using rule 80 (neuralwhile2 -> RIGHTPAR .)


state 181

    (81) foring -> FOR neuralfor1 idarray EQUAL . exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 195
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 182

    (37) paramsexp -> LEFTPAR neuralera . paramsexp2 neuralpar
    (39) paramsexp2 -> . exp neuralpar2 auxparamsexp2
    (40) paramsexp2 -> . empty
    (85) exp -> . andexp exp1
    (121) empty -> .
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    RIGHTPAR        reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    paramsexp2                     shift and go to state 196
    exp                            shift and go to state 197
    empty                          shift and go to state 198
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 183

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc . statutes RIGHTBR funcsize neuralendfuncs modules
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (121) empty -> .
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    RIGHTBR         reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    statutes                       shift and go to state 199
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    empty                          shift and go to state 69
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 184

    (34) mulparams -> COMMA parameters .

    RIGHTPAR        reduce using rule 34 (mulparams -> COMMA parameters .)


state 185

    (58) assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .

    READ            reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    WRITE           reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    RETURN          reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    IF              reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    FOR             reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    ID              reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    WHILE           reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    LEFTPAR         reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    CTEINT          reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    CTEFLOAT        reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    CTECHAR         reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    RIGHTBR         reduce using rule 58 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)


state 186

    (15) idarray -> initarray exp verify RIGHTSQR .

    EQUAL           reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    COMMA           reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    RIGHTPAR        reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    TIMES           reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    DIVIDE          reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    PLUS            reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    REST            reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    GREATER         reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    GREATERAND      reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    LESSER          reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    LESSERAND       reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    SAME            reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    NOTSAME         reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    NOT             reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    AND             reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    OR              reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    READ            reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    WRITE           reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    RETURN          reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    IF              reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    FOR             reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    ID              reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    WHILE           reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    LEFTPAR         reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    CTEINT          reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    CTEFLOAT        reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    CTECHAR         reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    RIGHTBR         reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    RIGHTSQR        reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    SEMICOLON       reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    TO              reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)
    DO              reduce using rule 15 (idarray -> initarray exp verify RIGHTSQR .)


state 187

    (69) reading -> READ LEFTPAR neuralread idarray mulread . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 200


state 188

    (71) mulread -> COMMA . ID idarray mulread

    ID              shift and go to state 201


state 189

    (72) mulread -> empty .

    RIGHTPAR        reduce using rule 72 (mulread -> empty .)


state 190

    (62) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 202


state 191

    (67) mulwrite -> COMMA auxwrite . mulwrite
    (67) mulwrite -> . COMMA auxwrite mulwrite
    (68) mulwrite -> . empty
    (121) empty -> .

    COMMA           shift and go to state 174
    RIGHTPAR        reduce using rule 121 (empty -> .)

    mulwrite                       shift and go to state 203
    empty                          shift and go to state 175

state 192

    (36) returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .

    READ            reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    IF              reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    ID              reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 36 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)


state 193

    (73) ifing -> IF LEFTPAR exp neuralif THEN . LEFTBR statutes RIGHTBR elsing

    LEFTBR          shift and go to state 204


state 194

    (78) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 205


state 195

    (81) foring -> FOR neuralfor1 idarray EQUAL exp . neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (83) neuralfor2 -> . TO

    TO              shift and go to state 207

    neuralfor2                     shift and go to state 206

state 196

    (37) paramsexp -> LEFTPAR neuralera paramsexp2 . neuralpar
    (44) neuralpar -> . RIGHTPAR

    RIGHTPAR        shift and go to state 209

    neuralpar                      shift and go to state 208

state 197

    (39) paramsexp2 -> exp . neuralpar2 auxparamsexp2
    (45) neuralpar2 -> .

    COMMA           reduce using rule 45 (neuralpar2 -> .)
    RIGHTPAR        reduce using rule 45 (neuralpar2 -> .)

    neuralpar2                     shift and go to state 210

state 198

    (40) paramsexp2 -> empty .

    RIGHTPAR        reduce using rule 40 (paramsexp2 -> empty .)


state 199

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes . RIGHTBR funcsize neuralendfuncs modules

    RIGHTBR         shift and go to state 211


state 200

    (69) reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 212


state 201

    (71) mulread -> COMMA ID . idarray mulread
    (15) idarray -> . initarray exp verify RIGHTSQR
    (16) idarray -> . empty
    (17) initarray -> . LEFTSQR
    (121) empty -> .

    LEFTSQR         shift and go to state 100
    COMMA           reduce using rule 121 (empty -> .)
    RIGHTPAR        reduce using rule 121 (empty -> .)

    idarray                        shift and go to state 213
    initarray                      shift and go to state 98
    empty                          shift and go to state 99

state 202

    (62) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .

    READ            reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    IF              reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    ID              reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 62 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)


state 203

    (67) mulwrite -> COMMA auxwrite mulwrite .

    RIGHTPAR        reduce using rule 67 (mulwrite -> COMMA auxwrite mulwrite .)


state 204

    (73) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR . statutes RIGHTBR elsing
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (121) empty -> .
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    RIGHTBR         reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    exp                            shift and go to state 59
    statutes                       shift and go to state 214
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    empty                          shift and go to state 69
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 205

    (78) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR . statutes RIGHTBR
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (121) empty -> .
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    RIGHTBR         reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    neuralwhile1                   shift and go to state 66
    exp                            shift and go to state 59
    statutes                       shift and go to state 215
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    andexp                         shift and go to state 68
    empty                          shift and go to state 69
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 206

    (81) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 . exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 216
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 207

    (83) neuralfor2 -> TO .

    LEFTPAR         reduce using rule 83 (neuralfor2 -> TO .)
    CTEINT          reduce using rule 83 (neuralfor2 -> TO .)
    CTEFLOAT        reduce using rule 83 (neuralfor2 -> TO .)
    CTECHAR         reduce using rule 83 (neuralfor2 -> TO .)
    ID              reduce using rule 83 (neuralfor2 -> TO .)


state 208

    (37) paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .

    TIMES           reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    DIVIDE          reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    PLUS            reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    REST            reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    GREATER         reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    GREATERAND      reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    LESSER          reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    LESSERAND       reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    SAME            reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    NOTSAME         reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    NOT             reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    AND             reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    OR              reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    READ            reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    WRITE           reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RETURN          reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    IF              reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    FOR             reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    ID              reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    WHILE           reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    LEFTPAR         reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    CTEINT          reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    CTEFLOAT        reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    CTECHAR         reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RIGHTBR         reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RIGHTPAR        reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RIGHTSQR        reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    COMMA           reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    SEMICOLON       reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    TO              reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    DO              reduce using rule 37 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)


state 209

    (44) neuralpar -> RIGHTPAR .

    TIMES           reduce using rule 44 (neuralpar -> RIGHTPAR .)
    DIVIDE          reduce using rule 44 (neuralpar -> RIGHTPAR .)
    PLUS            reduce using rule 44 (neuralpar -> RIGHTPAR .)
    REST            reduce using rule 44 (neuralpar -> RIGHTPAR .)
    GREATER         reduce using rule 44 (neuralpar -> RIGHTPAR .)
    GREATERAND      reduce using rule 44 (neuralpar -> RIGHTPAR .)
    LESSER          reduce using rule 44 (neuralpar -> RIGHTPAR .)
    LESSERAND       reduce using rule 44 (neuralpar -> RIGHTPAR .)
    SAME            reduce using rule 44 (neuralpar -> RIGHTPAR .)
    NOTSAME         reduce using rule 44 (neuralpar -> RIGHTPAR .)
    NOT             reduce using rule 44 (neuralpar -> RIGHTPAR .)
    AND             reduce using rule 44 (neuralpar -> RIGHTPAR .)
    OR              reduce using rule 44 (neuralpar -> RIGHTPAR .)
    READ            reduce using rule 44 (neuralpar -> RIGHTPAR .)
    WRITE           reduce using rule 44 (neuralpar -> RIGHTPAR .)
    RETURN          reduce using rule 44 (neuralpar -> RIGHTPAR .)
    IF              reduce using rule 44 (neuralpar -> RIGHTPAR .)
    FOR             reduce using rule 44 (neuralpar -> RIGHTPAR .)
    ID              reduce using rule 44 (neuralpar -> RIGHTPAR .)
    WHILE           reduce using rule 44 (neuralpar -> RIGHTPAR .)
    LEFTPAR         reduce using rule 44 (neuralpar -> RIGHTPAR .)
    CTEINT          reduce using rule 44 (neuralpar -> RIGHTPAR .)
    CTEFLOAT        reduce using rule 44 (neuralpar -> RIGHTPAR .)
    CTECHAR         reduce using rule 44 (neuralpar -> RIGHTPAR .)
    RIGHTBR         reduce using rule 44 (neuralpar -> RIGHTPAR .)
    RIGHTPAR        reduce using rule 44 (neuralpar -> RIGHTPAR .)
    RIGHTSQR        reduce using rule 44 (neuralpar -> RIGHTPAR .)
    COMMA           reduce using rule 44 (neuralpar -> RIGHTPAR .)
    SEMICOLON       reduce using rule 44 (neuralpar -> RIGHTPAR .)
    TO              reduce using rule 44 (neuralpar -> RIGHTPAR .)
    DO              reduce using rule 44 (neuralpar -> RIGHTPAR .)


state 210

    (39) paramsexp2 -> exp neuralpar2 . auxparamsexp2
    (41) auxparamsexp2 -> . COMMA exp neuralpar2 auxparamsexp2
    (42) auxparamsexp2 -> . empty
    (121) empty -> .

    COMMA           shift and go to state 218
    RIGHTPAR        reduce using rule 121 (empty -> .)

    auxparamsexp2                  shift and go to state 217
    empty                          shift and go to state 219

state 211

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR . funcsize neuralendfuncs modules
    (29) funcsize -> .

    FUNCTION        reduce using rule 29 (funcsize -> .)
    MAIN            reduce using rule 29 (funcsize -> .)

    funcsize                       shift and go to state 220

state 212

    (69) reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .

    READ            reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    IF              reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    ID              reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 69 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)


state 213

    (71) mulread -> COMMA ID idarray . mulread
    (71) mulread -> . COMMA ID idarray mulread
    (72) mulread -> . empty
    (121) empty -> .

    COMMA           shift and go to state 188
    RIGHTPAR        reduce using rule 121 (empty -> .)

    mulread                        shift and go to state 221
    empty                          shift and go to state 189

state 214

    (73) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes . RIGHTBR elsing

    RIGHTBR         shift and go to state 222


state 215

    (78) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 223


state 216

    (81) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp . neuralfor3 LEFTBR statutes RIGHTBR
    (84) neuralfor3 -> . DO

    DO              shift and go to state 225

    neuralfor3                     shift and go to state 224

state 217

    (39) paramsexp2 -> exp neuralpar2 auxparamsexp2 .

    RIGHTPAR        reduce using rule 39 (paramsexp2 -> exp neuralpar2 auxparamsexp2 .)


state 218

    (41) auxparamsexp2 -> COMMA . exp neuralpar2 auxparamsexp2
    (85) exp -> . andexp exp1
    (88) andexp -> . boolexp andexp1
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80
    ID              shift and go to state 137

    exp                            shift and go to state 226
    andexp                         shift and go to state 68
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 219

    (42) auxparamsexp2 -> empty .

    RIGHTPAR        reduce using rule 42 (auxparamsexp2 -> empty .)


state 220

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize . neuralendfuncs modules
    (28) neuralendfuncs -> .

    FUNCTION        reduce using rule 28 (neuralendfuncs -> .)
    MAIN            reduce using rule 28 (neuralendfuncs -> .)

    neuralendfuncs                 shift and go to state 227

state 221

    (71) mulread -> COMMA ID idarray mulread .

    RIGHTPAR        reduce using rule 71 (mulread -> COMMA ID idarray mulread .)


state 222

    (73) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR . elsing
    (75) elsing -> . neuralelse LEFTBR statutes RIGHTBR
    (76) elsing -> . empty
    (77) neuralelse -> . ELSE
    (121) empty -> .

    ELSE            shift and go to state 231
    READ            reduce using rule 121 (empty -> .)
    WRITE           reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    LEFTPAR         reduce using rule 121 (empty -> .)
    CTEINT          reduce using rule 121 (empty -> .)
    CTEFLOAT        reduce using rule 121 (empty -> .)
    CTECHAR         reduce using rule 121 (empty -> .)
    RIGHTBR         reduce using rule 121 (empty -> .)

    elsing                         shift and go to state 228
    neuralelse                     shift and go to state 229
    empty                          shift and go to state 230

state 223

    (78) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .

    READ            reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 78 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)


state 224

    (81) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 232


state 225

    (84) neuralfor3 -> DO .

    LEFTBR          reduce using rule 84 (neuralfor3 -> DO .)


state 226

    (41) auxparamsexp2 -> COMMA exp . neuralpar2 auxparamsexp2
    (45) neuralpar2 -> .

    COMMA           reduce using rule 45 (neuralpar2 -> .)
    RIGHTPAR        reduce using rule 45 (neuralpar2 -> .)

    neuralpar2                     shift and go to state 233

state 227

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs . modules
    (22) modules -> . FUNCTION functype neuralinsertfuncname funcparam
    (23) modules -> . empty
    (121) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 121 (empty -> .)

    modules                        shift and go to state 234
    empty                          shift and go to state 11

state 228

    (73) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .

    READ            reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    WRITE           reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    RETURN          reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    IF              reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    FOR             reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    ID              reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    WHILE           reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    LEFTPAR         reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTEINT          reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTEFLOAT        reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTECHAR         reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    RIGHTBR         reduce using rule 73 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)


state 229

    (75) elsing -> neuralelse . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 235


state 230

    (76) elsing -> empty .

    READ            reduce using rule 76 (elsing -> empty .)
    WRITE           reduce using rule 76 (elsing -> empty .)
    RETURN          reduce using rule 76 (elsing -> empty .)
    IF              reduce using rule 76 (elsing -> empty .)
    FOR             reduce using rule 76 (elsing -> empty .)
    ID              reduce using rule 76 (elsing -> empty .)
    WHILE           reduce using rule 76 (elsing -> empty .)
    LEFTPAR         reduce using rule 76 (elsing -> empty .)
    CTEINT          reduce using rule 76 (elsing -> empty .)
    CTEFLOAT        reduce using rule 76 (elsing -> empty .)
    CTECHAR         reduce using rule 76 (elsing -> empty .)
    RIGHTBR         reduce using rule 76 (elsing -> empty .)


state 231

    (77) neuralelse -> ELSE .

    LEFTBR          reduce using rule 77 (neuralelse -> ELSE .)


state 232

    (81) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR . statutes RIGHTBR
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (121) empty -> .
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    RIGHTBR         reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    exp                            shift and go to state 59
    statutes                       shift and go to state 236
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    empty                          shift and go to state 69
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 233

    (41) auxparamsexp2 -> COMMA exp neuralpar2 . auxparamsexp2
    (41) auxparamsexp2 -> . COMMA exp neuralpar2 auxparamsexp2
    (42) auxparamsexp2 -> . empty
    (121) empty -> .

    COMMA           shift and go to state 218
    RIGHTPAR        reduce using rule 121 (empty -> .)

    auxparamsexp2                  shift and go to state 237
    empty                          shift and go to state 219

state 234

    (27) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules .

    MAIN            reduce using rule 27 (funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules .)


state 235

    (75) elsing -> neuralelse LEFTBR . statutes RIGHTBR
    (46) statutes -> . assign statutesaux
    (47) statutes -> . reading statutesaux
    (48) statutes -> . writing statutesaux
    (49) statutes -> . returning statutesaux
    (50) statutes -> . ifing statutesaux
    (51) statutes -> . whiling statutesaux
    (52) statutes -> . foring statutesaux
    (53) statutes -> . exp statutesaux
    (54) statutes -> . specialfunc statutesaux
    (58) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (69) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (62) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (36) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (73) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (78) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (85) exp -> . andexp exp1
    (57) specialfunc -> . empty
    (59) neuralassign1 -> . ID
    (79) neuralwhile1 -> . WHILE
    (88) andexp -> . boolexp andexp1
    (121) empty -> .
    (92) boolexp -> . arithexp boolexp1
    (102) arithexp -> . geoexp arithexp1
    (107) geoexp -> . finexp geoexp1
    (114) finexp -> . addparenth exp popparenth
    (115) finexp -> . cteexp
    (112) addparenth -> . LEFTPAR
    (116) cteexp -> . CTEINT
    (117) cteexp -> . CTEFLOAT
    (118) cteexp -> . CTECHAR
    (119) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 62
    WRITE           shift and go to state 63
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 67
    ID              shift and go to state 70
    WHILE           shift and go to state 71
    RIGHTBR         reduce using rule 121 (empty -> .)
    LEFTPAR         shift and go to state 50
    CTEINT          shift and go to state 78
    CTEFLOAT        shift and go to state 79
    CTECHAR         shift and go to state 80

  ! READ            [ reduce using rule 121 (empty -> .) ]
  ! WRITE           [ reduce using rule 121 (empty -> .) ]
  ! RETURN          [ reduce using rule 121 (empty -> .) ]
  ! IF              [ reduce using rule 121 (empty -> .) ]
  ! FOR             [ reduce using rule 121 (empty -> .) ]
  ! ID              [ reduce using rule 121 (empty -> .) ]
  ! WHILE           [ reduce using rule 121 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 121 (empty -> .) ]
  ! CTEINT          [ reduce using rule 121 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 121 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 121 (empty -> .) ]

    statutes                       shift and go to state 238
    assign                         shift and go to state 52
    reading                        shift and go to state 53
    writing                        shift and go to state 54
    returning                      shift and go to state 55
    ifing                          shift and go to state 56
    whiling                        shift and go to state 57
    foring                         shift and go to state 58
    exp                            shift and go to state 59
    specialfunc                    shift and go to state 60
    neuralassign1                  shift and go to state 61
    neuralwhile1                   shift and go to state 66
    andexp                         shift and go to state 68
    empty                          shift and go to state 69
    boolexp                        shift and go to state 72
    arithexp                       shift and go to state 73
    geoexp                         shift and go to state 74
    finexp                         shift and go to state 75
    addparenth                     shift and go to state 76
    cteexp                         shift and go to state 77

state 236

    (81) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 239


state 237

    (41) auxparamsexp2 -> COMMA exp neuralpar2 auxparamsexp2 .

    RIGHTPAR        reduce using rule 41 (auxparamsexp2 -> COMMA exp neuralpar2 auxparamsexp2 .)


state 238

    (75) elsing -> neuralelse LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 240


state 239

    (81) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .

    READ            reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 81 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)


state 240

    (75) elsing -> neuralelse LEFTBR statutes RIGHTBR .

    READ            reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 75 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for READ in state 43 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 43 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for FOR in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 43 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 43 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 43 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 43 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 43 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 43 resolved as shift
WARNING: shift/reduce conflict for READ in state 52 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 52 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 52 resolved as shift
WARNING: shift/reduce conflict for IF in state 52 resolved as shift
WARNING: shift/reduce conflict for FOR in state 52 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 52 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 52 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 52 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 52 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 52 resolved as shift
WARNING: shift/reduce conflict for READ in state 53 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 53 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 53 resolved as shift
WARNING: shift/reduce conflict for IF in state 53 resolved as shift
WARNING: shift/reduce conflict for FOR in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 53 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 53 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 53 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 53 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 53 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 53 resolved as shift
WARNING: shift/reduce conflict for READ in state 54 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 54 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for FOR in state 54 resolved as shift
WARNING: shift/reduce conflict for ID in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 54 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 54 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 54 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 54 resolved as shift
WARNING: shift/reduce conflict for READ in state 55 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 55 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 55 resolved as shift
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for FOR in state 55 resolved as shift
WARNING: shift/reduce conflict for ID in state 55 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 55 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 55 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 55 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 55 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 55 resolved as shift
WARNING: shift/reduce conflict for READ in state 56 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 56 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 56 resolved as shift
WARNING: shift/reduce conflict for IF in state 56 resolved as shift
WARNING: shift/reduce conflict for FOR in state 56 resolved as shift
WARNING: shift/reduce conflict for ID in state 56 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 56 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 56 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 56 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 56 resolved as shift
WARNING: shift/reduce conflict for READ in state 57 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 57 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for FOR in state 57 resolved as shift
WARNING: shift/reduce conflict for ID in state 57 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 57 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 57 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 57 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 57 resolved as shift
WARNING: shift/reduce conflict for READ in state 58 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 58 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 58 resolved as shift
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for ID in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 58 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 58 resolved as shift
WARNING: shift/reduce conflict for READ in state 59 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 59 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 59 resolved as shift
WARNING: shift/reduce conflict for IF in state 59 resolved as shift
WARNING: shift/reduce conflict for FOR in state 59 resolved as shift
WARNING: shift/reduce conflict for ID in state 59 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 59 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 59 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 59 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 59 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 59 resolved as shift
WARNING: shift/reduce conflict for READ in state 60 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 60 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 60 resolved as shift
WARNING: shift/reduce conflict for IF in state 60 resolved as shift
WARNING: shift/reduce conflict for FOR in state 60 resolved as shift
WARNING: shift/reduce conflict for ID in state 60 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 60 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 60 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 60 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 60 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 60 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 111 resolved as shift
WARNING: shift/reduce conflict for READ in state 183 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 183 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 183 resolved as shift
WARNING: shift/reduce conflict for IF in state 183 resolved as shift
WARNING: shift/reduce conflict for FOR in state 183 resolved as shift
WARNING: shift/reduce conflict for ID in state 183 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 183 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 183 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 183 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 183 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 183 resolved as shift
WARNING: shift/reduce conflict for READ in state 204 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 204 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 204 resolved as shift
WARNING: shift/reduce conflict for IF in state 204 resolved as shift
WARNING: shift/reduce conflict for FOR in state 204 resolved as shift
WARNING: shift/reduce conflict for ID in state 204 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 204 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 204 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 204 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 204 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 204 resolved as shift
WARNING: shift/reduce conflict for READ in state 205 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 205 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 205 resolved as shift
WARNING: shift/reduce conflict for IF in state 205 resolved as shift
WARNING: shift/reduce conflict for FOR in state 205 resolved as shift
WARNING: shift/reduce conflict for ID in state 205 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 205 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 205 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 205 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 205 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 205 resolved as shift
WARNING: shift/reduce conflict for READ in state 232 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 232 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 232 resolved as shift
WARNING: shift/reduce conflict for IF in state 232 resolved as shift
WARNING: shift/reduce conflict for FOR in state 232 resolved as shift
WARNING: shift/reduce conflict for ID in state 232 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 232 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 232 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 232 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 232 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 232 resolved as shift
WARNING: shift/reduce conflict for READ in state 235 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 235 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 235 resolved as shift
WARNING: shift/reduce conflict for IF in state 235 resolved as shift
WARNING: shift/reduce conflict for FOR in state 235 resolved as shift
WARNING: shift/reduce conflict for ID in state 235 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 235 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 235 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 235 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 235 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 235 resolved as shift
WARNING: reduce/reduce conflict in state 70 resolved using rule (neuralassign1 -> ID)
WARNING: rejected rule (neuralexist -> <empty>) in state 70
WARNING: reduce/reduce conflict in state 88 resolved using rule (statutesaux -> empty)
WARNING: rejected rule (specialfunc -> empty) in state 88
WARNING: reduce/reduce conflict in state 150 resolved using rule (writetyping -> CTECHAR)
WARNING: rejected rule (cteexp -> CTECHAR) in state 150
