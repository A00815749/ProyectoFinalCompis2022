Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    STR
    TRUE
    FALSE
    MEDIA
    MEDIANA
    MODA
    VARIANZA
    STDEV
    PLOTXY

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
Rule 2     neuraltablefunctions -> ID
Rule 3     neuralmainjump -> <empty>
Rule 4     varsgl -> VARS vars
Rule 5     varsgl -> empty
Rule 6     vars -> typing COLON neuralinsertvar varsarr varsmul vars
Rule 7     vars -> empty
Rule 8     neuralinsertvar -> ID
Rule 9     varsarr -> LEFTSQR CTEINT RIGHTSQR
Rule 10    varsarr -> empty
Rule 11    varsmul -> COMMA neuralinsertvar varsarr varsmul
Rule 12    varsmul -> SEMICOLON
Rule 13    typing -> INT
Rule 14    typing -> FLOAT
Rule 15    typing -> CHAR
Rule 16    modules -> FUNCTION functype neuralinsertfuncname funcparam
Rule 17    modules -> empty
Rule 18    neuralinsertfuncname -> ID
Rule 19    functype -> VOID
Rule 20    functype -> typing
Rule 21    funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules
Rule 22    neuralendfuncs -> <empty>
Rule 23    funcsize -> <empty>
Rule 24    startfunc -> <empty>
Rule 25    parameters -> typing COLON neuralinsertid idarray mulparams
Rule 26    parameters -> empty
Rule 27    neuralinsertid -> ID
Rule 28    mulparams -> COMMA parameters
Rule 29    mulparams -> empty
Rule 30    paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar
Rule 31    paramsexp -> idarray
Rule 32    paramsexp2 -> exp neuralpar2 auxparamsexp2
Rule 33    paramsexp2 -> empty
Rule 34    auxparamsexp2 -> COMMA exp auxparamsexp2
Rule 35    auxparamsexp2 -> empty
Rule 36    neuralera -> <empty>
Rule 37    neuralpar -> RIGHTPAR
Rule 38    neuralpar2 -> <empty>
Rule 39    returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON
Rule 40    statutes -> assign statutesaux
Rule 41    statutes -> reading statutesaux
Rule 42    statutes -> writing statutesaux
Rule 43    statutes -> returning statutesaux
Rule 44    statutes -> ifing statutesaux
Rule 45    statutes -> whiling statutesaux
Rule 46    statutes -> foring statutesaux
Rule 47    statutes -> exp statutesaux
Rule 48    statutes -> specialfunc statutesaux
Rule 49    statutesaux -> statutes
Rule 50    statutesaux -> empty
Rule 51    specialfunc -> empty
Rule 52    assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON
Rule 53    neuralassign1 -> ID
Rule 54    neuralassign2 -> EQUAL
Rule 55    assignexp -> exp
Rule 56    writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
Rule 57    auxwrite -> writetyping
Rule 58    auxwrite -> exp
Rule 59    writetyping -> STRING
Rule 60    writetyping -> CTECHAR
Rule 61    mulwrite -> COMMA auxwrite mulwrite
Rule 62    mulwrite -> empty
Rule 63    reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
Rule 64    neuralread -> ID
Rule 65    mulread -> COMMA ID idarray mulread
Rule 66    mulread -> empty
Rule 67    ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
Rule 68    neuralif -> RIGHTPAR
Rule 69    elsing -> neuralelse LEFTBR statutes RIGHTBR
Rule 70    elsing -> empty
Rule 71    neuralelse -> ELSE
Rule 72    whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
Rule 73    neuralwhile1 -> WHILE
Rule 74    neuralwhile2 -> RIGHTPAR
Rule 75    foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
Rule 76    neuralfor1 -> ID
Rule 77    neuralfor2 -> TO
Rule 78    neuralfor3 -> DO
Rule 79    idarray -> LEFTSQR exp RIGHTSQR
Rule 80    idarray -> empty
Rule 81    exp -> andexp exp1
Rule 82    exp1 -> OR exp
Rule 83    exp1 -> empty
Rule 84    andexp -> boolexp andexp1
Rule 85    andexp1 -> neuraland andexp
Rule 86    andexp1 -> empty
Rule 87    neuraland -> AND
Rule 88    boolexp -> arithexp boolexp1
Rule 89    boolexp1 -> neuralbool arithexp
Rule 90    boolexp1 -> empty
Rule 91    neuralbool -> GREATER
Rule 92    neuralbool -> GREATERAND
Rule 93    neuralbool -> LESSER
Rule 94    neuralbool -> LESSERAND
Rule 95    neuralbool -> SAME
Rule 96    neuralbool -> NOTSAME
Rule 97    neuralbool -> NOT
Rule 98    arithexp -> geoexp arithexp1
Rule 99    arithexp1 -> neuralarith arithexp
Rule 100   arithexp1 -> empty
Rule 101   neuralarith -> PLUS
Rule 102   neuralarith -> REST
Rule 103   geoexp -> finexp geoexp1
Rule 104   geoexp1 -> neuralgeo geoexp
Rule 105   geoexp1 -> empty
Rule 106   neuralgeo -> TIMES
Rule 107   neuralgeo -> DIVIDE
Rule 108   addparenth -> LEFTPAR
Rule 109   popparenth -> RIGHTPAR
Rule 110   finexp -> addparenth exp popparenth
Rule 111   finexp -> cteexp
Rule 112   cteexp -> CTEINT
Rule 113   cteexp -> CTEFLOAT
Rule 114   cteexp -> CTECHAR
Rule 115   cteexp -> ID neuralexist paramsexp
Rule 116   neuralexist -> <empty>
Rule 117   empty -> <empty>
Rule 118   debug -> empty

Terminals, with rules where they appear

AND                  : 87
CHAR                 : 15
COLON                : 6 25
COMMA                : 11 28 34 61 65
CTECHAR              : 60 114
CTEFLOAT             : 113
CTEINT               : 9 112
DIVIDE               : 107
DO                   : 72 78
ELSE                 : 71
EQUAL                : 54 75
FALSE                : 
FLOAT                : 14
FOR                  : 75
FUNCTION             : 16
GREATER              : 91
GREATERAND           : 92
ID                   : 2 8 18 27 53 64 65 76 115
IF                   : 67
INT                  : 13
LEFTBR               : 1 21 67 69 72 75
LEFTPAR              : 1 21 30 39 56 63 67 72 108
LEFTSQR              : 9 79
LESSER               : 93
LESSERAND            : 94
MAIN                 : 1
MEDIA                : 
MEDIANA              : 
MODA                 : 
NOT                  : 97
NOTSAME              : 96
OR                   : 82
PLOTXY               : 
PLUS                 : 101
PROGRAM              : 1
READ                 : 63
REST                 : 102
RETURN               : 39
RIGHTBR              : 1 21 67 69 72 75
RIGHTPAR             : 1 21 37 39 56 63 68 74 109
RIGHTSQR             : 9 79
SAME                 : 95
SEMICOLON            : 1 12 21 39 52 56 63
STDEV                : 
STR                  : 
STRING               : 59
THEN                 : 67
TIMES                : 106
TO                   : 77
TRUE                 : 
VARIANZA             : 
VARS                 : 4
VOID                 : 19
WHILE                : 73
WRITE                : 56
error                : 

Nonterminals, with rules where they appear

addparenth           : 110
andexp               : 81 85
andexp1              : 84
arithexp             : 88 89 99
arithexp1            : 98
assign               : 40
assignexp            : 52
auxparamsexp2        : 32 34
auxwrite             : 56 61
boolexp              : 84
boolexp1             : 88
cteexp               : 111
debug                : 
elsing               : 67
empty                : 5 7 10 17 26 29 33 35 50 51 62 66 70 80 83 86 90 100 105 118
exp                  : 32 34 39 47 55 58 67 72 75 75 79 82 110
exp1                 : 81
finexp               : 103
foring               : 46
funcparam            : 16
funcsize             : 21
functype             : 16
geoexp               : 98 104
geoexp1              : 103
idarray              : 25 31 52 63 65 75
ifing                : 44
modules              : 1 21
mulparams            : 25
mulread              : 63 65
mulwrite             : 56 61
neuraland            : 85
neuralarith          : 99
neuralassign1        : 52
neuralassign2        : 52
neuralbool           : 89
neuralelse           : 69
neuralendfuncs       : 21
neuralera            : 30
neuralexist          : 115
neuralfor1           : 75
neuralfor2           : 75
neuralfor3           : 75
neuralgeo            : 104
neuralif             : 67
neuralinsertfuncname : 16
neuralinsertid       : 25
neuralinsertvar      : 6 11
neuralmainjump       : 1
neuralpar            : 30
neuralpar2           : 32
neuralread           : 63
neuraltablefunctions : 1
neuralwhile1         : 72
neuralwhile2         : 72
parameters           : 21 28
paramsexp            : 115
paramsexp2           : 30
popparenth           : 110
program              : 0
reading              : 41
returning            : 43
specialfunc          : 48
startfunc            : 21
statutes             : 1 21 49 67 69 72 75
statutesaux          : 40 41 42 43 44 45 46 47 48
typing               : 6 20 25
vars                 : 4 6
varsarr              : 6 11
varsgl               : 1 21
varsmul              : 6 11
whiling              : 45
writetyping          : 57
writing              : 42

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
    (2) neuraltablefunctions -> . ID

    ID              shift and go to state 4

    neuraltablefunctions           shift and go to state 3

state 3

    (1) program -> PROGRAM neuraltablefunctions . SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    SEMICOLON       shift and go to state 5


state 4

    (2) neuraltablefunctions -> ID .

    SEMICOLON       reduce using rule 2 (neuraltablefunctions -> ID .)


state 5

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON . varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
    (4) varsgl -> . VARS vars
    (5) varsgl -> . empty
    (117) empty -> .

    VARS            shift and go to state 7
    FUNCTION        reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)

    varsgl                         shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl . modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR
    (16) modules -> . FUNCTION functype neuralinsertfuncname funcparam
    (17) modules -> . empty
    (117) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 117 (empty -> .)

    modules                        shift and go to state 9
    empty                          shift and go to state 11

state 7

    (4) varsgl -> VARS . vars
    (6) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (7) vars -> . empty
    (13) typing -> . INT
    (14) typing -> . FLOAT
    (15) typing -> . CHAR
    (117) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    LEFTBR          reduce using rule 117 (empty -> .)

    vars                           shift and go to state 12
    typing                         shift and go to state 13
    empty                          shift and go to state 14

state 8

    (5) varsgl -> empty .

    FUNCTION        reduce using rule 5 (varsgl -> empty .)
    MAIN            reduce using rule 5 (varsgl -> empty .)
    LEFTBR          reduce using rule 5 (varsgl -> empty .)


state 9

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules . MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    MAIN            shift and go to state 18


state 10

    (16) modules -> FUNCTION . functype neuralinsertfuncname funcparam
    (19) functype -> . VOID
    (20) functype -> . typing
    (13) typing -> . INT
    (14) typing -> . FLOAT
    (15) typing -> . CHAR

    VOID            shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    functype                       shift and go to state 19
    typing                         shift and go to state 21

state 11

    (17) modules -> empty .

    MAIN            reduce using rule 17 (modules -> empty .)


state 12

    (4) varsgl -> VARS vars .

    FUNCTION        reduce using rule 4 (varsgl -> VARS vars .)
    MAIN            reduce using rule 4 (varsgl -> VARS vars .)
    LEFTBR          reduce using rule 4 (varsgl -> VARS vars .)


state 13

    (6) vars -> typing . COLON neuralinsertvar varsarr varsmul vars

    COLON           shift and go to state 22


state 14

    (7) vars -> empty .

    FUNCTION        reduce using rule 7 (vars -> empty .)
    MAIN            reduce using rule 7 (vars -> empty .)
    LEFTBR          reduce using rule 7 (vars -> empty .)


state 15

    (13) typing -> INT .

    COLON           reduce using rule 13 (typing -> INT .)
    ID              reduce using rule 13 (typing -> INT .)


state 16

    (14) typing -> FLOAT .

    COLON           reduce using rule 14 (typing -> FLOAT .)
    ID              reduce using rule 14 (typing -> FLOAT .)


state 17

    (15) typing -> CHAR .

    COLON           reduce using rule 15 (typing -> CHAR .)
    ID              reduce using rule 15 (typing -> CHAR .)


state 18

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN . LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    LEFTPAR         shift and go to state 23


state 19

    (16) modules -> FUNCTION functype . neuralinsertfuncname funcparam
    (18) neuralinsertfuncname -> . ID

    ID              shift and go to state 25

    neuralinsertfuncname           shift and go to state 24

state 20

    (19) functype -> VOID .

    ID              reduce using rule 19 (functype -> VOID .)


state 21

    (20) functype -> typing .

    ID              reduce using rule 20 (functype -> typing .)


state 22

    (6) vars -> typing COLON . neuralinsertvar varsarr varsmul vars
    (8) neuralinsertvar -> . ID

    ID              shift and go to state 27

    neuralinsertvar                shift and go to state 26

state 23

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR . RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR

    RIGHTPAR        shift and go to state 28


state 24

    (16) modules -> FUNCTION functype neuralinsertfuncname . funcparam
    (21) funcparam -> . LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    LEFTPAR         shift and go to state 30

    funcparam                      shift and go to state 29

state 25

    (18) neuralinsertfuncname -> ID .

    LEFTPAR         reduce using rule 18 (neuralinsertfuncname -> ID .)


state 26

    (6) vars -> typing COLON neuralinsertvar . varsarr varsmul vars
    (9) varsarr -> . LEFTSQR CTEINT RIGHTSQR
    (10) varsarr -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 32
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    varsarr                        shift and go to state 31
    empty                          shift and go to state 33

state 27

    (8) neuralinsertvar -> ID .

    LEFTSQR         reduce using rule 8 (neuralinsertvar -> ID .)
    COMMA           reduce using rule 8 (neuralinsertvar -> ID .)
    SEMICOLON       reduce using rule 8 (neuralinsertvar -> ID .)


state 28

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR . LEFTBR neuralmainjump statutes RIGHTBR

    LEFTBR          shift and go to state 34


state 29

    (16) modules -> FUNCTION functype neuralinsertfuncname funcparam .

    MAIN            reduce using rule 16 (modules -> FUNCTION functype neuralinsertfuncname funcparam .)


state 30

    (21) funcparam -> LEFTPAR . parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules
    (25) parameters -> . typing COLON neuralinsertid idarray mulparams
    (26) parameters -> . empty
    (13) typing -> . INT
    (14) typing -> . FLOAT
    (15) typing -> . CHAR
    (117) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 117 (empty -> .)

    parameters                     shift and go to state 35
    typing                         shift and go to state 36
    empty                          shift and go to state 37

state 31

    (6) vars -> typing COLON neuralinsertvar varsarr . varsmul vars
    (11) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (12) varsmul -> . SEMICOLON

    COMMA           shift and go to state 39
    SEMICOLON       shift and go to state 40

    varsmul                        shift and go to state 38

state 32

    (9) varsarr -> LEFTSQR . CTEINT RIGHTSQR

    CTEINT          shift and go to state 41


state 33

    (10) varsarr -> empty .

    COMMA           reduce using rule 10 (varsarr -> empty .)
    SEMICOLON       reduce using rule 10 (varsarr -> empty .)


state 34

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR . neuralmainjump statutes RIGHTBR
    (3) neuralmainjump -> .

    READ            reduce using rule 3 (neuralmainjump -> .)
    WRITE           reduce using rule 3 (neuralmainjump -> .)
    RETURN          reduce using rule 3 (neuralmainjump -> .)
    IF              reduce using rule 3 (neuralmainjump -> .)
    FOR             reduce using rule 3 (neuralmainjump -> .)
    ID              reduce using rule 3 (neuralmainjump -> .)
    WHILE           reduce using rule 3 (neuralmainjump -> .)
    LEFTPAR         reduce using rule 3 (neuralmainjump -> .)
    CTEINT          reduce using rule 3 (neuralmainjump -> .)
    CTEFLOAT        reduce using rule 3 (neuralmainjump -> .)
    CTECHAR         reduce using rule 3 (neuralmainjump -> .)
    RIGHTBR         reduce using rule 3 (neuralmainjump -> .)

    neuralmainjump                 shift and go to state 42

state 35

    (21) funcparam -> LEFTPAR parameters . RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    RIGHTPAR        shift and go to state 43


state 36

    (25) parameters -> typing . COLON neuralinsertid idarray mulparams

    COLON           shift and go to state 44


state 37

    (26) parameters -> empty .

    RIGHTPAR        reduce using rule 26 (parameters -> empty .)


state 38

    (6) vars -> typing COLON neuralinsertvar varsarr varsmul . vars
    (6) vars -> . typing COLON neuralinsertvar varsarr varsmul vars
    (7) vars -> . empty
    (13) typing -> . INT
    (14) typing -> . FLOAT
    (15) typing -> . CHAR
    (117) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    FUNCTION        reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    LEFTBR          reduce using rule 117 (empty -> .)

    typing                         shift and go to state 13
    vars                           shift and go to state 45
    empty                          shift and go to state 14

state 39

    (11) varsmul -> COMMA . neuralinsertvar varsarr varsmul
    (8) neuralinsertvar -> . ID

    ID              shift and go to state 27

    neuralinsertvar                shift and go to state 46

state 40

    (12) varsmul -> SEMICOLON .

    INT             reduce using rule 12 (varsmul -> SEMICOLON .)
    FLOAT           reduce using rule 12 (varsmul -> SEMICOLON .)
    CHAR            reduce using rule 12 (varsmul -> SEMICOLON .)
    FUNCTION        reduce using rule 12 (varsmul -> SEMICOLON .)
    MAIN            reduce using rule 12 (varsmul -> SEMICOLON .)
    LEFTBR          reduce using rule 12 (varsmul -> SEMICOLON .)


state 41

    (9) varsarr -> LEFTSQR CTEINT . RIGHTSQR

    RIGHTSQR        shift and go to state 47


state 42

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump . statutes RIGHTBR
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (117) empty -> .
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    RIGHTBR         reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    statutes                       shift and go to state 49
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    empty                          shift and go to state 67
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 43

    (21) funcparam -> LEFTPAR parameters RIGHTPAR . SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    SEMICOLON       shift and go to state 79


state 44

    (25) parameters -> typing COLON . neuralinsertid idarray mulparams
    (27) neuralinsertid -> . ID

    ID              shift and go to state 81

    neuralinsertid                 shift and go to state 80

state 45

    (6) vars -> typing COLON neuralinsertvar varsarr varsmul vars .

    FUNCTION        reduce using rule 6 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    MAIN            reduce using rule 6 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)
    LEFTBR          reduce using rule 6 (vars -> typing COLON neuralinsertvar varsarr varsmul vars .)


state 46

    (11) varsmul -> COMMA neuralinsertvar . varsarr varsmul
    (9) varsarr -> . LEFTSQR CTEINT RIGHTSQR
    (10) varsarr -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 32
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    varsarr                        shift and go to state 82
    empty                          shift and go to state 33

state 47

    (9) varsarr -> LEFTSQR CTEINT RIGHTSQR .

    COMMA           reduce using rule 9 (varsarr -> LEFTSQR CTEINT RIGHTSQR .)
    SEMICOLON       reduce using rule 9 (varsarr -> LEFTSQR CTEINT RIGHTSQR .)


state 48

    (108) addparenth -> LEFTPAR .

    LEFTPAR         reduce using rule 108 (addparenth -> LEFTPAR .)
    CTEINT          reduce using rule 108 (addparenth -> LEFTPAR .)
    CTEFLOAT        reduce using rule 108 (addparenth -> LEFTPAR .)
    CTECHAR         reduce using rule 108 (addparenth -> LEFTPAR .)
    ID              reduce using rule 108 (addparenth -> LEFTPAR .)


state 49

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes . RIGHTBR

    RIGHTBR         shift and go to state 83


state 50

    (40) statutes -> assign . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    assign                         shift and go to state 50
    statutesaux                    shift and go to state 84
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 51

    (41) statutes -> reading . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    reading                        shift and go to state 51
    statutesaux                    shift and go to state 87
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 52

    (42) statutes -> writing . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    writing                        shift and go to state 52
    statutesaux                    shift and go to state 88
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 53

    (43) statutes -> returning . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    returning                      shift and go to state 53
    statutesaux                    shift and go to state 89
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 54

    (44) statutes -> ifing . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    ifing                          shift and go to state 54
    statutesaux                    shift and go to state 90
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 55

    (45) statutes -> whiling . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    whiling                        shift and go to state 55
    statutesaux                    shift and go to state 91
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 56

    (46) statutes -> foring . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    foring                         shift and go to state 56
    statutesaux                    shift and go to state 92
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 57

    (47) statutes -> exp . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    exp                            shift and go to state 57
    statutesaux                    shift and go to state 93
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 58

    (48) statutes -> specialfunc . statutesaux
    (49) statutesaux -> . statutes
    (50) statutesaux -> . empty
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (117) empty -> .
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    RIGHTBR         reduce using rule 117 (empty -> .)
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    specialfunc                    shift and go to state 58
    statutesaux                    shift and go to state 94
    statutes                       shift and go to state 85
    empty                          shift and go to state 86
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 59

    (52) assign -> neuralassign1 . idarray neuralassign2 assignexp SEMICOLON
    (79) idarray -> . LEFTSQR exp RIGHTSQR
    (80) idarray -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 96
    EQUAL           reduce using rule 117 (empty -> .)

    idarray                        shift and go to state 95
    empty                          shift and go to state 97

state 60

    (63) reading -> READ . LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 98


state 61

    (56) writing -> WRITE . LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 99


state 62

    (39) returning -> RETURN . LEFTPAR exp RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 100


state 63

    (67) ifing -> IF . LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing

    LEFTPAR         shift and go to state 101


state 64

    (72) whiling -> neuralwhile1 . LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 102


state 65

    (75) foring -> FOR . neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (76) neuralfor1 -> . ID

    ID              shift and go to state 104

    neuralfor1                     shift and go to state 103

state 66

    (81) exp -> andexp . exp1
    (82) exp1 -> . OR exp
    (83) exp1 -> . empty
    (117) empty -> .

    OR              shift and go to state 106
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    LEFTPAR         reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)
    RIGHTSQR        reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    exp1                           shift and go to state 105
    empty                          shift and go to state 107

state 67

    (51) specialfunc -> empty .

    READ            reduce using rule 51 (specialfunc -> empty .)
    WRITE           reduce using rule 51 (specialfunc -> empty .)
    RETURN          reduce using rule 51 (specialfunc -> empty .)
    IF              reduce using rule 51 (specialfunc -> empty .)
    FOR             reduce using rule 51 (specialfunc -> empty .)
    ID              reduce using rule 51 (specialfunc -> empty .)
    WHILE           reduce using rule 51 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 51 (specialfunc -> empty .)
    CTEINT          reduce using rule 51 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 51 (specialfunc -> empty .)
    CTECHAR         reduce using rule 51 (specialfunc -> empty .)
    RIGHTBR         reduce using rule 51 (specialfunc -> empty .)


state 68

    (53) neuralassign1 -> ID .
    (115) cteexp -> ID . neuralexist paramsexp
    (116) neuralexist -> .

  ! reduce/reduce conflict for LEFTSQR resolved using rule 53 (neuralassign1 -> ID .)
    LEFTSQR         reduce using rule 53 (neuralassign1 -> ID .)
    EQUAL           reduce using rule 53 (neuralassign1 -> ID .)
    LEFTPAR         reduce using rule 116 (neuralexist -> .)
    TIMES           reduce using rule 116 (neuralexist -> .)
    DIVIDE          reduce using rule 116 (neuralexist -> .)
    PLUS            reduce using rule 116 (neuralexist -> .)
    REST            reduce using rule 116 (neuralexist -> .)
    GREATER         reduce using rule 116 (neuralexist -> .)
    GREATERAND      reduce using rule 116 (neuralexist -> .)
    LESSER          reduce using rule 116 (neuralexist -> .)
    LESSERAND       reduce using rule 116 (neuralexist -> .)
    SAME            reduce using rule 116 (neuralexist -> .)
    NOTSAME         reduce using rule 116 (neuralexist -> .)
    NOT             reduce using rule 116 (neuralexist -> .)
    AND             reduce using rule 116 (neuralexist -> .)
    OR              reduce using rule 116 (neuralexist -> .)
    READ            reduce using rule 116 (neuralexist -> .)
    WRITE           reduce using rule 116 (neuralexist -> .)
    RETURN          reduce using rule 116 (neuralexist -> .)
    IF              reduce using rule 116 (neuralexist -> .)
    FOR             reduce using rule 116 (neuralexist -> .)
    ID              reduce using rule 116 (neuralexist -> .)
    WHILE           reduce using rule 116 (neuralexist -> .)
    CTEINT          reduce using rule 116 (neuralexist -> .)
    CTEFLOAT        reduce using rule 116 (neuralexist -> .)
    CTECHAR         reduce using rule 116 (neuralexist -> .)
    RIGHTBR         reduce using rule 116 (neuralexist -> .)

  ! LEFTSQR         [ reduce using rule 116 (neuralexist -> .) ]

    neuralexist                    shift and go to state 108

state 69

    (73) neuralwhile1 -> WHILE .

    LEFTPAR         reduce using rule 73 (neuralwhile1 -> WHILE .)


state 70

    (84) andexp -> boolexp . andexp1
    (85) andexp1 -> . neuraland andexp
    (86) andexp1 -> . empty
    (87) neuraland -> . AND
    (117) empty -> .

    AND             shift and go to state 112
    OR              reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    LEFTPAR         reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)
    RIGHTSQR        reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    andexp1                        shift and go to state 109
    neuraland                      shift and go to state 110
    empty                          shift and go to state 111

state 71

    (88) boolexp -> arithexp . boolexp1
    (89) boolexp1 -> . neuralbool arithexp
    (90) boolexp1 -> . empty
    (91) neuralbool -> . GREATER
    (92) neuralbool -> . GREATERAND
    (93) neuralbool -> . LESSER
    (94) neuralbool -> . LESSERAND
    (95) neuralbool -> . SAME
    (96) neuralbool -> . NOTSAME
    (97) neuralbool -> . NOT
    (117) empty -> .

    GREATER         shift and go to state 116
    GREATERAND      shift and go to state 117
    LESSER          shift and go to state 118
    LESSERAND       shift and go to state 119
    SAME            shift and go to state 120
    NOTSAME         shift and go to state 121
    NOT             shift and go to state 122
    AND             reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    LEFTPAR         reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)
    RIGHTSQR        reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    boolexp1                       shift and go to state 113
    neuralbool                     shift and go to state 114
    empty                          shift and go to state 115

state 72

    (98) arithexp -> geoexp . arithexp1
    (99) arithexp1 -> . neuralarith arithexp
    (100) arithexp1 -> . empty
    (101) neuralarith -> . PLUS
    (102) neuralarith -> . REST
    (117) empty -> .

    PLUS            shift and go to state 126
    REST            shift and go to state 127
    GREATER         reduce using rule 117 (empty -> .)
    GREATERAND      reduce using rule 117 (empty -> .)
    LESSER          reduce using rule 117 (empty -> .)
    LESSERAND       reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    NOTSAME         reduce using rule 117 (empty -> .)
    NOT             reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    LEFTPAR         reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)
    RIGHTSQR        reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    arithexp1                      shift and go to state 123
    neuralarith                    shift and go to state 124
    empty                          shift and go to state 125

state 73

    (103) geoexp -> finexp . geoexp1
    (104) geoexp1 -> . neuralgeo geoexp
    (105) geoexp1 -> . empty
    (106) neuralgeo -> . TIMES
    (107) neuralgeo -> . DIVIDE
    (117) empty -> .

    TIMES           shift and go to state 131
    DIVIDE          shift and go to state 132
    PLUS            reduce using rule 117 (empty -> .)
    REST            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    GREATERAND      reduce using rule 117 (empty -> .)
    LESSER          reduce using rule 117 (empty -> .)
    LESSERAND       reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    NOTSAME         reduce using rule 117 (empty -> .)
    NOT             reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    LEFTPAR         reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)
    RIGHTSQR        reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    geoexp1                        shift and go to state 128
    neuralgeo                      shift and go to state 129
    empty                          shift and go to state 130

state 74

    (110) finexp -> addparenth . exp popparenth
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    addparenth                     shift and go to state 74
    exp                            shift and go to state 133
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    cteexp                         shift and go to state 75

state 75

    (111) finexp -> cteexp .

    TIMES           reduce using rule 111 (finexp -> cteexp .)
    DIVIDE          reduce using rule 111 (finexp -> cteexp .)
    PLUS            reduce using rule 111 (finexp -> cteexp .)
    REST            reduce using rule 111 (finexp -> cteexp .)
    GREATER         reduce using rule 111 (finexp -> cteexp .)
    GREATERAND      reduce using rule 111 (finexp -> cteexp .)
    LESSER          reduce using rule 111 (finexp -> cteexp .)
    LESSERAND       reduce using rule 111 (finexp -> cteexp .)
    SAME            reduce using rule 111 (finexp -> cteexp .)
    NOTSAME         reduce using rule 111 (finexp -> cteexp .)
    NOT             reduce using rule 111 (finexp -> cteexp .)
    AND             reduce using rule 111 (finexp -> cteexp .)
    OR              reduce using rule 111 (finexp -> cteexp .)
    READ            reduce using rule 111 (finexp -> cteexp .)
    WRITE           reduce using rule 111 (finexp -> cteexp .)
    RETURN          reduce using rule 111 (finexp -> cteexp .)
    IF              reduce using rule 111 (finexp -> cteexp .)
    FOR             reduce using rule 111 (finexp -> cteexp .)
    ID              reduce using rule 111 (finexp -> cteexp .)
    WHILE           reduce using rule 111 (finexp -> cteexp .)
    LEFTPAR         reduce using rule 111 (finexp -> cteexp .)
    CTEINT          reduce using rule 111 (finexp -> cteexp .)
    CTEFLOAT        reduce using rule 111 (finexp -> cteexp .)
    CTECHAR         reduce using rule 111 (finexp -> cteexp .)
    RIGHTBR         reduce using rule 111 (finexp -> cteexp .)
    RIGHTPAR        reduce using rule 111 (finexp -> cteexp .)
    RIGHTSQR        reduce using rule 111 (finexp -> cteexp .)
    COMMA           reduce using rule 111 (finexp -> cteexp .)
    SEMICOLON       reduce using rule 111 (finexp -> cteexp .)
    TO              reduce using rule 111 (finexp -> cteexp .)
    DO              reduce using rule 111 (finexp -> cteexp .)


state 76

    (112) cteexp -> CTEINT .

    TIMES           reduce using rule 112 (cteexp -> CTEINT .)
    DIVIDE          reduce using rule 112 (cteexp -> CTEINT .)
    PLUS            reduce using rule 112 (cteexp -> CTEINT .)
    REST            reduce using rule 112 (cteexp -> CTEINT .)
    GREATER         reduce using rule 112 (cteexp -> CTEINT .)
    GREATERAND      reduce using rule 112 (cteexp -> CTEINT .)
    LESSER          reduce using rule 112 (cteexp -> CTEINT .)
    LESSERAND       reduce using rule 112 (cteexp -> CTEINT .)
    SAME            reduce using rule 112 (cteexp -> CTEINT .)
    NOTSAME         reduce using rule 112 (cteexp -> CTEINT .)
    NOT             reduce using rule 112 (cteexp -> CTEINT .)
    AND             reduce using rule 112 (cteexp -> CTEINT .)
    OR              reduce using rule 112 (cteexp -> CTEINT .)
    READ            reduce using rule 112 (cteexp -> CTEINT .)
    WRITE           reduce using rule 112 (cteexp -> CTEINT .)
    RETURN          reduce using rule 112 (cteexp -> CTEINT .)
    IF              reduce using rule 112 (cteexp -> CTEINT .)
    FOR             reduce using rule 112 (cteexp -> CTEINT .)
    ID              reduce using rule 112 (cteexp -> CTEINT .)
    WHILE           reduce using rule 112 (cteexp -> CTEINT .)
    LEFTPAR         reduce using rule 112 (cteexp -> CTEINT .)
    CTEINT          reduce using rule 112 (cteexp -> CTEINT .)
    CTEFLOAT        reduce using rule 112 (cteexp -> CTEINT .)
    CTECHAR         reduce using rule 112 (cteexp -> CTEINT .)
    RIGHTBR         reduce using rule 112 (cteexp -> CTEINT .)
    RIGHTPAR        reduce using rule 112 (cteexp -> CTEINT .)
    RIGHTSQR        reduce using rule 112 (cteexp -> CTEINT .)
    COMMA           reduce using rule 112 (cteexp -> CTEINT .)
    SEMICOLON       reduce using rule 112 (cteexp -> CTEINT .)
    TO              reduce using rule 112 (cteexp -> CTEINT .)
    DO              reduce using rule 112 (cteexp -> CTEINT .)


state 77

    (113) cteexp -> CTEFLOAT .

    TIMES           reduce using rule 113 (cteexp -> CTEFLOAT .)
    DIVIDE          reduce using rule 113 (cteexp -> CTEFLOAT .)
    PLUS            reduce using rule 113 (cteexp -> CTEFLOAT .)
    REST            reduce using rule 113 (cteexp -> CTEFLOAT .)
    GREATER         reduce using rule 113 (cteexp -> CTEFLOAT .)
    GREATERAND      reduce using rule 113 (cteexp -> CTEFLOAT .)
    LESSER          reduce using rule 113 (cteexp -> CTEFLOAT .)
    LESSERAND       reduce using rule 113 (cteexp -> CTEFLOAT .)
    SAME            reduce using rule 113 (cteexp -> CTEFLOAT .)
    NOTSAME         reduce using rule 113 (cteexp -> CTEFLOAT .)
    NOT             reduce using rule 113 (cteexp -> CTEFLOAT .)
    AND             reduce using rule 113 (cteexp -> CTEFLOAT .)
    OR              reduce using rule 113 (cteexp -> CTEFLOAT .)
    READ            reduce using rule 113 (cteexp -> CTEFLOAT .)
    WRITE           reduce using rule 113 (cteexp -> CTEFLOAT .)
    RETURN          reduce using rule 113 (cteexp -> CTEFLOAT .)
    IF              reduce using rule 113 (cteexp -> CTEFLOAT .)
    FOR             reduce using rule 113 (cteexp -> CTEFLOAT .)
    ID              reduce using rule 113 (cteexp -> CTEFLOAT .)
    WHILE           reduce using rule 113 (cteexp -> CTEFLOAT .)
    LEFTPAR         reduce using rule 113 (cteexp -> CTEFLOAT .)
    CTEINT          reduce using rule 113 (cteexp -> CTEFLOAT .)
    CTEFLOAT        reduce using rule 113 (cteexp -> CTEFLOAT .)
    CTECHAR         reduce using rule 113 (cteexp -> CTEFLOAT .)
    RIGHTBR         reduce using rule 113 (cteexp -> CTEFLOAT .)
    RIGHTPAR        reduce using rule 113 (cteexp -> CTEFLOAT .)
    RIGHTSQR        reduce using rule 113 (cteexp -> CTEFLOAT .)
    COMMA           reduce using rule 113 (cteexp -> CTEFLOAT .)
    SEMICOLON       reduce using rule 113 (cteexp -> CTEFLOAT .)
    TO              reduce using rule 113 (cteexp -> CTEFLOAT .)
    DO              reduce using rule 113 (cteexp -> CTEFLOAT .)


state 78

    (114) cteexp -> CTECHAR .

    TIMES           reduce using rule 114 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 114 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 114 (cteexp -> CTECHAR .)
    REST            reduce using rule 114 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 114 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 114 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 114 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 114 (cteexp -> CTECHAR .)
    SAME            reduce using rule 114 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 114 (cteexp -> CTECHAR .)
    NOT             reduce using rule 114 (cteexp -> CTECHAR .)
    AND             reduce using rule 114 (cteexp -> CTECHAR .)
    OR              reduce using rule 114 (cteexp -> CTECHAR .)
    READ            reduce using rule 114 (cteexp -> CTECHAR .)
    WRITE           reduce using rule 114 (cteexp -> CTECHAR .)
    RETURN          reduce using rule 114 (cteexp -> CTECHAR .)
    IF              reduce using rule 114 (cteexp -> CTECHAR .)
    FOR             reduce using rule 114 (cteexp -> CTECHAR .)
    ID              reduce using rule 114 (cteexp -> CTECHAR .)
    WHILE           reduce using rule 114 (cteexp -> CTECHAR .)
    LEFTPAR         reduce using rule 114 (cteexp -> CTECHAR .)
    CTEINT          reduce using rule 114 (cteexp -> CTECHAR .)
    CTEFLOAT        reduce using rule 114 (cteexp -> CTECHAR .)
    CTECHAR         reduce using rule 114 (cteexp -> CTECHAR .)
    RIGHTBR         reduce using rule 114 (cteexp -> CTECHAR .)
    RIGHTPAR        reduce using rule 114 (cteexp -> CTECHAR .)
    RIGHTSQR        reduce using rule 114 (cteexp -> CTECHAR .)
    COMMA           reduce using rule 114 (cteexp -> CTECHAR .)
    SEMICOLON       reduce using rule 114 (cteexp -> CTECHAR .)
    TO              reduce using rule 114 (cteexp -> CTECHAR .)
    DO              reduce using rule 114 (cteexp -> CTECHAR .)


state 79

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON . varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules
    (4) varsgl -> . VARS vars
    (5) varsgl -> . empty
    (117) empty -> .

    VARS            shift and go to state 7
    LEFTBR          reduce using rule 117 (empty -> .)

    varsgl                         shift and go to state 135
    empty                          shift and go to state 8

state 80

    (25) parameters -> typing COLON neuralinsertid . idarray mulparams
    (79) idarray -> . LEFTSQR exp RIGHTSQR
    (80) idarray -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 96
    COMMA           reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)

    idarray                        shift and go to state 136
    empty                          shift and go to state 97

state 81

    (27) neuralinsertid -> ID .

    LEFTSQR         reduce using rule 27 (neuralinsertid -> ID .)
    COMMA           reduce using rule 27 (neuralinsertid -> ID .)
    RIGHTPAR        reduce using rule 27 (neuralinsertid -> ID .)


state 82

    (11) varsmul -> COMMA neuralinsertvar varsarr . varsmul
    (11) varsmul -> . COMMA neuralinsertvar varsarr varsmul
    (12) varsmul -> . SEMICOLON

    COMMA           shift and go to state 39
    SEMICOLON       shift and go to state 40

    varsmul                        shift and go to state 137

state 83

    (1) program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR .

    $end            reduce using rule 1 (program -> PROGRAM neuraltablefunctions SEMICOLON varsgl modules MAIN LEFTPAR RIGHTPAR LEFTBR neuralmainjump statutes RIGHTBR .)


state 84

    (40) statutes -> assign statutesaux .

    RIGHTBR         reduce using rule 40 (statutes -> assign statutesaux .)


state 85

    (49) statutesaux -> statutes .

    RIGHTBR         reduce using rule 49 (statutesaux -> statutes .)


state 86

    (50) statutesaux -> empty .
    (51) specialfunc -> empty .

  ! reduce/reduce conflict for RIGHTBR resolved using rule 50 (statutesaux -> empty .)
    RIGHTBR         reduce using rule 50 (statutesaux -> empty .)
    READ            reduce using rule 51 (specialfunc -> empty .)
    WRITE           reduce using rule 51 (specialfunc -> empty .)
    RETURN          reduce using rule 51 (specialfunc -> empty .)
    IF              reduce using rule 51 (specialfunc -> empty .)
    FOR             reduce using rule 51 (specialfunc -> empty .)
    ID              reduce using rule 51 (specialfunc -> empty .)
    WHILE           reduce using rule 51 (specialfunc -> empty .)
    LEFTPAR         reduce using rule 51 (specialfunc -> empty .)
    CTEINT          reduce using rule 51 (specialfunc -> empty .)
    CTEFLOAT        reduce using rule 51 (specialfunc -> empty .)
    CTECHAR         reduce using rule 51 (specialfunc -> empty .)

  ! RIGHTBR         [ reduce using rule 51 (specialfunc -> empty .) ]


state 87

    (41) statutes -> reading statutesaux .

    RIGHTBR         reduce using rule 41 (statutes -> reading statutesaux .)


state 88

    (42) statutes -> writing statutesaux .

    RIGHTBR         reduce using rule 42 (statutes -> writing statutesaux .)


state 89

    (43) statutes -> returning statutesaux .

    RIGHTBR         reduce using rule 43 (statutes -> returning statutesaux .)


state 90

    (44) statutes -> ifing statutesaux .

    RIGHTBR         reduce using rule 44 (statutes -> ifing statutesaux .)


state 91

    (45) statutes -> whiling statutesaux .

    RIGHTBR         reduce using rule 45 (statutes -> whiling statutesaux .)


state 92

    (46) statutes -> foring statutesaux .

    RIGHTBR         reduce using rule 46 (statutes -> foring statutesaux .)


state 93

    (47) statutes -> exp statutesaux .

    RIGHTBR         reduce using rule 47 (statutes -> exp statutesaux .)


state 94

    (48) statutes -> specialfunc statutesaux .

    RIGHTBR         reduce using rule 48 (statutes -> specialfunc statutesaux .)


state 95

    (52) assign -> neuralassign1 idarray . neuralassign2 assignexp SEMICOLON
    (54) neuralassign2 -> . EQUAL

    EQUAL           shift and go to state 139

    neuralassign2                  shift and go to state 138

state 96

    (79) idarray -> LEFTSQR . exp RIGHTSQR
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 140
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 97

    (80) idarray -> empty .

    EQUAL           reduce using rule 80 (idarray -> empty .)
    COMMA           reduce using rule 80 (idarray -> empty .)
    RIGHTPAR        reduce using rule 80 (idarray -> empty .)
    TIMES           reduce using rule 80 (idarray -> empty .)
    DIVIDE          reduce using rule 80 (idarray -> empty .)
    PLUS            reduce using rule 80 (idarray -> empty .)
    REST            reduce using rule 80 (idarray -> empty .)
    GREATER         reduce using rule 80 (idarray -> empty .)
    GREATERAND      reduce using rule 80 (idarray -> empty .)
    LESSER          reduce using rule 80 (idarray -> empty .)
    LESSERAND       reduce using rule 80 (idarray -> empty .)
    SAME            reduce using rule 80 (idarray -> empty .)
    NOTSAME         reduce using rule 80 (idarray -> empty .)
    NOT             reduce using rule 80 (idarray -> empty .)
    AND             reduce using rule 80 (idarray -> empty .)
    OR              reduce using rule 80 (idarray -> empty .)
    READ            reduce using rule 80 (idarray -> empty .)
    WRITE           reduce using rule 80 (idarray -> empty .)
    RETURN          reduce using rule 80 (idarray -> empty .)
    IF              reduce using rule 80 (idarray -> empty .)
    FOR             reduce using rule 80 (idarray -> empty .)
    ID              reduce using rule 80 (idarray -> empty .)
    WHILE           reduce using rule 80 (idarray -> empty .)
    LEFTPAR         reduce using rule 80 (idarray -> empty .)
    CTEINT          reduce using rule 80 (idarray -> empty .)
    CTEFLOAT        reduce using rule 80 (idarray -> empty .)
    CTECHAR         reduce using rule 80 (idarray -> empty .)
    RIGHTBR         reduce using rule 80 (idarray -> empty .)
    RIGHTSQR        reduce using rule 80 (idarray -> empty .)
    SEMICOLON       reduce using rule 80 (idarray -> empty .)
    TO              reduce using rule 80 (idarray -> empty .)
    DO              reduce using rule 80 (idarray -> empty .)


state 98

    (63) reading -> READ LEFTPAR . neuralread idarray mulread RIGHTPAR SEMICOLON
    (64) neuralread -> . ID

    ID              shift and go to state 142

    neuralread                     shift and go to state 141

state 99

    (56) writing -> WRITE LEFTPAR . auxwrite mulwrite RIGHTPAR SEMICOLON
    (57) auxwrite -> . writetyping
    (58) auxwrite -> . exp
    (59) writetyping -> . STRING
    (60) writetyping -> . CTECHAR
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    STRING          shift and go to state 146
    CTECHAR         shift and go to state 147
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    ID              shift and go to state 134

    auxwrite                       shift and go to state 143
    writetyping                    shift and go to state 144
    exp                            shift and go to state 145
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 100

    (39) returning -> RETURN LEFTPAR . exp RIGHTPAR SEMICOLON
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 148
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 101

    (67) ifing -> IF LEFTPAR . exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 149
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 102

    (72) whiling -> neuralwhile1 LEFTPAR . exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 150
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 103

    (75) foring -> FOR neuralfor1 . idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (79) idarray -> . LEFTSQR exp RIGHTSQR
    (80) idarray -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 96
    EQUAL           reduce using rule 117 (empty -> .)

    idarray                        shift and go to state 151
    empty                          shift and go to state 97

state 104

    (76) neuralfor1 -> ID .

    LEFTSQR         reduce using rule 76 (neuralfor1 -> ID .)
    EQUAL           reduce using rule 76 (neuralfor1 -> ID .)


state 105

    (81) exp -> andexp exp1 .

    READ            reduce using rule 81 (exp -> andexp exp1 .)
    WRITE           reduce using rule 81 (exp -> andexp exp1 .)
    RETURN          reduce using rule 81 (exp -> andexp exp1 .)
    IF              reduce using rule 81 (exp -> andexp exp1 .)
    FOR             reduce using rule 81 (exp -> andexp exp1 .)
    ID              reduce using rule 81 (exp -> andexp exp1 .)
    WHILE           reduce using rule 81 (exp -> andexp exp1 .)
    LEFTPAR         reduce using rule 81 (exp -> andexp exp1 .)
    CTEINT          reduce using rule 81 (exp -> andexp exp1 .)
    CTEFLOAT        reduce using rule 81 (exp -> andexp exp1 .)
    CTECHAR         reduce using rule 81 (exp -> andexp exp1 .)
    RIGHTBR         reduce using rule 81 (exp -> andexp exp1 .)
    RIGHTPAR        reduce using rule 81 (exp -> andexp exp1 .)
    RIGHTSQR        reduce using rule 81 (exp -> andexp exp1 .)
    COMMA           reduce using rule 81 (exp -> andexp exp1 .)
    SEMICOLON       reduce using rule 81 (exp -> andexp exp1 .)
    TO              reduce using rule 81 (exp -> andexp exp1 .)
    DO              reduce using rule 81 (exp -> andexp exp1 .)


state 106

    (82) exp1 -> OR . exp
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 152
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 107

    (83) exp1 -> empty .

    READ            reduce using rule 83 (exp1 -> empty .)
    WRITE           reduce using rule 83 (exp1 -> empty .)
    RETURN          reduce using rule 83 (exp1 -> empty .)
    IF              reduce using rule 83 (exp1 -> empty .)
    FOR             reduce using rule 83 (exp1 -> empty .)
    ID              reduce using rule 83 (exp1 -> empty .)
    WHILE           reduce using rule 83 (exp1 -> empty .)
    LEFTPAR         reduce using rule 83 (exp1 -> empty .)
    CTEINT          reduce using rule 83 (exp1 -> empty .)
    CTEFLOAT        reduce using rule 83 (exp1 -> empty .)
    CTECHAR         reduce using rule 83 (exp1 -> empty .)
    RIGHTBR         reduce using rule 83 (exp1 -> empty .)
    RIGHTPAR        reduce using rule 83 (exp1 -> empty .)
    RIGHTSQR        reduce using rule 83 (exp1 -> empty .)
    COMMA           reduce using rule 83 (exp1 -> empty .)
    SEMICOLON       reduce using rule 83 (exp1 -> empty .)
    TO              reduce using rule 83 (exp1 -> empty .)
    DO              reduce using rule 83 (exp1 -> empty .)


state 108

    (115) cteexp -> ID neuralexist . paramsexp
    (30) paramsexp -> . LEFTPAR neuralera paramsexp2 neuralpar
    (31) paramsexp -> . idarray
    (79) idarray -> . LEFTSQR exp RIGHTSQR
    (80) idarray -> . empty
    (117) empty -> .

  ! shift/reduce conflict for LEFTPAR resolved as shift
    LEFTPAR         shift and go to state 154
    LEFTSQR         shift and go to state 96
    TIMES           reduce using rule 117 (empty -> .)
    DIVIDE          reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    REST            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    GREATERAND      reduce using rule 117 (empty -> .)
    LESSER          reduce using rule 117 (empty -> .)
    LESSERAND       reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    NOTSAME         reduce using rule 117 (empty -> .)
    NOT             reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)
    RIGHTSQR        reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]

    paramsexp                      shift and go to state 153
    idarray                        shift and go to state 155
    empty                          shift and go to state 97

state 109

    (84) andexp -> boolexp andexp1 .

    OR              reduce using rule 84 (andexp -> boolexp andexp1 .)
    READ            reduce using rule 84 (andexp -> boolexp andexp1 .)
    WRITE           reduce using rule 84 (andexp -> boolexp andexp1 .)
    RETURN          reduce using rule 84 (andexp -> boolexp andexp1 .)
    IF              reduce using rule 84 (andexp -> boolexp andexp1 .)
    FOR             reduce using rule 84 (andexp -> boolexp andexp1 .)
    ID              reduce using rule 84 (andexp -> boolexp andexp1 .)
    WHILE           reduce using rule 84 (andexp -> boolexp andexp1 .)
    LEFTPAR         reduce using rule 84 (andexp -> boolexp andexp1 .)
    CTEINT          reduce using rule 84 (andexp -> boolexp andexp1 .)
    CTEFLOAT        reduce using rule 84 (andexp -> boolexp andexp1 .)
    CTECHAR         reduce using rule 84 (andexp -> boolexp andexp1 .)
    RIGHTBR         reduce using rule 84 (andexp -> boolexp andexp1 .)
    RIGHTPAR        reduce using rule 84 (andexp -> boolexp andexp1 .)
    RIGHTSQR        reduce using rule 84 (andexp -> boolexp andexp1 .)
    COMMA           reduce using rule 84 (andexp -> boolexp andexp1 .)
    SEMICOLON       reduce using rule 84 (andexp -> boolexp andexp1 .)
    TO              reduce using rule 84 (andexp -> boolexp andexp1 .)
    DO              reduce using rule 84 (andexp -> boolexp andexp1 .)


state 110

    (85) andexp1 -> neuraland . andexp
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    andexp                         shift and go to state 156
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 111

    (86) andexp1 -> empty .

    OR              reduce using rule 86 (andexp1 -> empty .)
    READ            reduce using rule 86 (andexp1 -> empty .)
    WRITE           reduce using rule 86 (andexp1 -> empty .)
    RETURN          reduce using rule 86 (andexp1 -> empty .)
    IF              reduce using rule 86 (andexp1 -> empty .)
    FOR             reduce using rule 86 (andexp1 -> empty .)
    ID              reduce using rule 86 (andexp1 -> empty .)
    WHILE           reduce using rule 86 (andexp1 -> empty .)
    LEFTPAR         reduce using rule 86 (andexp1 -> empty .)
    CTEINT          reduce using rule 86 (andexp1 -> empty .)
    CTEFLOAT        reduce using rule 86 (andexp1 -> empty .)
    CTECHAR         reduce using rule 86 (andexp1 -> empty .)
    RIGHTBR         reduce using rule 86 (andexp1 -> empty .)
    RIGHTPAR        reduce using rule 86 (andexp1 -> empty .)
    RIGHTSQR        reduce using rule 86 (andexp1 -> empty .)
    COMMA           reduce using rule 86 (andexp1 -> empty .)
    SEMICOLON       reduce using rule 86 (andexp1 -> empty .)
    TO              reduce using rule 86 (andexp1 -> empty .)
    DO              reduce using rule 86 (andexp1 -> empty .)


state 112

    (87) neuraland -> AND .

    LEFTPAR         reduce using rule 87 (neuraland -> AND .)
    CTEINT          reduce using rule 87 (neuraland -> AND .)
    CTEFLOAT        reduce using rule 87 (neuraland -> AND .)
    CTECHAR         reduce using rule 87 (neuraland -> AND .)
    ID              reduce using rule 87 (neuraland -> AND .)


state 113

    (88) boolexp -> arithexp boolexp1 .

    AND             reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    OR              reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    READ            reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    WRITE           reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    RETURN          reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    IF              reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    FOR             reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    ID              reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    WHILE           reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    LEFTPAR         reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    CTEINT          reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    CTEFLOAT        reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    CTECHAR         reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    RIGHTBR         reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    RIGHTPAR        reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    RIGHTSQR        reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    COMMA           reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    SEMICOLON       reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    TO              reduce using rule 88 (boolexp -> arithexp boolexp1 .)
    DO              reduce using rule 88 (boolexp -> arithexp boolexp1 .)


state 114

    (89) boolexp1 -> neuralbool . arithexp
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    arithexp                       shift and go to state 157
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 115

    (90) boolexp1 -> empty .

    AND             reduce using rule 90 (boolexp1 -> empty .)
    OR              reduce using rule 90 (boolexp1 -> empty .)
    READ            reduce using rule 90 (boolexp1 -> empty .)
    WRITE           reduce using rule 90 (boolexp1 -> empty .)
    RETURN          reduce using rule 90 (boolexp1 -> empty .)
    IF              reduce using rule 90 (boolexp1 -> empty .)
    FOR             reduce using rule 90 (boolexp1 -> empty .)
    ID              reduce using rule 90 (boolexp1 -> empty .)
    WHILE           reduce using rule 90 (boolexp1 -> empty .)
    LEFTPAR         reduce using rule 90 (boolexp1 -> empty .)
    CTEINT          reduce using rule 90 (boolexp1 -> empty .)
    CTEFLOAT        reduce using rule 90 (boolexp1 -> empty .)
    CTECHAR         reduce using rule 90 (boolexp1 -> empty .)
    RIGHTBR         reduce using rule 90 (boolexp1 -> empty .)
    RIGHTPAR        reduce using rule 90 (boolexp1 -> empty .)
    RIGHTSQR        reduce using rule 90 (boolexp1 -> empty .)
    COMMA           reduce using rule 90 (boolexp1 -> empty .)
    SEMICOLON       reduce using rule 90 (boolexp1 -> empty .)
    TO              reduce using rule 90 (boolexp1 -> empty .)
    DO              reduce using rule 90 (boolexp1 -> empty .)


state 116

    (91) neuralbool -> GREATER .

    LEFTPAR         reduce using rule 91 (neuralbool -> GREATER .)
    CTEINT          reduce using rule 91 (neuralbool -> GREATER .)
    CTEFLOAT        reduce using rule 91 (neuralbool -> GREATER .)
    CTECHAR         reduce using rule 91 (neuralbool -> GREATER .)
    ID              reduce using rule 91 (neuralbool -> GREATER .)


state 117

    (92) neuralbool -> GREATERAND .

    LEFTPAR         reduce using rule 92 (neuralbool -> GREATERAND .)
    CTEINT          reduce using rule 92 (neuralbool -> GREATERAND .)
    CTEFLOAT        reduce using rule 92 (neuralbool -> GREATERAND .)
    CTECHAR         reduce using rule 92 (neuralbool -> GREATERAND .)
    ID              reduce using rule 92 (neuralbool -> GREATERAND .)


state 118

    (93) neuralbool -> LESSER .

    LEFTPAR         reduce using rule 93 (neuralbool -> LESSER .)
    CTEINT          reduce using rule 93 (neuralbool -> LESSER .)
    CTEFLOAT        reduce using rule 93 (neuralbool -> LESSER .)
    CTECHAR         reduce using rule 93 (neuralbool -> LESSER .)
    ID              reduce using rule 93 (neuralbool -> LESSER .)


state 119

    (94) neuralbool -> LESSERAND .

    LEFTPAR         reduce using rule 94 (neuralbool -> LESSERAND .)
    CTEINT          reduce using rule 94 (neuralbool -> LESSERAND .)
    CTEFLOAT        reduce using rule 94 (neuralbool -> LESSERAND .)
    CTECHAR         reduce using rule 94 (neuralbool -> LESSERAND .)
    ID              reduce using rule 94 (neuralbool -> LESSERAND .)


state 120

    (95) neuralbool -> SAME .

    LEFTPAR         reduce using rule 95 (neuralbool -> SAME .)
    CTEINT          reduce using rule 95 (neuralbool -> SAME .)
    CTEFLOAT        reduce using rule 95 (neuralbool -> SAME .)
    CTECHAR         reduce using rule 95 (neuralbool -> SAME .)
    ID              reduce using rule 95 (neuralbool -> SAME .)


state 121

    (96) neuralbool -> NOTSAME .

    LEFTPAR         reduce using rule 96 (neuralbool -> NOTSAME .)
    CTEINT          reduce using rule 96 (neuralbool -> NOTSAME .)
    CTEFLOAT        reduce using rule 96 (neuralbool -> NOTSAME .)
    CTECHAR         reduce using rule 96 (neuralbool -> NOTSAME .)
    ID              reduce using rule 96 (neuralbool -> NOTSAME .)


state 122

    (97) neuralbool -> NOT .

    LEFTPAR         reduce using rule 97 (neuralbool -> NOT .)
    CTEINT          reduce using rule 97 (neuralbool -> NOT .)
    CTEFLOAT        reduce using rule 97 (neuralbool -> NOT .)
    CTECHAR         reduce using rule 97 (neuralbool -> NOT .)
    ID              reduce using rule 97 (neuralbool -> NOT .)


state 123

    (98) arithexp -> geoexp arithexp1 .

    GREATER         reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    GREATERAND      reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    LESSER          reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    LESSERAND       reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    SAME            reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    NOTSAME         reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    NOT             reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    AND             reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    OR              reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    READ            reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    WRITE           reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    RETURN          reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    IF              reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    FOR             reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    ID              reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    WHILE           reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    LEFTPAR         reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    CTEINT          reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    CTEFLOAT        reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    CTECHAR         reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    RIGHTBR         reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    RIGHTPAR        reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    RIGHTSQR        reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    COMMA           reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    SEMICOLON       reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    TO              reduce using rule 98 (arithexp -> geoexp arithexp1 .)
    DO              reduce using rule 98 (arithexp -> geoexp arithexp1 .)


state 124

    (99) arithexp1 -> neuralarith . arithexp
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    arithexp                       shift and go to state 158
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 125

    (100) arithexp1 -> empty .

    GREATER         reduce using rule 100 (arithexp1 -> empty .)
    GREATERAND      reduce using rule 100 (arithexp1 -> empty .)
    LESSER          reduce using rule 100 (arithexp1 -> empty .)
    LESSERAND       reduce using rule 100 (arithexp1 -> empty .)
    SAME            reduce using rule 100 (arithexp1 -> empty .)
    NOTSAME         reduce using rule 100 (arithexp1 -> empty .)
    NOT             reduce using rule 100 (arithexp1 -> empty .)
    AND             reduce using rule 100 (arithexp1 -> empty .)
    OR              reduce using rule 100 (arithexp1 -> empty .)
    READ            reduce using rule 100 (arithexp1 -> empty .)
    WRITE           reduce using rule 100 (arithexp1 -> empty .)
    RETURN          reduce using rule 100 (arithexp1 -> empty .)
    IF              reduce using rule 100 (arithexp1 -> empty .)
    FOR             reduce using rule 100 (arithexp1 -> empty .)
    ID              reduce using rule 100 (arithexp1 -> empty .)
    WHILE           reduce using rule 100 (arithexp1 -> empty .)
    LEFTPAR         reduce using rule 100 (arithexp1 -> empty .)
    CTEINT          reduce using rule 100 (arithexp1 -> empty .)
    CTEFLOAT        reduce using rule 100 (arithexp1 -> empty .)
    CTECHAR         reduce using rule 100 (arithexp1 -> empty .)
    RIGHTBR         reduce using rule 100 (arithexp1 -> empty .)
    RIGHTPAR        reduce using rule 100 (arithexp1 -> empty .)
    RIGHTSQR        reduce using rule 100 (arithexp1 -> empty .)
    COMMA           reduce using rule 100 (arithexp1 -> empty .)
    SEMICOLON       reduce using rule 100 (arithexp1 -> empty .)
    TO              reduce using rule 100 (arithexp1 -> empty .)
    DO              reduce using rule 100 (arithexp1 -> empty .)


state 126

    (101) neuralarith -> PLUS .

    LEFTPAR         reduce using rule 101 (neuralarith -> PLUS .)
    CTEINT          reduce using rule 101 (neuralarith -> PLUS .)
    CTEFLOAT        reduce using rule 101 (neuralarith -> PLUS .)
    CTECHAR         reduce using rule 101 (neuralarith -> PLUS .)
    ID              reduce using rule 101 (neuralarith -> PLUS .)


state 127

    (102) neuralarith -> REST .

    LEFTPAR         reduce using rule 102 (neuralarith -> REST .)
    CTEINT          reduce using rule 102 (neuralarith -> REST .)
    CTEFLOAT        reduce using rule 102 (neuralarith -> REST .)
    CTECHAR         reduce using rule 102 (neuralarith -> REST .)
    ID              reduce using rule 102 (neuralarith -> REST .)


state 128

    (103) geoexp -> finexp geoexp1 .

    PLUS            reduce using rule 103 (geoexp -> finexp geoexp1 .)
    REST            reduce using rule 103 (geoexp -> finexp geoexp1 .)
    GREATER         reduce using rule 103 (geoexp -> finexp geoexp1 .)
    GREATERAND      reduce using rule 103 (geoexp -> finexp geoexp1 .)
    LESSER          reduce using rule 103 (geoexp -> finexp geoexp1 .)
    LESSERAND       reduce using rule 103 (geoexp -> finexp geoexp1 .)
    SAME            reduce using rule 103 (geoexp -> finexp geoexp1 .)
    NOTSAME         reduce using rule 103 (geoexp -> finexp geoexp1 .)
    NOT             reduce using rule 103 (geoexp -> finexp geoexp1 .)
    AND             reduce using rule 103 (geoexp -> finexp geoexp1 .)
    OR              reduce using rule 103 (geoexp -> finexp geoexp1 .)
    READ            reduce using rule 103 (geoexp -> finexp geoexp1 .)
    WRITE           reduce using rule 103 (geoexp -> finexp geoexp1 .)
    RETURN          reduce using rule 103 (geoexp -> finexp geoexp1 .)
    IF              reduce using rule 103 (geoexp -> finexp geoexp1 .)
    FOR             reduce using rule 103 (geoexp -> finexp geoexp1 .)
    ID              reduce using rule 103 (geoexp -> finexp geoexp1 .)
    WHILE           reduce using rule 103 (geoexp -> finexp geoexp1 .)
    LEFTPAR         reduce using rule 103 (geoexp -> finexp geoexp1 .)
    CTEINT          reduce using rule 103 (geoexp -> finexp geoexp1 .)
    CTEFLOAT        reduce using rule 103 (geoexp -> finexp geoexp1 .)
    CTECHAR         reduce using rule 103 (geoexp -> finexp geoexp1 .)
    RIGHTBR         reduce using rule 103 (geoexp -> finexp geoexp1 .)
    RIGHTPAR        reduce using rule 103 (geoexp -> finexp geoexp1 .)
    RIGHTSQR        reduce using rule 103 (geoexp -> finexp geoexp1 .)
    COMMA           reduce using rule 103 (geoexp -> finexp geoexp1 .)
    SEMICOLON       reduce using rule 103 (geoexp -> finexp geoexp1 .)
    TO              reduce using rule 103 (geoexp -> finexp geoexp1 .)
    DO              reduce using rule 103 (geoexp -> finexp geoexp1 .)


state 129

    (104) geoexp1 -> neuralgeo . geoexp
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    geoexp                         shift and go to state 159
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 130

    (105) geoexp1 -> empty .

    PLUS            reduce using rule 105 (geoexp1 -> empty .)
    REST            reduce using rule 105 (geoexp1 -> empty .)
    GREATER         reduce using rule 105 (geoexp1 -> empty .)
    GREATERAND      reduce using rule 105 (geoexp1 -> empty .)
    LESSER          reduce using rule 105 (geoexp1 -> empty .)
    LESSERAND       reduce using rule 105 (geoexp1 -> empty .)
    SAME            reduce using rule 105 (geoexp1 -> empty .)
    NOTSAME         reduce using rule 105 (geoexp1 -> empty .)
    NOT             reduce using rule 105 (geoexp1 -> empty .)
    AND             reduce using rule 105 (geoexp1 -> empty .)
    OR              reduce using rule 105 (geoexp1 -> empty .)
    READ            reduce using rule 105 (geoexp1 -> empty .)
    WRITE           reduce using rule 105 (geoexp1 -> empty .)
    RETURN          reduce using rule 105 (geoexp1 -> empty .)
    IF              reduce using rule 105 (geoexp1 -> empty .)
    FOR             reduce using rule 105 (geoexp1 -> empty .)
    ID              reduce using rule 105 (geoexp1 -> empty .)
    WHILE           reduce using rule 105 (geoexp1 -> empty .)
    LEFTPAR         reduce using rule 105 (geoexp1 -> empty .)
    CTEINT          reduce using rule 105 (geoexp1 -> empty .)
    CTEFLOAT        reduce using rule 105 (geoexp1 -> empty .)
    CTECHAR         reduce using rule 105 (geoexp1 -> empty .)
    RIGHTBR         reduce using rule 105 (geoexp1 -> empty .)
    RIGHTPAR        reduce using rule 105 (geoexp1 -> empty .)
    RIGHTSQR        reduce using rule 105 (geoexp1 -> empty .)
    COMMA           reduce using rule 105 (geoexp1 -> empty .)
    SEMICOLON       reduce using rule 105 (geoexp1 -> empty .)
    TO              reduce using rule 105 (geoexp1 -> empty .)
    DO              reduce using rule 105 (geoexp1 -> empty .)


state 131

    (106) neuralgeo -> TIMES .

    LEFTPAR         reduce using rule 106 (neuralgeo -> TIMES .)
    CTEINT          reduce using rule 106 (neuralgeo -> TIMES .)
    CTEFLOAT        reduce using rule 106 (neuralgeo -> TIMES .)
    CTECHAR         reduce using rule 106 (neuralgeo -> TIMES .)
    ID              reduce using rule 106 (neuralgeo -> TIMES .)


state 132

    (107) neuralgeo -> DIVIDE .

    LEFTPAR         reduce using rule 107 (neuralgeo -> DIVIDE .)
    CTEINT          reduce using rule 107 (neuralgeo -> DIVIDE .)
    CTEFLOAT        reduce using rule 107 (neuralgeo -> DIVIDE .)
    CTECHAR         reduce using rule 107 (neuralgeo -> DIVIDE .)
    ID              reduce using rule 107 (neuralgeo -> DIVIDE .)


state 133

    (110) finexp -> addparenth exp . popparenth
    (109) popparenth -> . RIGHTPAR

    RIGHTPAR        shift and go to state 161

    popparenth                     shift and go to state 160

state 134

    (115) cteexp -> ID . neuralexist paramsexp
    (116) neuralexist -> .

    LEFTPAR         reduce using rule 116 (neuralexist -> .)
    LEFTSQR         reduce using rule 116 (neuralexist -> .)
    TIMES           reduce using rule 116 (neuralexist -> .)
    DIVIDE          reduce using rule 116 (neuralexist -> .)
    PLUS            reduce using rule 116 (neuralexist -> .)
    REST            reduce using rule 116 (neuralexist -> .)
    GREATER         reduce using rule 116 (neuralexist -> .)
    GREATERAND      reduce using rule 116 (neuralexist -> .)
    LESSER          reduce using rule 116 (neuralexist -> .)
    LESSERAND       reduce using rule 116 (neuralexist -> .)
    SAME            reduce using rule 116 (neuralexist -> .)
    NOTSAME         reduce using rule 116 (neuralexist -> .)
    NOT             reduce using rule 116 (neuralexist -> .)
    AND             reduce using rule 116 (neuralexist -> .)
    OR              reduce using rule 116 (neuralexist -> .)
    RIGHTPAR        reduce using rule 116 (neuralexist -> .)
    RIGHTSQR        reduce using rule 116 (neuralexist -> .)
    COMMA           reduce using rule 116 (neuralexist -> .)
    READ            reduce using rule 116 (neuralexist -> .)
    WRITE           reduce using rule 116 (neuralexist -> .)
    RETURN          reduce using rule 116 (neuralexist -> .)
    IF              reduce using rule 116 (neuralexist -> .)
    FOR             reduce using rule 116 (neuralexist -> .)
    ID              reduce using rule 116 (neuralexist -> .)
    WHILE           reduce using rule 116 (neuralexist -> .)
    CTEINT          reduce using rule 116 (neuralexist -> .)
    CTEFLOAT        reduce using rule 116 (neuralexist -> .)
    CTECHAR         reduce using rule 116 (neuralexist -> .)
    RIGHTBR         reduce using rule 116 (neuralexist -> .)
    SEMICOLON       reduce using rule 116 (neuralexist -> .)
    TO              reduce using rule 116 (neuralexist -> .)
    DO              reduce using rule 116 (neuralexist -> .)

    neuralexist                    shift and go to state 108

state 135

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl . LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules

    LEFTBR          shift and go to state 162


state 136

    (25) parameters -> typing COLON neuralinsertid idarray . mulparams
    (28) mulparams -> . COMMA parameters
    (29) mulparams -> . empty
    (117) empty -> .

    COMMA           shift and go to state 164
    RIGHTPAR        reduce using rule 117 (empty -> .)

    mulparams                      shift and go to state 163
    empty                          shift and go to state 165

state 137

    (11) varsmul -> COMMA neuralinsertvar varsarr varsmul .

    INT             reduce using rule 11 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FLOAT           reduce using rule 11 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    CHAR            reduce using rule 11 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    FUNCTION        reduce using rule 11 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    MAIN            reduce using rule 11 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)
    LEFTBR          reduce using rule 11 (varsmul -> COMMA neuralinsertvar varsarr varsmul .)


state 138

    (52) assign -> neuralassign1 idarray neuralassign2 . assignexp SEMICOLON
    (55) assignexp -> . exp
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    assignexp                      shift and go to state 166
    exp                            shift and go to state 167
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 139

    (54) neuralassign2 -> EQUAL .

    LEFTPAR         reduce using rule 54 (neuralassign2 -> EQUAL .)
    CTEINT          reduce using rule 54 (neuralassign2 -> EQUAL .)
    CTEFLOAT        reduce using rule 54 (neuralassign2 -> EQUAL .)
    CTECHAR         reduce using rule 54 (neuralassign2 -> EQUAL .)
    ID              reduce using rule 54 (neuralassign2 -> EQUAL .)


state 140

    (79) idarray -> LEFTSQR exp . RIGHTSQR

    RIGHTSQR        shift and go to state 168


state 141

    (63) reading -> READ LEFTPAR neuralread . idarray mulread RIGHTPAR SEMICOLON
    (79) idarray -> . LEFTSQR exp RIGHTSQR
    (80) idarray -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 96
    COMMA           reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)

    idarray                        shift and go to state 169
    empty                          shift and go to state 97

state 142

    (64) neuralread -> ID .

    LEFTSQR         reduce using rule 64 (neuralread -> ID .)
    COMMA           reduce using rule 64 (neuralread -> ID .)
    RIGHTPAR        reduce using rule 64 (neuralread -> ID .)


state 143

    (56) writing -> WRITE LEFTPAR auxwrite . mulwrite RIGHTPAR SEMICOLON
    (61) mulwrite -> . COMMA auxwrite mulwrite
    (62) mulwrite -> . empty
    (117) empty -> .

    COMMA           shift and go to state 171
    RIGHTPAR        reduce using rule 117 (empty -> .)

    mulwrite                       shift and go to state 170
    empty                          shift and go to state 172

state 144

    (57) auxwrite -> writetyping .

    COMMA           reduce using rule 57 (auxwrite -> writetyping .)
    RIGHTPAR        reduce using rule 57 (auxwrite -> writetyping .)


state 145

    (58) auxwrite -> exp .

    COMMA           reduce using rule 58 (auxwrite -> exp .)
    RIGHTPAR        reduce using rule 58 (auxwrite -> exp .)


state 146

    (59) writetyping -> STRING .

    COMMA           reduce using rule 59 (writetyping -> STRING .)
    RIGHTPAR        reduce using rule 59 (writetyping -> STRING .)


state 147

    (60) writetyping -> CTECHAR .
    (114) cteexp -> CTECHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 60 (writetyping -> CTECHAR .)
  ! reduce/reduce conflict for RIGHTPAR resolved using rule 60 (writetyping -> CTECHAR .)
    COMMA           reduce using rule 60 (writetyping -> CTECHAR .)
    RIGHTPAR        reduce using rule 60 (writetyping -> CTECHAR .)
    TIMES           reduce using rule 114 (cteexp -> CTECHAR .)
    DIVIDE          reduce using rule 114 (cteexp -> CTECHAR .)
    PLUS            reduce using rule 114 (cteexp -> CTECHAR .)
    REST            reduce using rule 114 (cteexp -> CTECHAR .)
    GREATER         reduce using rule 114 (cteexp -> CTECHAR .)
    GREATERAND      reduce using rule 114 (cteexp -> CTECHAR .)
    LESSER          reduce using rule 114 (cteexp -> CTECHAR .)
    LESSERAND       reduce using rule 114 (cteexp -> CTECHAR .)
    SAME            reduce using rule 114 (cteexp -> CTECHAR .)
    NOTSAME         reduce using rule 114 (cteexp -> CTECHAR .)
    NOT             reduce using rule 114 (cteexp -> CTECHAR .)
    AND             reduce using rule 114 (cteexp -> CTECHAR .)
    OR              reduce using rule 114 (cteexp -> CTECHAR .)

  ! COMMA           [ reduce using rule 114 (cteexp -> CTECHAR .) ]
  ! RIGHTPAR        [ reduce using rule 114 (cteexp -> CTECHAR .) ]


state 148

    (39) returning -> RETURN LEFTPAR exp . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 173


state 149

    (67) ifing -> IF LEFTPAR exp . neuralif THEN LEFTBR statutes RIGHTBR elsing
    (68) neuralif -> . RIGHTPAR

    RIGHTPAR        shift and go to state 175

    neuralif                       shift and go to state 174

state 150

    (72) whiling -> neuralwhile1 LEFTPAR exp . neuralwhile2 DO LEFTBR statutes RIGHTBR
    (74) neuralwhile2 -> . RIGHTPAR

    RIGHTPAR        shift and go to state 177

    neuralwhile2                   shift and go to state 176

state 151

    (75) foring -> FOR neuralfor1 idarray . EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR

    EQUAL           shift and go to state 178


state 152

    (82) exp1 -> OR exp .

    READ            reduce using rule 82 (exp1 -> OR exp .)
    WRITE           reduce using rule 82 (exp1 -> OR exp .)
    RETURN          reduce using rule 82 (exp1 -> OR exp .)
    IF              reduce using rule 82 (exp1 -> OR exp .)
    FOR             reduce using rule 82 (exp1 -> OR exp .)
    ID              reduce using rule 82 (exp1 -> OR exp .)
    WHILE           reduce using rule 82 (exp1 -> OR exp .)
    LEFTPAR         reduce using rule 82 (exp1 -> OR exp .)
    CTEINT          reduce using rule 82 (exp1 -> OR exp .)
    CTEFLOAT        reduce using rule 82 (exp1 -> OR exp .)
    CTECHAR         reduce using rule 82 (exp1 -> OR exp .)
    RIGHTBR         reduce using rule 82 (exp1 -> OR exp .)
    RIGHTPAR        reduce using rule 82 (exp1 -> OR exp .)
    RIGHTSQR        reduce using rule 82 (exp1 -> OR exp .)
    COMMA           reduce using rule 82 (exp1 -> OR exp .)
    SEMICOLON       reduce using rule 82 (exp1 -> OR exp .)
    TO              reduce using rule 82 (exp1 -> OR exp .)
    DO              reduce using rule 82 (exp1 -> OR exp .)


state 153

    (115) cteexp -> ID neuralexist paramsexp .

    TIMES           reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    DIVIDE          reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    PLUS            reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    REST            reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    GREATER         reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    GREATERAND      reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    LESSER          reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    LESSERAND       reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    SAME            reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    NOTSAME         reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    NOT             reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    AND             reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    OR              reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    READ            reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    WRITE           reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    RETURN          reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    IF              reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    FOR             reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    ID              reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    WHILE           reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    LEFTPAR         reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    CTEINT          reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    CTEFLOAT        reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    CTECHAR         reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    RIGHTBR         reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    RIGHTPAR        reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    RIGHTSQR        reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    COMMA           reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    SEMICOLON       reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    TO              reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)
    DO              reduce using rule 115 (cteexp -> ID neuralexist paramsexp .)


state 154

    (30) paramsexp -> LEFTPAR . neuralera paramsexp2 neuralpar
    (36) neuralera -> .

    LEFTPAR         reduce using rule 36 (neuralera -> .)
    CTEINT          reduce using rule 36 (neuralera -> .)
    CTEFLOAT        reduce using rule 36 (neuralera -> .)
    CTECHAR         reduce using rule 36 (neuralera -> .)
    ID              reduce using rule 36 (neuralera -> .)
    RIGHTPAR        reduce using rule 36 (neuralera -> .)

    neuralera                      shift and go to state 179

state 155

    (31) paramsexp -> idarray .

    TIMES           reduce using rule 31 (paramsexp -> idarray .)
    DIVIDE          reduce using rule 31 (paramsexp -> idarray .)
    PLUS            reduce using rule 31 (paramsexp -> idarray .)
    REST            reduce using rule 31 (paramsexp -> idarray .)
    GREATER         reduce using rule 31 (paramsexp -> idarray .)
    GREATERAND      reduce using rule 31 (paramsexp -> idarray .)
    LESSER          reduce using rule 31 (paramsexp -> idarray .)
    LESSERAND       reduce using rule 31 (paramsexp -> idarray .)
    SAME            reduce using rule 31 (paramsexp -> idarray .)
    NOTSAME         reduce using rule 31 (paramsexp -> idarray .)
    NOT             reduce using rule 31 (paramsexp -> idarray .)
    AND             reduce using rule 31 (paramsexp -> idarray .)
    OR              reduce using rule 31 (paramsexp -> idarray .)
    READ            reduce using rule 31 (paramsexp -> idarray .)
    WRITE           reduce using rule 31 (paramsexp -> idarray .)
    RETURN          reduce using rule 31 (paramsexp -> idarray .)
    IF              reduce using rule 31 (paramsexp -> idarray .)
    FOR             reduce using rule 31 (paramsexp -> idarray .)
    ID              reduce using rule 31 (paramsexp -> idarray .)
    WHILE           reduce using rule 31 (paramsexp -> idarray .)
    LEFTPAR         reduce using rule 31 (paramsexp -> idarray .)
    CTEINT          reduce using rule 31 (paramsexp -> idarray .)
    CTEFLOAT        reduce using rule 31 (paramsexp -> idarray .)
    CTECHAR         reduce using rule 31 (paramsexp -> idarray .)
    RIGHTBR         reduce using rule 31 (paramsexp -> idarray .)
    RIGHTPAR        reduce using rule 31 (paramsexp -> idarray .)
    RIGHTSQR        reduce using rule 31 (paramsexp -> idarray .)
    COMMA           reduce using rule 31 (paramsexp -> idarray .)
    SEMICOLON       reduce using rule 31 (paramsexp -> idarray .)
    TO              reduce using rule 31 (paramsexp -> idarray .)
    DO              reduce using rule 31 (paramsexp -> idarray .)


state 156

    (85) andexp1 -> neuraland andexp .

    OR              reduce using rule 85 (andexp1 -> neuraland andexp .)
    READ            reduce using rule 85 (andexp1 -> neuraland andexp .)
    WRITE           reduce using rule 85 (andexp1 -> neuraland andexp .)
    RETURN          reduce using rule 85 (andexp1 -> neuraland andexp .)
    IF              reduce using rule 85 (andexp1 -> neuraland andexp .)
    FOR             reduce using rule 85 (andexp1 -> neuraland andexp .)
    ID              reduce using rule 85 (andexp1 -> neuraland andexp .)
    WHILE           reduce using rule 85 (andexp1 -> neuraland andexp .)
    LEFTPAR         reduce using rule 85 (andexp1 -> neuraland andexp .)
    CTEINT          reduce using rule 85 (andexp1 -> neuraland andexp .)
    CTEFLOAT        reduce using rule 85 (andexp1 -> neuraland andexp .)
    CTECHAR         reduce using rule 85 (andexp1 -> neuraland andexp .)
    RIGHTBR         reduce using rule 85 (andexp1 -> neuraland andexp .)
    RIGHTPAR        reduce using rule 85 (andexp1 -> neuraland andexp .)
    RIGHTSQR        reduce using rule 85 (andexp1 -> neuraland andexp .)
    COMMA           reduce using rule 85 (andexp1 -> neuraland andexp .)
    SEMICOLON       reduce using rule 85 (andexp1 -> neuraland andexp .)
    TO              reduce using rule 85 (andexp1 -> neuraland andexp .)
    DO              reduce using rule 85 (andexp1 -> neuraland andexp .)


state 157

    (89) boolexp1 -> neuralbool arithexp .

    AND             reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    OR              reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    READ            reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    WRITE           reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    RETURN          reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    IF              reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    FOR             reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    ID              reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    WHILE           reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    LEFTPAR         reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    CTEINT          reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    CTEFLOAT        reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    CTECHAR         reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    RIGHTBR         reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    RIGHTPAR        reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    RIGHTSQR        reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    COMMA           reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    SEMICOLON       reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    TO              reduce using rule 89 (boolexp1 -> neuralbool arithexp .)
    DO              reduce using rule 89 (boolexp1 -> neuralbool arithexp .)


state 158

    (99) arithexp1 -> neuralarith arithexp .

    GREATER         reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    GREATERAND      reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    LESSER          reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    LESSERAND       reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    SAME            reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    NOTSAME         reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    NOT             reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    AND             reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    OR              reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    READ            reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    WRITE           reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    RETURN          reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    IF              reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    FOR             reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    ID              reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    WHILE           reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    LEFTPAR         reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    CTEINT          reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    CTEFLOAT        reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    CTECHAR         reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    RIGHTBR         reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    RIGHTPAR        reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    RIGHTSQR        reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    COMMA           reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    SEMICOLON       reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    TO              reduce using rule 99 (arithexp1 -> neuralarith arithexp .)
    DO              reduce using rule 99 (arithexp1 -> neuralarith arithexp .)


state 159

    (104) geoexp1 -> neuralgeo geoexp .

    PLUS            reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    REST            reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    GREATER         reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    GREATERAND      reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    LESSER          reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    LESSERAND       reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    SAME            reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    NOTSAME         reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    NOT             reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    AND             reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    OR              reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    READ            reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    WRITE           reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    RETURN          reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    IF              reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    FOR             reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    ID              reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    WHILE           reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    LEFTPAR         reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    CTEINT          reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    CTEFLOAT        reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    CTECHAR         reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    RIGHTBR         reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    RIGHTPAR        reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    RIGHTSQR        reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    COMMA           reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    SEMICOLON       reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    TO              reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)
    DO              reduce using rule 104 (geoexp1 -> neuralgeo geoexp .)


state 160

    (110) finexp -> addparenth exp popparenth .

    TIMES           reduce using rule 110 (finexp -> addparenth exp popparenth .)
    DIVIDE          reduce using rule 110 (finexp -> addparenth exp popparenth .)
    PLUS            reduce using rule 110 (finexp -> addparenth exp popparenth .)
    REST            reduce using rule 110 (finexp -> addparenth exp popparenth .)
    GREATER         reduce using rule 110 (finexp -> addparenth exp popparenth .)
    GREATERAND      reduce using rule 110 (finexp -> addparenth exp popparenth .)
    LESSER          reduce using rule 110 (finexp -> addparenth exp popparenth .)
    LESSERAND       reduce using rule 110 (finexp -> addparenth exp popparenth .)
    SAME            reduce using rule 110 (finexp -> addparenth exp popparenth .)
    NOTSAME         reduce using rule 110 (finexp -> addparenth exp popparenth .)
    NOT             reduce using rule 110 (finexp -> addparenth exp popparenth .)
    AND             reduce using rule 110 (finexp -> addparenth exp popparenth .)
    OR              reduce using rule 110 (finexp -> addparenth exp popparenth .)
    READ            reduce using rule 110 (finexp -> addparenth exp popparenth .)
    WRITE           reduce using rule 110 (finexp -> addparenth exp popparenth .)
    RETURN          reduce using rule 110 (finexp -> addparenth exp popparenth .)
    IF              reduce using rule 110 (finexp -> addparenth exp popparenth .)
    FOR             reduce using rule 110 (finexp -> addparenth exp popparenth .)
    ID              reduce using rule 110 (finexp -> addparenth exp popparenth .)
    WHILE           reduce using rule 110 (finexp -> addparenth exp popparenth .)
    LEFTPAR         reduce using rule 110 (finexp -> addparenth exp popparenth .)
    CTEINT          reduce using rule 110 (finexp -> addparenth exp popparenth .)
    CTEFLOAT        reduce using rule 110 (finexp -> addparenth exp popparenth .)
    CTECHAR         reduce using rule 110 (finexp -> addparenth exp popparenth .)
    RIGHTBR         reduce using rule 110 (finexp -> addparenth exp popparenth .)
    RIGHTPAR        reduce using rule 110 (finexp -> addparenth exp popparenth .)
    RIGHTSQR        reduce using rule 110 (finexp -> addparenth exp popparenth .)
    COMMA           reduce using rule 110 (finexp -> addparenth exp popparenth .)
    SEMICOLON       reduce using rule 110 (finexp -> addparenth exp popparenth .)
    TO              reduce using rule 110 (finexp -> addparenth exp popparenth .)
    DO              reduce using rule 110 (finexp -> addparenth exp popparenth .)


state 161

    (109) popparenth -> RIGHTPAR .

    TIMES           reduce using rule 109 (popparenth -> RIGHTPAR .)
    DIVIDE          reduce using rule 109 (popparenth -> RIGHTPAR .)
    PLUS            reduce using rule 109 (popparenth -> RIGHTPAR .)
    REST            reduce using rule 109 (popparenth -> RIGHTPAR .)
    GREATER         reduce using rule 109 (popparenth -> RIGHTPAR .)
    GREATERAND      reduce using rule 109 (popparenth -> RIGHTPAR .)
    LESSER          reduce using rule 109 (popparenth -> RIGHTPAR .)
    LESSERAND       reduce using rule 109 (popparenth -> RIGHTPAR .)
    SAME            reduce using rule 109 (popparenth -> RIGHTPAR .)
    NOTSAME         reduce using rule 109 (popparenth -> RIGHTPAR .)
    NOT             reduce using rule 109 (popparenth -> RIGHTPAR .)
    AND             reduce using rule 109 (popparenth -> RIGHTPAR .)
    OR              reduce using rule 109 (popparenth -> RIGHTPAR .)
    READ            reduce using rule 109 (popparenth -> RIGHTPAR .)
    WRITE           reduce using rule 109 (popparenth -> RIGHTPAR .)
    RETURN          reduce using rule 109 (popparenth -> RIGHTPAR .)
    IF              reduce using rule 109 (popparenth -> RIGHTPAR .)
    FOR             reduce using rule 109 (popparenth -> RIGHTPAR .)
    ID              reduce using rule 109 (popparenth -> RIGHTPAR .)
    WHILE           reduce using rule 109 (popparenth -> RIGHTPAR .)
    LEFTPAR         reduce using rule 109 (popparenth -> RIGHTPAR .)
    CTEINT          reduce using rule 109 (popparenth -> RIGHTPAR .)
    CTEFLOAT        reduce using rule 109 (popparenth -> RIGHTPAR .)
    CTECHAR         reduce using rule 109 (popparenth -> RIGHTPAR .)
    RIGHTBR         reduce using rule 109 (popparenth -> RIGHTPAR .)
    RIGHTPAR        reduce using rule 109 (popparenth -> RIGHTPAR .)
    RIGHTSQR        reduce using rule 109 (popparenth -> RIGHTPAR .)
    COMMA           reduce using rule 109 (popparenth -> RIGHTPAR .)
    SEMICOLON       reduce using rule 109 (popparenth -> RIGHTPAR .)
    TO              reduce using rule 109 (popparenth -> RIGHTPAR .)
    DO              reduce using rule 109 (popparenth -> RIGHTPAR .)


state 162

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR . startfunc statutes RIGHTBR funcsize neuralendfuncs modules
    (24) startfunc -> .

    READ            reduce using rule 24 (startfunc -> .)
    WRITE           reduce using rule 24 (startfunc -> .)
    RETURN          reduce using rule 24 (startfunc -> .)
    IF              reduce using rule 24 (startfunc -> .)
    FOR             reduce using rule 24 (startfunc -> .)
    ID              reduce using rule 24 (startfunc -> .)
    WHILE           reduce using rule 24 (startfunc -> .)
    LEFTPAR         reduce using rule 24 (startfunc -> .)
    CTEINT          reduce using rule 24 (startfunc -> .)
    CTEFLOAT        reduce using rule 24 (startfunc -> .)
    CTECHAR         reduce using rule 24 (startfunc -> .)
    RIGHTBR         reduce using rule 24 (startfunc -> .)

    startfunc                      shift and go to state 180

state 163

    (25) parameters -> typing COLON neuralinsertid idarray mulparams .

    RIGHTPAR        reduce using rule 25 (parameters -> typing COLON neuralinsertid idarray mulparams .)


state 164

    (28) mulparams -> COMMA . parameters
    (25) parameters -> . typing COLON neuralinsertid idarray mulparams
    (26) parameters -> . empty
    (13) typing -> . INT
    (14) typing -> . FLOAT
    (15) typing -> . CHAR
    (117) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    RIGHTPAR        reduce using rule 117 (empty -> .)

    parameters                     shift and go to state 181
    typing                         shift and go to state 36
    empty                          shift and go to state 37

state 165

    (29) mulparams -> empty .

    RIGHTPAR        reduce using rule 29 (mulparams -> empty .)


state 166

    (52) assign -> neuralassign1 idarray neuralassign2 assignexp . SEMICOLON

    SEMICOLON       shift and go to state 182


state 167

    (55) assignexp -> exp .

    SEMICOLON       reduce using rule 55 (assignexp -> exp .)


state 168

    (79) idarray -> LEFTSQR exp RIGHTSQR .

    EQUAL           reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    COMMA           reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTPAR        reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    TIMES           reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    DIVIDE          reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    PLUS            reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    REST            reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    GREATER         reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    GREATERAND      reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    LESSER          reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    LESSERAND       reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    SAME            reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    NOTSAME         reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    NOT             reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    AND             reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    OR              reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    READ            reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    WRITE           reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    RETURN          reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    IF              reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    FOR             reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    ID              reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    WHILE           reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    LEFTPAR         reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTEINT          reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTEFLOAT        reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    CTECHAR         reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTBR         reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    RIGHTSQR        reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    SEMICOLON       reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    TO              reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)
    DO              reduce using rule 79 (idarray -> LEFTSQR exp RIGHTSQR .)


state 169

    (63) reading -> READ LEFTPAR neuralread idarray . mulread RIGHTPAR SEMICOLON
    (65) mulread -> . COMMA ID idarray mulread
    (66) mulread -> . empty
    (117) empty -> .

    COMMA           shift and go to state 184
    RIGHTPAR        reduce using rule 117 (empty -> .)

    mulread                        shift and go to state 183
    empty                          shift and go to state 185

state 170

    (56) writing -> WRITE LEFTPAR auxwrite mulwrite . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 186


state 171

    (61) mulwrite -> COMMA . auxwrite mulwrite
    (57) auxwrite -> . writetyping
    (58) auxwrite -> . exp
    (59) writetyping -> . STRING
    (60) writetyping -> . CTECHAR
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    STRING          shift and go to state 146
    CTECHAR         shift and go to state 147
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    ID              shift and go to state 134

    auxwrite                       shift and go to state 187
    writetyping                    shift and go to state 144
    exp                            shift and go to state 145
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 172

    (62) mulwrite -> empty .

    RIGHTPAR        reduce using rule 62 (mulwrite -> empty .)


state 173

    (39) returning -> RETURN LEFTPAR exp RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 188


state 174

    (67) ifing -> IF LEFTPAR exp neuralif . THEN LEFTBR statutes RIGHTBR elsing

    THEN            shift and go to state 189


state 175

    (68) neuralif -> RIGHTPAR .

    THEN            reduce using rule 68 (neuralif -> RIGHTPAR .)


state 176

    (72) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 190


state 177

    (74) neuralwhile2 -> RIGHTPAR .

    DO              reduce using rule 74 (neuralwhile2 -> RIGHTPAR .)


state 178

    (75) foring -> FOR neuralfor1 idarray EQUAL . exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 191
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 179

    (30) paramsexp -> LEFTPAR neuralera . paramsexp2 neuralpar
    (32) paramsexp2 -> . exp neuralpar2 auxparamsexp2
    (33) paramsexp2 -> . empty
    (81) exp -> . andexp exp1
    (117) empty -> .
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    RIGHTPAR        reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    paramsexp2                     shift and go to state 192
    exp                            shift and go to state 193
    empty                          shift and go to state 194
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 180

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc . statutes RIGHTBR funcsize neuralendfuncs modules
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (117) empty -> .
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    RIGHTBR         reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    statutes                       shift and go to state 195
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    empty                          shift and go to state 67
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 181

    (28) mulparams -> COMMA parameters .

    RIGHTPAR        reduce using rule 28 (mulparams -> COMMA parameters .)


state 182

    (52) assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .

    READ            reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    WRITE           reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    RETURN          reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    IF              reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    FOR             reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    ID              reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    WHILE           reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    LEFTPAR         reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    CTEINT          reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    CTEFLOAT        reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    CTECHAR         reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)
    RIGHTBR         reduce using rule 52 (assign -> neuralassign1 idarray neuralassign2 assignexp SEMICOLON .)


state 183

    (63) reading -> READ LEFTPAR neuralread idarray mulread . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 196


state 184

    (65) mulread -> COMMA . ID idarray mulread

    ID              shift and go to state 197


state 185

    (66) mulread -> empty .

    RIGHTPAR        reduce using rule 66 (mulread -> empty .)


state 186

    (56) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 198


state 187

    (61) mulwrite -> COMMA auxwrite . mulwrite
    (61) mulwrite -> . COMMA auxwrite mulwrite
    (62) mulwrite -> . empty
    (117) empty -> .

    COMMA           shift and go to state 171
    RIGHTPAR        reduce using rule 117 (empty -> .)

    mulwrite                       shift and go to state 199
    empty                          shift and go to state 172

state 188

    (39) returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .

    READ            reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    IF              reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    ID              reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 39 (returning -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)


state 189

    (67) ifing -> IF LEFTPAR exp neuralif THEN . LEFTBR statutes RIGHTBR elsing

    LEFTBR          shift and go to state 200


state 190

    (72) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 201


state 191

    (75) foring -> FOR neuralfor1 idarray EQUAL exp . neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (77) neuralfor2 -> . TO

    TO              shift and go to state 203

    neuralfor2                     shift and go to state 202

state 192

    (30) paramsexp -> LEFTPAR neuralera paramsexp2 . neuralpar
    (37) neuralpar -> . RIGHTPAR

    RIGHTPAR        shift and go to state 205

    neuralpar                      shift and go to state 204

state 193

    (32) paramsexp2 -> exp . neuralpar2 auxparamsexp2
    (38) neuralpar2 -> .

    COMMA           reduce using rule 38 (neuralpar2 -> .)
    RIGHTPAR        reduce using rule 38 (neuralpar2 -> .)

    neuralpar2                     shift and go to state 206

state 194

    (33) paramsexp2 -> empty .

    RIGHTPAR        reduce using rule 33 (paramsexp2 -> empty .)


state 195

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes . RIGHTBR funcsize neuralendfuncs modules

    RIGHTBR         shift and go to state 207


state 196

    (63) reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 208


state 197

    (65) mulread -> COMMA ID . idarray mulread
    (79) idarray -> . LEFTSQR exp RIGHTSQR
    (80) idarray -> . empty
    (117) empty -> .

    LEFTSQR         shift and go to state 96
    COMMA           reduce using rule 117 (empty -> .)
    RIGHTPAR        reduce using rule 117 (empty -> .)

    idarray                        shift and go to state 209
    empty                          shift and go to state 97

state 198

    (56) writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .

    READ            reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    IF              reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    ID              reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 56 (writing -> WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON .)


state 199

    (61) mulwrite -> COMMA auxwrite mulwrite .

    RIGHTPAR        reduce using rule 61 (mulwrite -> COMMA auxwrite mulwrite .)


state 200

    (67) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR . statutes RIGHTBR elsing
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (117) empty -> .
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    RIGHTBR         reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    exp                            shift and go to state 57
    statutes                       shift and go to state 210
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    empty                          shift and go to state 67
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 201

    (72) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR . statutes RIGHTBR
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (117) empty -> .
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    RIGHTBR         reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    neuralwhile1                   shift and go to state 64
    exp                            shift and go to state 57
    statutes                       shift and go to state 211
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    andexp                         shift and go to state 66
    empty                          shift and go to state 67
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 202

    (75) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 . exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 212
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 203

    (77) neuralfor2 -> TO .

    LEFTPAR         reduce using rule 77 (neuralfor2 -> TO .)
    CTEINT          reduce using rule 77 (neuralfor2 -> TO .)
    CTEFLOAT        reduce using rule 77 (neuralfor2 -> TO .)
    CTECHAR         reduce using rule 77 (neuralfor2 -> TO .)
    ID              reduce using rule 77 (neuralfor2 -> TO .)


state 204

    (30) paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .

    TIMES           reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    DIVIDE          reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    PLUS            reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    REST            reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    GREATER         reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    GREATERAND      reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    LESSER          reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    LESSERAND       reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    SAME            reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    NOTSAME         reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    NOT             reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    AND             reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    OR              reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    READ            reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    WRITE           reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RETURN          reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    IF              reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    FOR             reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    ID              reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    WHILE           reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    LEFTPAR         reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    CTEINT          reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    CTEFLOAT        reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    CTECHAR         reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RIGHTBR         reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RIGHTPAR        reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    RIGHTSQR        reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    COMMA           reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    SEMICOLON       reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    TO              reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)
    DO              reduce using rule 30 (paramsexp -> LEFTPAR neuralera paramsexp2 neuralpar .)


state 205

    (37) neuralpar -> RIGHTPAR .

    TIMES           reduce using rule 37 (neuralpar -> RIGHTPAR .)
    DIVIDE          reduce using rule 37 (neuralpar -> RIGHTPAR .)
    PLUS            reduce using rule 37 (neuralpar -> RIGHTPAR .)
    REST            reduce using rule 37 (neuralpar -> RIGHTPAR .)
    GREATER         reduce using rule 37 (neuralpar -> RIGHTPAR .)
    GREATERAND      reduce using rule 37 (neuralpar -> RIGHTPAR .)
    LESSER          reduce using rule 37 (neuralpar -> RIGHTPAR .)
    LESSERAND       reduce using rule 37 (neuralpar -> RIGHTPAR .)
    SAME            reduce using rule 37 (neuralpar -> RIGHTPAR .)
    NOTSAME         reduce using rule 37 (neuralpar -> RIGHTPAR .)
    NOT             reduce using rule 37 (neuralpar -> RIGHTPAR .)
    AND             reduce using rule 37 (neuralpar -> RIGHTPAR .)
    OR              reduce using rule 37 (neuralpar -> RIGHTPAR .)
    READ            reduce using rule 37 (neuralpar -> RIGHTPAR .)
    WRITE           reduce using rule 37 (neuralpar -> RIGHTPAR .)
    RETURN          reduce using rule 37 (neuralpar -> RIGHTPAR .)
    IF              reduce using rule 37 (neuralpar -> RIGHTPAR .)
    FOR             reduce using rule 37 (neuralpar -> RIGHTPAR .)
    ID              reduce using rule 37 (neuralpar -> RIGHTPAR .)
    WHILE           reduce using rule 37 (neuralpar -> RIGHTPAR .)
    LEFTPAR         reduce using rule 37 (neuralpar -> RIGHTPAR .)
    CTEINT          reduce using rule 37 (neuralpar -> RIGHTPAR .)
    CTEFLOAT        reduce using rule 37 (neuralpar -> RIGHTPAR .)
    CTECHAR         reduce using rule 37 (neuralpar -> RIGHTPAR .)
    RIGHTBR         reduce using rule 37 (neuralpar -> RIGHTPAR .)
    RIGHTPAR        reduce using rule 37 (neuralpar -> RIGHTPAR .)
    RIGHTSQR        reduce using rule 37 (neuralpar -> RIGHTPAR .)
    COMMA           reduce using rule 37 (neuralpar -> RIGHTPAR .)
    SEMICOLON       reduce using rule 37 (neuralpar -> RIGHTPAR .)
    TO              reduce using rule 37 (neuralpar -> RIGHTPAR .)
    DO              reduce using rule 37 (neuralpar -> RIGHTPAR .)


state 206

    (32) paramsexp2 -> exp neuralpar2 . auxparamsexp2
    (34) auxparamsexp2 -> . COMMA exp auxparamsexp2
    (35) auxparamsexp2 -> . empty
    (117) empty -> .

    COMMA           shift and go to state 214
    RIGHTPAR        reduce using rule 117 (empty -> .)

    auxparamsexp2                  shift and go to state 213
    empty                          shift and go to state 215

state 207

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR . funcsize neuralendfuncs modules
    (23) funcsize -> .

    FUNCTION        reduce using rule 23 (funcsize -> .)
    MAIN            reduce using rule 23 (funcsize -> .)

    funcsize                       shift and go to state 216

state 208

    (63) reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .

    READ            reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    IF              reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    ID              reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    LEFTPAR         reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTEINT          reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTEFLOAT        reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    CTECHAR         reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 63 (reading -> READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON .)


state 209

    (65) mulread -> COMMA ID idarray . mulread
    (65) mulread -> . COMMA ID idarray mulread
    (66) mulread -> . empty
    (117) empty -> .

    COMMA           shift and go to state 184
    RIGHTPAR        reduce using rule 117 (empty -> .)

    mulread                        shift and go to state 217
    empty                          shift and go to state 185

state 210

    (67) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes . RIGHTBR elsing

    RIGHTBR         shift and go to state 218


state 211

    (72) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 219


state 212

    (75) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp . neuralfor3 LEFTBR statutes RIGHTBR
    (78) neuralfor3 -> . DO

    DO              shift and go to state 221

    neuralfor3                     shift and go to state 220

state 213

    (32) paramsexp2 -> exp neuralpar2 auxparamsexp2 .

    RIGHTPAR        reduce using rule 32 (paramsexp2 -> exp neuralpar2 auxparamsexp2 .)


state 214

    (34) auxparamsexp2 -> COMMA . exp auxparamsexp2
    (81) exp -> . andexp exp1
    (84) andexp -> . boolexp andexp1
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78
    ID              shift and go to state 134

    exp                            shift and go to state 222
    andexp                         shift and go to state 66
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 215

    (35) auxparamsexp2 -> empty .

    RIGHTPAR        reduce using rule 35 (auxparamsexp2 -> empty .)


state 216

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize . neuralendfuncs modules
    (22) neuralendfuncs -> .

    FUNCTION        reduce using rule 22 (neuralendfuncs -> .)
    MAIN            reduce using rule 22 (neuralendfuncs -> .)

    neuralendfuncs                 shift and go to state 223

state 217

    (65) mulread -> COMMA ID idarray mulread .

    RIGHTPAR        reduce using rule 65 (mulread -> COMMA ID idarray mulread .)


state 218

    (67) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR . elsing
    (69) elsing -> . neuralelse LEFTBR statutes RIGHTBR
    (70) elsing -> . empty
    (71) neuralelse -> . ELSE
    (117) empty -> .

    ELSE            shift and go to state 227
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    FOR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    LEFTPAR         reduce using rule 117 (empty -> .)
    CTEINT          reduce using rule 117 (empty -> .)
    CTEFLOAT        reduce using rule 117 (empty -> .)
    CTECHAR         reduce using rule 117 (empty -> .)
    RIGHTBR         reduce using rule 117 (empty -> .)

    elsing                         shift and go to state 224
    neuralelse                     shift and go to state 225
    empty                          shift and go to state 226

state 219

    (72) whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .

    READ            reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 72 (whiling -> neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR .)


state 220

    (75) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 228


state 221

    (78) neuralfor3 -> DO .

    LEFTBR          reduce using rule 78 (neuralfor3 -> DO .)


state 222

    (34) auxparamsexp2 -> COMMA exp . auxparamsexp2
    (34) auxparamsexp2 -> . COMMA exp auxparamsexp2
    (35) auxparamsexp2 -> . empty
    (117) empty -> .

    COMMA           shift and go to state 214
    RIGHTPAR        reduce using rule 117 (empty -> .)

    auxparamsexp2                  shift and go to state 229
    empty                          shift and go to state 215

state 223

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs . modules
    (16) modules -> . FUNCTION functype neuralinsertfuncname funcparam
    (17) modules -> . empty
    (117) empty -> .

    FUNCTION        shift and go to state 10
    MAIN            reduce using rule 117 (empty -> .)

    modules                        shift and go to state 230
    empty                          shift and go to state 11

state 224

    (67) ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .

    READ            reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    WRITE           reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    RETURN          reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    IF              reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    FOR             reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    ID              reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    WHILE           reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    LEFTPAR         reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTEINT          reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTEFLOAT        reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    CTECHAR         reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)
    RIGHTBR         reduce using rule 67 (ifing -> IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing .)


state 225

    (69) elsing -> neuralelse . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 231


state 226

    (70) elsing -> empty .

    READ            reduce using rule 70 (elsing -> empty .)
    WRITE           reduce using rule 70 (elsing -> empty .)
    RETURN          reduce using rule 70 (elsing -> empty .)
    IF              reduce using rule 70 (elsing -> empty .)
    FOR             reduce using rule 70 (elsing -> empty .)
    ID              reduce using rule 70 (elsing -> empty .)
    WHILE           reduce using rule 70 (elsing -> empty .)
    LEFTPAR         reduce using rule 70 (elsing -> empty .)
    CTEINT          reduce using rule 70 (elsing -> empty .)
    CTEFLOAT        reduce using rule 70 (elsing -> empty .)
    CTECHAR         reduce using rule 70 (elsing -> empty .)
    RIGHTBR         reduce using rule 70 (elsing -> empty .)


state 227

    (71) neuralelse -> ELSE .

    LEFTBR          reduce using rule 71 (neuralelse -> ELSE .)


state 228

    (75) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR . statutes RIGHTBR
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (117) empty -> .
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    RIGHTBR         reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    exp                            shift and go to state 57
    statutes                       shift and go to state 232
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    empty                          shift and go to state 67
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 229

    (34) auxparamsexp2 -> COMMA exp auxparamsexp2 .

    RIGHTPAR        reduce using rule 34 (auxparamsexp2 -> COMMA exp auxparamsexp2 .)


state 230

    (21) funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules .

    MAIN            reduce using rule 21 (funcparam -> LEFTPAR parameters RIGHTPAR SEMICOLON varsgl LEFTBR startfunc statutes RIGHTBR funcsize neuralendfuncs modules .)


state 231

    (69) elsing -> neuralelse LEFTBR . statutes RIGHTBR
    (40) statutes -> . assign statutesaux
    (41) statutes -> . reading statutesaux
    (42) statutes -> . writing statutesaux
    (43) statutes -> . returning statutesaux
    (44) statutes -> . ifing statutesaux
    (45) statutes -> . whiling statutesaux
    (46) statutes -> . foring statutesaux
    (47) statutes -> . exp statutesaux
    (48) statutes -> . specialfunc statutesaux
    (52) assign -> . neuralassign1 idarray neuralassign2 assignexp SEMICOLON
    (63) reading -> . READ LEFTPAR neuralread idarray mulread RIGHTPAR SEMICOLON
    (56) writing -> . WRITE LEFTPAR auxwrite mulwrite RIGHTPAR SEMICOLON
    (39) returning -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (67) ifing -> . IF LEFTPAR exp neuralif THEN LEFTBR statutes RIGHTBR elsing
    (72) whiling -> . neuralwhile1 LEFTPAR exp neuralwhile2 DO LEFTBR statutes RIGHTBR
    (75) foring -> . FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR
    (81) exp -> . andexp exp1
    (51) specialfunc -> . empty
    (53) neuralassign1 -> . ID
    (73) neuralwhile1 -> . WHILE
    (84) andexp -> . boolexp andexp1
    (117) empty -> .
    (88) boolexp -> . arithexp boolexp1
    (98) arithexp -> . geoexp arithexp1
    (103) geoexp -> . finexp geoexp1
    (110) finexp -> . addparenth exp popparenth
    (111) finexp -> . cteexp
    (108) addparenth -> . LEFTPAR
    (112) cteexp -> . CTEINT
    (113) cteexp -> . CTEFLOAT
    (114) cteexp -> . CTECHAR
    (115) cteexp -> . ID neuralexist paramsexp

  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
    READ            shift and go to state 60
    WRITE           shift and go to state 61
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 65
    ID              shift and go to state 68
    WHILE           shift and go to state 69
    RIGHTBR         reduce using rule 117 (empty -> .)
    LEFTPAR         shift and go to state 48
    CTEINT          shift and go to state 76
    CTEFLOAT        shift and go to state 77
    CTECHAR         shift and go to state 78

  ! READ            [ reduce using rule 117 (empty -> .) ]
  ! WRITE           [ reduce using rule 117 (empty -> .) ]
  ! RETURN          [ reduce using rule 117 (empty -> .) ]
  ! IF              [ reduce using rule 117 (empty -> .) ]
  ! FOR             [ reduce using rule 117 (empty -> .) ]
  ! ID              [ reduce using rule 117 (empty -> .) ]
  ! WHILE           [ reduce using rule 117 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 117 (empty -> .) ]
  ! CTEINT          [ reduce using rule 117 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 117 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 117 (empty -> .) ]

    statutes                       shift and go to state 233
    assign                         shift and go to state 50
    reading                        shift and go to state 51
    writing                        shift and go to state 52
    returning                      shift and go to state 53
    ifing                          shift and go to state 54
    whiling                        shift and go to state 55
    foring                         shift and go to state 56
    exp                            shift and go to state 57
    specialfunc                    shift and go to state 58
    neuralassign1                  shift and go to state 59
    neuralwhile1                   shift and go to state 64
    andexp                         shift and go to state 66
    empty                          shift and go to state 67
    boolexp                        shift and go to state 70
    arithexp                       shift and go to state 71
    geoexp                         shift and go to state 72
    finexp                         shift and go to state 73
    addparenth                     shift and go to state 74
    cteexp                         shift and go to state 75

state 232

    (75) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 234


state 233

    (69) elsing -> neuralelse LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 235


state 234

    (75) foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .

    READ            reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 75 (foring -> FOR neuralfor1 idarray EQUAL exp neuralfor2 exp neuralfor3 LEFTBR statutes RIGHTBR .)


state 235

    (69) elsing -> neuralelse LEFTBR statutes RIGHTBR .

    READ            reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    ID              reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    LEFTPAR         reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTEINT          reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTEFLOAT        reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    CTECHAR         reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 69 (elsing -> neuralelse LEFTBR statutes RIGHTBR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for READ in state 42 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 42 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for FOR in state 42 resolved as shift
WARNING: shift/reduce conflict for ID in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 42 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 42 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 42 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 42 resolved as shift
WARNING: shift/reduce conflict for READ in state 50 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 50 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 50 resolved as shift
WARNING: shift/reduce conflict for IF in state 50 resolved as shift
WARNING: shift/reduce conflict for FOR in state 50 resolved as shift
WARNING: shift/reduce conflict for ID in state 50 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 50 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 50 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 50 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 50 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 50 resolved as shift
WARNING: shift/reduce conflict for READ in state 51 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 51 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 51 resolved as shift
WARNING: shift/reduce conflict for IF in state 51 resolved as shift
WARNING: shift/reduce conflict for FOR in state 51 resolved as shift
WARNING: shift/reduce conflict for ID in state 51 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 51 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 51 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 51 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 51 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 51 resolved as shift
WARNING: shift/reduce conflict for READ in state 52 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 52 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 52 resolved as shift
WARNING: shift/reduce conflict for IF in state 52 resolved as shift
WARNING: shift/reduce conflict for FOR in state 52 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 52 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 52 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 52 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 52 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 52 resolved as shift
WARNING: shift/reduce conflict for READ in state 53 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 53 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 53 resolved as shift
WARNING: shift/reduce conflict for IF in state 53 resolved as shift
WARNING: shift/reduce conflict for FOR in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 53 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 53 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 53 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 53 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 53 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 53 resolved as shift
WARNING: shift/reduce conflict for READ in state 54 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 54 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for FOR in state 54 resolved as shift
WARNING: shift/reduce conflict for ID in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 54 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 54 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 54 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 54 resolved as shift
WARNING: shift/reduce conflict for READ in state 55 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 55 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 55 resolved as shift
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for FOR in state 55 resolved as shift
WARNING: shift/reduce conflict for ID in state 55 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 55 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 55 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 55 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 55 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 55 resolved as shift
WARNING: shift/reduce conflict for READ in state 56 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 56 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 56 resolved as shift
WARNING: shift/reduce conflict for IF in state 56 resolved as shift
WARNING: shift/reduce conflict for FOR in state 56 resolved as shift
WARNING: shift/reduce conflict for ID in state 56 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 56 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 56 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 56 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 56 resolved as shift
WARNING: shift/reduce conflict for READ in state 57 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 57 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for FOR in state 57 resolved as shift
WARNING: shift/reduce conflict for ID in state 57 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 57 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 57 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 57 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 57 resolved as shift
WARNING: shift/reduce conflict for READ in state 58 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 58 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 58 resolved as shift
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for ID in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 58 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 58 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 108 resolved as shift
WARNING: shift/reduce conflict for READ in state 180 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 180 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 180 resolved as shift
WARNING: shift/reduce conflict for IF in state 180 resolved as shift
WARNING: shift/reduce conflict for FOR in state 180 resolved as shift
WARNING: shift/reduce conflict for ID in state 180 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 180 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 180 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 180 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 180 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 180 resolved as shift
WARNING: shift/reduce conflict for READ in state 200 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 200 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 200 resolved as shift
WARNING: shift/reduce conflict for IF in state 200 resolved as shift
WARNING: shift/reduce conflict for FOR in state 200 resolved as shift
WARNING: shift/reduce conflict for ID in state 200 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 200 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 200 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 200 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 200 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 200 resolved as shift
WARNING: shift/reduce conflict for READ in state 201 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 201 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 201 resolved as shift
WARNING: shift/reduce conflict for IF in state 201 resolved as shift
WARNING: shift/reduce conflict for FOR in state 201 resolved as shift
WARNING: shift/reduce conflict for ID in state 201 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 201 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 201 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 201 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 201 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 201 resolved as shift
WARNING: shift/reduce conflict for READ in state 228 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 228 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 228 resolved as shift
WARNING: shift/reduce conflict for IF in state 228 resolved as shift
WARNING: shift/reduce conflict for FOR in state 228 resolved as shift
WARNING: shift/reduce conflict for ID in state 228 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 228 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 228 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 228 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 228 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 228 resolved as shift
WARNING: shift/reduce conflict for READ in state 231 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 231 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 231 resolved as shift
WARNING: shift/reduce conflict for IF in state 231 resolved as shift
WARNING: shift/reduce conflict for FOR in state 231 resolved as shift
WARNING: shift/reduce conflict for ID in state 231 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 231 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 231 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 231 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 231 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 231 resolved as shift
WARNING: reduce/reduce conflict in state 68 resolved using rule (neuralassign1 -> ID)
WARNING: rejected rule (neuralexist -> <empty>) in state 68
WARNING: reduce/reduce conflict in state 86 resolved using rule (statutesaux -> empty)
WARNING: rejected rule (specialfunc -> empty) in state 86
WARNING: reduce/reduce conflict in state 147 resolved using rule (writetyping -> CTECHAR)
WARNING: rejected rule (cteexp -> CTECHAR) in state 147
